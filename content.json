{"meta":{"title":"周超的博客","subtitle":"记录编程学习的历程","description":"","author":"周超","url":"https://lao-biao.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-07-05T14:18:21.000Z","updated":"2020-07-06T03:06:29.459Z","comments":true,"path":"categories/index.html","permalink":"https://lao-biao.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-07-06T02:24:53.000Z","updated":"2020-07-06T02:42:01.088Z","comments":true,"path":"guestbook/index.html","permalink":"https://lao-biao.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-05T15:02:47.000Z","updated":"2020-07-06T03:06:47.053Z","comments":true,"path":"tags/index.html","permalink":"https://lao-biao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM虚拟机","slug":"JVM虚拟机","date":"2020-07-14T15:03:22.000Z","updated":"2020-07-15T00:24:55.962Z","comments":true,"path":"articles/18701caa.html","link":"","permalink":"https://lao-biao.github.io/articles/18701caa.html","excerpt":"JVM基础java从编码到执行 JVM：从跨平台的语言到跨语言的平台 jvmjava虚拟机 java virtual machine jvm是一种规范 java虚拟机规范 java virtual machine specifications jvm是虚构出来的一台计算机 字节码指令集（汇编语言） 内存管理：栈 堆 方法区等 jvm分代模型 新生代（Young Generation） 老年代（(Old Generation） 持久代（Permanent Generation）：用于存储静态文件 JDK 8 中已经把持久代（PermGen Space）移除了，取而代之的元空间（Metaspace）。Metaspace占用的是本地内存，不再占用虚拟机内存。 jvm与class文件格式jvm与java无关，任何语言都可以通过编译成字节码文件在jvm上运行。 12graph TB;A[任何语言]--&gt;B(class字节码)--&gt;C[JVM虚拟机] 常见的JVM实现Hotspot Oracle官方，做实验用的JVM java -version Jrockit BEA公司开发，曾经号称世界上最快的JVM 被Oracle收购 J9-IBMIBM公司开发，类似于Hotspot，主要用于IBM自己的产品。 Microsoft VM微软虚拟机 TaobaoVMHotspot深度定制版 LiquidVM直接针对硬件 azul zing最新垃圾回收的行业标杆 JDK-JRE-JVMJDK：开发集成工具+jre，java开发工具包，部署java开发环境 JRE：核心库+jvm，运行java环境 JVM：运行最终的字节码文件","text":"JVM基础java从编码到执行 JVM：从跨平台的语言到跨语言的平台 jvmjava虚拟机 java virtual machine jvm是一种规范 java虚拟机规范 java virtual machine specifications jvm是虚构出来的一台计算机 字节码指令集（汇编语言） 内存管理：栈 堆 方法区等 jvm分代模型 新生代（Young Generation） 老年代（(Old Generation） 持久代（Permanent Generation）：用于存储静态文件 JDK 8 中已经把持久代（PermGen Space）移除了，取而代之的元空间（Metaspace）。Metaspace占用的是本地内存，不再占用虚拟机内存。 jvm与class文件格式jvm与java无关，任何语言都可以通过编译成字节码文件在jvm上运行。 12graph TB;A[任何语言]--&gt;B(class字节码)--&gt;C[JVM虚拟机] 常见的JVM实现Hotspot Oracle官方，做实验用的JVM java -version Jrockit BEA公司开发，曾经号称世界上最快的JVM 被Oracle收购 J9-IBMIBM公司开发，类似于Hotspot，主要用于IBM自己的产品。 Microsoft VM微软虚拟机 TaobaoVMHotspot深度定制版 LiquidVM直接针对硬件 azul zing最新垃圾回收的行业标杆 JDK-JRE-JVMJDK：开发集成工具+jre，java开发工具包，部署java开发环境 JRE：核心库+jvm，运行java环境 JVM：运行最终的字节码文件 Garbage Collector 与 GC tuning垃圾回收与垃圾回收调优 垃圾的定义内存 多删 忘删：内存泄漏（Memory Leak） JVM中GC自动回收垃圾 java与c++垃圾回收比较java GC处理垃圾 开发效率高，执行效率低 C++ 手动处理垃圾 忘记回收：内存泄漏 回收多次：非法访问 开发效率低，执行效率高 垃圾的定位垃圾是如何定位的 Reference Count 算法引用计数 在空引用时进行回收 缺陷：RC不能解决循环引用的问题（一堆垃圾） Root Searching 根可达算法由根节点可以连接到达为有效对象，其他的视为垃圾。 以下可视为根节点 JVM stack main方法的栈帧 native method stack 本地方法栈 runtime constant pool 运行时的常量池 static references in method area 方法区内静态引用对象 Clazz 类对象 GC roots：线程变量、静态变量、常量池、JNI指针 注意： Java 不采用RC（Reference Count）算法，而是采用RS（Root Searching）算法。 常见垃圾回收算法常见GC 算法 Mark-Sweep 标记清除 Copying 拷贝 Mark-Compact 标记压缩 Mark-Sweep 标记清除 标记清除算法流程 优点： 算法相对简单 存活对象比较多的情况下效率较高 缺点： 扫描两次，效率偏低 容易产生碎片化：不能存放连续的对象 Copying 复制 复制算法流程 优点： 适用于存活对象较少的情况 只扫描一次，效率提高 没有碎片 缺点： 空间浪费，每次只有一半内存被使用 移动复制对象，需要调整对象的引用 Mark Compact 标记压缩 标记压缩算法流程 优点： 不会产生碎片，方便对象分配 不会产生内存减半 缺点： 扫描两次 需要移动对象，效率偏低 垃圾回收器 JDK 1.8默认 PS+PO JDK 1.9 10 11 12 13 默认G1 常见垃圾回收器分类 Young、Old 分代模型，新生代和老生代配合使用 ParNew+CMS ParNew+Serial Old Serial+Serial Old Serial+CMS+Serial Old Parallel Scavenge+Parallel Old Parallel Scavenge+Serial Old G1：物理上不分代，逻辑上分代 堆内存逻辑分区（不适用不分代垃圾收集器）新生代大量死去，少量存活，采用复制算法 老年代存活率高，回收较少，采用MC（Mark Compact）或MS（Mark Sweep） CMS：经过6次GC–&gt;老年代 其他：经过15次GC GC概念MinorGC/YGC：年轻代空间耗尽时触发 MajorGC/FullGC：在老年代无法继续分配空间时触发，新生代老年代同时进行回收 GC详解栈上分配 线程私有小对象 无逃逸：栈中存在引用 支持标量替换 无需调整 线程本地分配TLAB（Thread Local Allocation Buffer） 占用eden，默认1% 多线程的时候不用竞争eden就可以申请空间，提高效率 小对象 无需调整 Old 老年代 大对象 eden 伊甸：对象刚出生时，刚new的时候 YGC与FGCYGC Young GC Minor（辅助） GC Eden区不足 FGC Full GC Major GC Old空间不足 System.gc() 对象何时进入老年代超过XX:MaxTenuringThreshold指定次数（YGC） Parallel Scavenge 经过15次GC进入老年代 CMS 经过6次GC进入老年代 G1 经过15次GC进入老年代 动态年龄 s1 - &gt; s2超过50% 把年龄最大的放入O（老年代） 通过参数：-XX:MaxTenuringThreshold配置 总结 ParNew垃圾回收器PS（Parallel Scavenge）的变种，用来配合CMS使用。 a stop-thr-world,copying collector with uses multiple GC threads. It differs from “Parallel Scavenge” in that it has enhancements that make it uasable with CMS. For example,”ParNew” doses the synchronization needed so that it can run during thr concurrent phases of CMS. 默认线程数位CPU的核数 Serial垃圾回收器与Serial Old垃圾回收器此种组合基本不使用，效率太低 串行 STW 单线程拷贝算法（工作在年轻代） Parallel Scavenge垃圾回收器 STW 多线程拷贝算法 Parallel Old垃圾回收器A compacting collector that uses multiple GC threads. 多线程压缩算法（工作在老年代） CMS垃圾回收器 并发标记清理concurrent mark sweep 高并发低停顿收集器a mostly concurrent，low-pause collector 4个阶段（从线程角度） 初始标记initial mark 并发标记concurrent mark 重新标记remark 并发清理concurrent sweep CMS垃圾回收器缺点 memory fragmentation -XX:CMSFullGCsBeforeCompaction floating garbage Concurrent Mode Failure -XX:CMSInitiatingOccupancyFraction 92% SerialOld CMS Remark阶段的算法三色扫描算法：白灰黑 在并发按标记时，引用可能产生变化，白色对象有可能被错误回收 解决方案 SATB 在起始的时候做一个快照 snapshot at the beginning 当B-&gt;D消失时，要把这个引用推到GC的堆栈，保证D还能被GC扫描到 配合RSet，只用扫描哪些Region引用到D这个Region（区域）了 Incremental Update 当一个白色对象被一个黑色对象引用 将黑色对象重新标记为灰色，让collector重新扫描 这个容易产生问题，比如 A a， A b 都已经标记完，但是 A a - D了，A成为灰色，这时mutator（设置方法）把A a 标记完了，又把 A变成了黑色 这也是为什么CMS的final mark必须再扫描一遍地原因 JVM调优什么是调优 根据需求进行JVM规划和预调优 优化运行JVM运行环境（慢、卡顿） 解决JVM运行过程中出现的任何问题（OOM） 调优方式简单粗暴的调优方式：重启 在线调优 JVM命令行参数HotSpot参数分类 标准：-开头，所有的HotSpot都支持 非标准：-X开头，特定版本HotSpot支持特定命令 不稳定：-XX开头，下个版本可能取消 123456java # 列出所有的HotSpot都支持的命令java -X # 列出特定版本HotSpot支持的特定命令Java -XX:+PrintFlagsWithComments # 只有debug版本能用java -XX:+PrintFlagsFinal # 列出所有不稳定命令 JVM调优实战将xms（程序启动时初始内存大小），xmx（程序运行时最大可用内存大小）设置成一致的好处是可以防止内存抖动。 问题背景OOM（Out Of Memory）：内存泄漏、内存溢出 当程序的GC垃圾回收在执行，而Memory只增不降，需要进行调优。 当执行到一定时间时，最终频繁Full GC ，每次GC只会回收2kB或1kB。 工具阿里开源JVM在线调优工具 arthas 文档：Arthas Arthas无法替代jvm唯一的命令jmap 12345top # 类似于任务管理器，通过此命令找到java程序运行的端口号top -Hp 1196 # 可以查看该进程下各个线程的cpu使用情况；jps # 用于查询正在运行的JVM进程jstat # 可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据jmap -histo 1196 | head -20 # 1196为运行端口号，以实际为主，20为获取前面的数据 问题：当服务器cpu出现飙高怎么处理 业务线程：列出堆栈，通过jmap命令找到占用内存最高的对象，无法进行GC处理掉的对象，查看代码，进行调整。 GC线程：通过在线调优工具进行排查 导致Full GC的原因： 年老代（Old）被写满 持久代（Perm）被写满 System.gc()被显示调用","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://lao-biao.github.io/tags/jvm/"}]},{"title":"Ajax笔记","slug":"Ajax笔记","date":"2020-07-12T02:47:12.000Z","updated":"2020-07-12T05:43:38.501Z","comments":true,"path":"articles/48d9bd16.html","link":"","permalink":"https://lao-biao.github.io/articles/48d9bd16.html","excerpt":"Ajax概述全称”Asynchronous JavaScript and XML” 异步JavaScript和XML，是一种创建交互网页应用的网页开发技术。 基于web标准(Standards-based Presentation) XHTML+CSS 使用DOM(Document Object Model)进行动态显示与交互 使用XML和XSLT进行数据交换及相关操作 使用XMLHttpRequest进行异步数据查询、检索 使用JavaScript将所有的东西绑定在一起 本质是一个浏览器端的技术 异步刷新技术，用来在当前页面响应不同的请求内容。","text":"Ajax概述全称”Asynchronous JavaScript and XML” 异步JavaScript和XML，是一种创建交互网页应用的网页开发技术。 基于web标准(Standards-based Presentation) XHTML+CSS 使用DOM(Document Object Model)进行动态显示与交互 使用XML和XSLT进行数据交换及相关操作 使用XMLHttpRequest进行异步数据查询、检索 使用JavaScript将所有的东西绑定在一起 本质是一个浏览器端的技术 异步刷新技术，用来在当前页面响应不同的请求内容。 Ajax功能需求：需要将本次的响应结果和前面的响应结果内容在同一个页面中展现给用户 解决: 在后台服务器端将多次相应内容重新拼接成一个jsp页面，响应对象，jsp内部使用，带有缓冲区的响应对象，效率高于response对象问题:造成相应你内容被重复的响应，资源浪费 使用Ajax技术 Ajax基本使用流程 创建ajax引擎对象 覆写onreadystatement函数 判断ajax状态码 判断响应状态码 获取相应内容 处理相应内容 发送请求 123456789101112131415161718192021222324252627282930313233// 创建ajax引擎对象var ajax;if (window.XMLHttpRequest) &#123; // firefox ajax = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // ie ajax = new ActiveXObject(\"Msxml2.XMLHTTP\");&#125;// 覆写onreadystatement函数ajax.onreadystatechange = function () &#123; // 会执行4次,判断ajax状态码，只在数据成功接收时执行以下代码 if (4 === ajax.readyState) &#123; // 获取元素对象 let showdiv = document.getElementById(\"showDiv\"); // 判断响应状态码 if (200 === ajax.status) &#123; // 获取响应内容，修改元素内容 showdiv.innerHTML = ajax.responseText; &#125;else if (404===ajax.status)&#123; showdiv.innerHTML=\"请求资源不存在\"; &#125;else if(500===ajax.status)&#123; showdiv.innerHTML=\"服务器繁忙\"; &#125; &#125;&#125;// 发送请求 get/post// get请求实体拼接在url后面，?隔开，键值对 ajax.open(\"get\", \"ajax?name=value\");ajax.send(null);// post请求有单独的请求实体， ajax.open(\"post\",\"ajax\");ajax.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");ajax.send(\"name=value\"); Ajax状态码readyState readyState值 含义 0 表示XMLHttpRequest已建立，但还未初始化，这是尚未调用open方法 1 表示open方法已经调用，但未调用send方法（已创建，未发送） 2 表示send方法已经调用，其他数据未知 3 表示请求已经成功发送，正在接收数据 4 表示数据已经成功接收 常用Http状态码 http状态码 含义 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在（可能输入了错误的URL） 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Ajax异步和同步ajax.open(method, url,async); method：get方法，post方法 url：请求的地址 async：设置代码执行方式，false同步，true异步,默认为异步 Ajax请求get：携带的数据包含在url中 12ajax.open(\"get\", url + (data === null ? \"\" : \"?\" + data), async); // false同步，true异步ajax.send(null); post 123ajax.open(\"post\", url, async); // false同步，true异步ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");ajax.send(data); Ajax响应数据类型普通字符串responseText 12// 获取响应数据var result = ajax.responseText; json将数据按照json的格式拼接好的字符串，方便使用eval方法将接受的字符串直接转换成js的对象 12345// json格式var obj=&#123; name:value, ...&#125;; 需求分类 在当前页面显示查询结果 创建ajax函数 调用ajax函数发送请求到UserServlet 调用业务层获取对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;title&gt;AjaxData&lt;/title&gt; &lt;!--引入外部js文件，见ajax封装--&gt; &lt;script type=\"text/javascript\" src=\"js/ajaxutil.js\"&gt;&lt;/script&gt; &lt;!--声明js代码域--&gt; &lt;script type=\"text/javascript\"&gt; var obj = &#123;&#125;; function getData() &#123; // 获取用户请求信息 var name = document.getElementById(\"uname\").value; // 创建ajax引擎对象 var ajax; if (window.XMLHttpRequest) &#123; // firefox ajax = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; // ie ajax = new window.ActiveXObject(\"Msxml2.XMLHTTP\"); &#125; // 覆写onreadystatementchange函数 ajax.onreadystatechange = function () &#123; // 判断ajax状态码 if (ajax.readyState === 4) &#123; // 判断响应状态码 if (ajax.status === 200) &#123; // 获取响应数据 var result = ajax.responseText; eval(\"u=\" + result); // 处理响应数据 // 获取table元素对象 var ta = document.getElementById(\"table\"); ta.innerHTML = \"\"; // 插入新的行 var tr = ta.insertRow(0); var uid = tr.insertCell(0); uid.innerHTML = \"编号\"; var uname = tr.insertCell(1); uname.innerHTML = \"英雄\"; var price = tr.insertCell(2); price.innerHTML = \"价格\"; var location = tr.insertCell(3); location.innerHTML = \"位置\"; var description = tr.insertCell(4); description.innerHTML = \"描述\"; var tr = ta.insertRow(1); var uid = tr.insertCell(0); uid.innerHTML = u.uid; var uname = tr.insertCell(1); uname.innerHTML = u.uname; var price = tr.insertCell(2); price.innerHTML = u.price; var location = tr.insertCell(3); location.innerHTML = u.location; var description = tr.insertCell(4); description.innerHTML = u.description; &#125; &#125; &#125; // 发送请求 ajax.open(\"get\", \"user?name=\" + name); ajax.send(null); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;AjaxData&lt;/h3&gt; &lt;hr&gt; 名称: &lt;input type=\"text\" name=\"uname\" value=\"\" id=\"uname\"&gt; &lt;input type=\"button\" value=\"搜索\" onclick=\"getData()\"&gt; &lt;hr&gt; &lt;table border=\"1px\" id=\"table\"&gt;&lt;/table&gt; &lt;/body&gt;&lt;/html&gt; XML数据responseXML，返回document对象通过document对象将数据从xml中获取出来 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;title&gt;XML数据格式学习&lt;/title&gt; &lt;!--声明js代码域--&gt; &lt;script type=\"text/javascript\"&gt; function getXML() &#123; // 创建ajax引擎对象 var ajax; if (window.XMLHttpRequest) &#123; ajax = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; ajax = new window.ActiveXObject(\"Msxml2.XMLHTTP\"); &#125; // 覆写onreadystatementchange函数 ajax.onreadystatechange = function () &#123; // 判断ajax状态码 if (ajax.readyState === 4) &#123; // 判断响应状态码 if (ajax.status === 200) &#123; // 获取响应数据 var result = ajax.responseXML; alert(result.getElementsByTagName(\"uname\")[0].innerHTML); &#125; &#125; &#125; // 发送请求 ajax.open(\"get\", \"xml\",true); ajax.send(null); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;XML数据格式学习&lt;/h3&gt; &lt;hr&gt; &lt;input type=\"button\" value=\"测试\" onclick=\"getXML()\"&gt; &lt;/body&gt;&lt;/html&gt; Ajax封装封装ajax方便调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * ajax封装 * @param method 请求方式，get或post * @param url 请求地址 * @param data 请求数据，格式\"name=value&amp;...\"，没有值需要传入null * @param deal200 接收一个带有一个形参的js函数对象，形参接收的实参是ajax引擎对象 * @param deal404 接收一个js函数对象 * @param deal500 接收一个js函数对象 * @param async 异步或同步，boolean */function myAjax(method, url, data, deal200, deal404, deal500, async=true) &#123; // 创建ajax引擎对象 var ajax = getAjax(); // 覆写onreadystatement函数 ajax.onreadystatechange = function () &#123; // 获取元素对象 let showdiv = document.getElementById(\"showDiv\"); // 会执行4次,判断ajax状态码，只在数据成功接收时执行以下代码 if (4 === ajax.readyState) &#123; // 判断响应状态码 if (200 === ajax.status) &#123; if (deal200) deal200(ajax); &#125; else if (404 === ajax.status) &#123; if (deal404) deal404(); &#125; else if (500 === ajax.status) &#123; if (deal500) deal500(); &#125; &#125; &#125; if (\"get\" === method) &#123; // 发送请求 ajax.open(\"get\", url + (data === null ? \"\" : \"?\" + data), async); // false同步，true异步 ajax.send(null); &#125; else if (\"post\" === method) &#123; ajax.open(\"post\", url, async); ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); ajax.send(data); &#125;&#125;/*ajax的封装*/function getAjax() &#123; var ajax; if (window.XMLHttpRequest) &#123; // firefox ajax = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; // ie ajax = new ActiveXObject(\"Msxml2.XMLHTTP\"); &#125; return ajax;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://lao-biao.github.io/tags/ajax/"}]},{"title":"Jsp-EL表达式-JSTL笔记","slug":"Jsp-EL表达式-JSTL笔记","date":"2020-07-12T02:45:37.000Z","updated":"2020-07-12T12:35:04.575Z","comments":true,"path":"articles/324a571.html","link":"","permalink":"https://lao-biao.github.io/articles/324a571.html","excerpt":"Jsp概念Java Server Pages，Java服务器页面 简化的Servlet设计 动态网页技术标准（数据的动态改变） 特点 本质上是Servlet 跨平台 组件跨平台 健壮性和安全性（业务逻辑，数据） 访问原理Tomcat只能识别Servlet，用户访问jsp文件，服务器用JspServlet将jsp文件转义成对应的Java文件，返回给用户 123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用JSP负责页面展现，Sevlet负责业务逻辑处理","text":"Jsp概念Java Server Pages，Java服务器页面 简化的Servlet设计 动态网页技术标准（数据的动态改变） 特点 本质上是Servlet 跨平台 组件跨平台 健壮性和安全性（业务逻辑，数据） 访问原理Tomcat只能识别Servlet，用户访问jsp文件，服务器用JspServlet将jsp文件转义成对应的Java文件，返回给用户 123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用JSP负责页面展现，Sevlet负责业务逻辑处理 Jsp的语法和指令Jsp三大指令 page指令：配置jsp文件的转译相关的参数 include指令：静态引入jsp文件 taglib指令：引入jstl标签库 jsp的三种注释前端语言注释(html,css,js)：会被转译，也会被发送，但是不会被浏览器执行 java语言注释(行注释，块注释，文档注释)：会被转译，但是不会被servlet执行 jsp注释：不会被转译 jsp的page指令 &lt;@ page attribute1=&quot;value&quot; attribute2=&quot;value&quot; ...%&gt; 作用：配置jsp文件的转译相关的参数 language:声明jsp要被转译的语言 import:声明转译java的java文件要导入的包，不同的包使用逗号隔开 pageEncoding:设置jsp文件的数据编码格式 contentType:设置jsp数据响应给浏览器时，浏览器的解析和编码格式 session:设置转译的Servlet是否开启session支持，默认开启，true开启，false关闭 errorPage:设置jsp运行错误跳转的页面 extends:设置jsp转译的java文件要继承的父类（包名+类名） jsp的局部代码块特点 布局代码块中声明的java代码会被原样转译到jsp对应的Servlet文件的_JspService方法中 代码块中声明的变量都是局部变量 使用：&lt;%java代码块%&gt; 缺点：使用局部代码块在jsp中进行逻辑判断，书写麻烦，阅读困难 开发：使用Sevlet进行请求逻辑处理，使用jsp进行页面展现 jsp的全局代码块特点：声明的java代码作为全局代码转译到对应的Servlet类中 使用：&lt;%!java全局代码块%&gt; 注意：全局代码块声明的代码，需要使用局部代码块调用 jsp的脚本段语句特点：帮助开发人员快速地获取变量或者方法的返回值作为数据响应给浏览器 使用：&lt;%=变量名或者方法%&gt; &lt;===&gt; out.write(变量名或方法); 注意：不要在变量名或者方法后使用分号 位置：除jsp语法要求以外的任意位置 jsp的静态引入和动态引入静态引入 &lt;%@include file=&quot;jsp文件相对地址&quot; %&gt; 特点： 会将引入的jsp文件和当前jsp文件转译成一个java（Servlet）文件使用 在网页中也就显示了合并后的显示效果 注意： 静态引入的jsp文件不会单独转译成java（Servlet）文件 同名变量 编译报错 Duplicate local variable 当前文件和静态引入的jsp文件中不能使用java代码块声明同名变量 动态引入&lt;jsp:include page=&quot;jsp文件相对地址&quot;/&gt; 特点： 会将引入的jsp文件单独转译，在当前文件转译好的java文件中调用引入的jsp文件的转译文件 在网页中显示合并后的显示效果 注意：动态引入允许文件中声明同名变量 优点：降低jsp代码的冗余，便于维护升级 jsp的转发标签使用：&lt;jsp:forward page=&quot;jsp文件相对地址&quot;&gt;&lt;/jsp:forward&gt; jsp文件相对地址 特点 一次请求 地址栏信息不变 注意：在转发标签的两个标签中间除了写&lt;jsp:param name=&quot;&quot; value=&quot;&quot;/&gt;子标签不会报错，其他任意字符都会报错&lt;%=request.getParameter(&quot;键名&quot;)%&gt;name属性为附带的数据的键名value属性为附带的数据的内容会将数据以?的形式在转发路径的后面 123&lt;jsp:forward page=\"要转发的jsp文件的相对路径\"&gt; &lt;jsp:param name=\"str\" value=\"a\"/&gt;&lt;/jsp:forward&gt; jsp内置对象内置对象jsp文件在转译其对应的Servlet文件的时候自动生成的并声明的对象，可以在jsp页面中直接使用。 注意内置对象在jsp页面中使用，使用局部代码块或者脚本段语句来使用，不能够在全局代码块中使用。 内容PageContext对象页面上下文对象，封存了其他内置对象。封存了当前jsp的运行信息 注意：每个jsp文件单独拥有一个PageContext对象 作用域：当前页面 Request对象封存当前请求数据的对象，由Tomcat服务器创建，作用域为一次请求。 12345&lt;%// 获取请求数据String s = request.getParameter(\"str\");request.getAttribute(\"str\");%&gt; Session对象存储用户的不同请求的共享数据，作用域为一次会话 Application对象ServletContext对象，一个项目只有一个，存储用户共享数据的对象，以及完成其他操作，项目内 Response对象响应对象，用来响应请求处理结果给浏览器的对象，设置响应头，重定向。 123&lt;% response.sendRedirect(\"forward.jsp\");%&gt; Out对象响应对象，jsp内部使用，带有缓冲区的响应对象，效率高于response对象 Page对象代表当前jsp对象，相当于java的this Exception对象异常对象，存储了当前运行的异常信息 注意：使用此对象需要在page指定使用属性isErrorPage=”true”开启 Congfig对象ServletConfig对象，主要用来获取web.xml中的配置数据，完成一些初始化数据据的读取 四个作用域对象pageContext：当前对象，解决了在当前页面的数据共享问题。获取其他内置对象 request:一次请求，一次请求的servlet的数据共享。通过请求转发将数据流转给下一个Servlet session:一次会话，一个用户的不同请求的数据共享。将数据从一次请求流转给其他请求 application:项目内，不同用户的数据共享问题。将数据从一个用户流转给其他用户 作用：数据流转 jsp资源路径在jsp中资源路径可以使用相对路径完成跳转，存在的问题 问题一：资源的位置不可随意更改 问题二：需要使用../进行文件夹的跳出，使用比较麻烦 使用绝对路径 /表示服务器根目录即localhost:8080/ /虚拟项目名/项目资源路径 举例：项目虚拟名为jsp 资源文件路径webapp/jsp/a/a.jsp &lt;a href=&quot;/jsp/a/a.jsp&quot;&gt;a.jsp&lt;/a&gt; webapp/jsp/jsppro.jsp &lt;a href=&quot;/jsp/jsppro.jsp&quot;&gt;jsppro.jsp&lt;/a&gt; 使用jsp中自带的全局路径声明1234567891011&lt;%String path = request.getContextPath();String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 作用：给资源前面添加项目路径http://127.0.0.1:8080/虚拟项目名/ EL表达式问题引入 Servlet进行请求处理后，使用作用域对象作为数据流转的载体，将数据流转给对应的jsp文件 在jsp中获取作用域中的数据 传统方式：在jsp页面中使用java脚本段语句 传统方式获取作用域数据 缺点一：要通过&lt;%@ page import=&quot;&quot;%&gt;导入包 缺点二：需要强制转换对象 缺点三：获取数据的代码过于麻烦 ElServlet.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@WebServlet(name = \"ElServlet\", urlPatterns = &#123;\"/es\"&#125;)public class ElServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 设置请求编码 req.setCharacterEncoding(\"utf-8\"); // 设置响应编码 resp.setContentType(\"text/html;charset=utf-8\"); // 获取请求信息 String uname = req.getParameter(\"uname\"); String pwd = req.getParameter(\"pwd\"); // 处理请求信息 System.out.println(uname + \"===\" + pwd); // 响应处理结果 // 使用request作用域进行数据流转 // 普通字符串 req.setAttribute(\"str\", \"今天天气很好!\"); // 对象类型 User u = new User(0, \"张三\", \"跑步\", new Address(\"湖北\", \"黄冈\", \"红安县\")); req.setAttribute(\"user\", u); // 集合类型 // List集合 // 存储普通字符串 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"周润发\"); list.add(\"刘德华\"); list.add(\"周星驰\"); req.setAttribute(\"list\", list); // 存储对象 User u2 = new User(1, \"李四\", \"游泳\", new Address(\"湖北\", \"武汉\", \"武昌区\")); List&lt;User&gt; lu = new ArrayList&lt;&gt;(); lu.add(u); lu.add(u2); req.setAttribute(\"lu\", lu); // Map集合 // 存储普通字符串 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"a\", \"北京\"); map.put(\"b\", \"上海\"); map.put(\"c\", \"广州\"); map.put(\"d\", \"深圳\"); req.setAttribute(\"map\", map); // 存储对象 Map&lt;String, User&gt; mu = new HashMap&lt;&gt;(); mu.put(\"a\", new User(2, \"张家辉\", \"演戏\", new Address(\"广东省\", \"广州市\", \"中山区\"))); req.setAttribute(\"mu\", mu); // 空值判断 req.setAttribute(\"s0\",\"\"); req.setAttribute(\"s1\",new User()); req.setAttribute(\"s2\",new ArrayList&lt;&gt;()); req.setAttribute(\"s3\",new HashMap&lt;&gt;()); req.getRequestDispatcher(\"/el.jsp\").forward(req, resp); return; &#125;&#125; 相关bean类 12345678910111213public class Address &#123; private String pre; private String city; private String town; getter/setter...&#125;public class User &#123; private int uid; private String uname; private String fav; private Address addr; getter/setter...&#125; jsp文件 12345678&lt;b&gt;&lt;%=request.getParameter(\"uname\")%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=request.getAttribute(\"str\")%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=((User) request.getAttribute(\"user\")).getAddr().getTown()%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=((ArrayList) request.getAttribute(\"list\")).get(1)%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=((User) ((ArrayList) request.getAttribute(\"lu\")).get(0)).getAddr().getPre()%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=((ArrayList&lt;User&gt;) request.getAttribute(\"lu\")).get(1).getAddr().getPre()%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=((HashMap) request.getAttribute(\"map\")).get(\"b\")%&gt;&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;%=((HashMap&lt;String, User&gt;) request.getAttribute(\"mu\")).get(\"a\").getAddr().getTown()%&gt;&lt;/b&gt; 概述全称：Expression Language，一种写法非常简洁的表达式，语法简单易懂，便于使用，表达式语言的灵感来自于ESMAScript和XPath表达式语言。 作用让jsp书写起来更加的方便，简化在jsp中获取作用域或者请求数据的写法，也会搭配JSTL来进行使用 使用语法结构：$(expression)提供.和[]两种运算符来存取数据 使用EL表达式获取请求数据获取用户请求数据 ${requset.attribute} 获取请求头数据 ${header} 返回所有的请求头数据 ${header[“键名”]} 返回指定键名的请求头数据 ${headerValues[“键名”]} 返回指定得键名(同键不同值) 123$&#123;header&#125;$&#123;header[\"User-Agent\"]&#125;$&#123;headerValues[\"Accept-Language\"][0]&#125; 获取Cookie数据 ${cookie} 返回存储了所有的cookie对象的map集合 ${cookie.键名} 返回指定的cookie对象 ${cookie.键名.name} 返回指定的cookie对象存储的数据的键名 ${cookie.键名.value} 返回指定的cookie对象存储的数据的值 12$&#123;cookie&#125;$&#123;cookie.JSESSIONID.value&#125; 使用EL表达式获取作用域数据获取作用域数据 request对象存储了请求数据 param.键名 返回的是值 request对象存储了请求数据 paramValues.键名 返回的是数组 通过setAttribute方法存储到作用域对象中的数据 ${键名} 返回键名所对应的值 注意 如果存储的是普通字符串则直接返回 如果存储的是对象，则返回的是对象 获取对象中的数据 普通对象:${键名.属性名.属性名…} 集合对象: list集合${键名[角标]} map集合${键名.map集合存储的键名} 作用域查找顺序默认查找顺序：pageContext–&gt;reqeust–&gt;session–&gt;application 注意：每次查找都从小到大进行查找，找到了则获取，不再继续找了 获取指定作用域的数据 ${requestScope.键名} ${pageScope.键名} ${sessionScope.键名} ${applicationScope.键名} 使用EL表达式进行运算算术运算${算术表达式} 关系运算${关系表达式} 逻辑运算${逻辑表达式} 三目运算${三目表达式} 注意：+表示加法运算，不表示字符连接，使用EL表达式进行字符连接会报错 1234567891+3=&gt;$&#123;1+3&#125;&lt;br&gt;1*2=&gt;$&#123;1*2&#125;&lt;br&gt;1/2=&gt;$&#123;1/2&#125;&lt;br&gt;4-2=&gt;$&#123;4-2&#125;&lt;br&gt;4%2=&gt;$&#123;4%2&#125;&lt;br&gt;4==3=&gt;$&#123;4==3&#125;&lt;br&gt;4&gt;2=&gt;$&#123;4&gt;2&#125;&lt;br&gt;1==1?'男':'女'=&gt;$&#123;1==1?'男':'女'&#125;&lt;br&gt;1+\"2\"=&gt;$&#123;1+\"2\"&#125; 使用EL表达式控制判断empty${empty 键名} 作用：判断键名对象的值是否存有数据 JSTL标签库概述JSTL是apache对EL表达式的扩展（JSTL依赖于EL），JSTL是标签语言。JSTL标签使用起来非常方便，它与JSP动作标签一样，只不过是它不是JSP内置的标签，需要导包，以及指定标签库。 使用MyEclipse开发JavaWeb，在项目发布到Tomcat时，MyEclipse会在lib目录下存放jstl的jar包。如果没有使用MyEclipse开发需要手动导入jar包。Maven项目需要导入JSTL的相关依赖。 作用用来提升在JSP页面的逻辑代码的编码效率，使用标签来替换逻辑代码的直接书写，高效、美观、整洁、易读。 内容 核心标签库 格式化标签库 JSTL的SQL标签库 JSTL的函数标签库 JSTL的XML标签库 菜鸟教程-JSTL：https://www.runoob.com/jsp/jsp-jstl.html JSTL的核心标签库 导入jar包 声明jstl标签库的引入(核心标签库) 12&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jstl/core\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jstl/core_rt\" %&gt; 基本标签&lt;c:out value=&quot;数据&quot; default=&quot;默认值&quot;/&gt; 数据可以作为常量值也可以是EL表达式 作用：将数据输出给客户端 &lt;c:set var=&quot;hello&quot; value=&quot;hello pageContext&quot; scope=&quot;page&quot;/&gt; 作用：存储数据到作用域对象中 var:表示存储的键名 value:表示存储的数据 scope:表示要存储的作用域对象 page request session application &lt;c:remove var=&quot;hello&quot; scope=&quot;request&quot;/&gt; 作用：删除作用域中指定键的数据 var:表示要删除的键的名字 scrope:表示要删除的作用域(可选) 注意：如果在不指定作用域的情况使用该标签删除数据，会将四个作用域对象中的符合要求的数据全部删除 逻辑标签123&lt;c:if test=\"\\$&#123;表达式&#125;\"&gt; 前端代码&lt;/c:if&gt; 作用：进行逻辑判断，相当于java代码的单分支判断。 注意：逻辑判断标签需要依赖于EL的逻辑运算，也就是表达式中涉及到的数据必须从作用域中拿。 12345&lt;c:choose&gt; &lt;c:when test=\"\"&gt;执行内容&lt;/c:when&gt; ... &lt;c:otherwise&gt;执行内容&lt;/c:otherwise&gt;&lt;/c:choose&gt; 作用:用来进行多条件逻辑判断，类似java中的多分支语句。 注意：条件成立只会执行一次，都不成立则执行otherwise。 循环标签123&lt;c:forEach begin=\"1\" end=\"4\" step=\"1\"&gt; 循环体&lt;/c:forEach&gt; 作用：循环内容进行处理 begin：声明循环开始位置 end：声明循环结束位置 step：设置循环步长 varStatus：声明变量记录每次循环的数据(角标、次数，是否是第一次循环，是否是最后一次循环) 注意:数据存储在作用域中，需要使用EL表达式获取 例如：${vs.index}–${vs.count}–​${vs.first}–​${vs.last} items：声明要遍历的对象，结合EL表达式获取对象 var：声明变量记录每次循环的结果，存储在作用域中，通过EL表达式获取对象 数据 123456789101112&lt;%ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");list.add(\"c\");request.setAttribute(\"list\", list);HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"hello\", \"Hello\");map.put(\"world\", \"world\");request.setAttribute(\"map\", map);%&gt; 123456789101112131415161718192021222324&lt;%--常量循环--%&gt;&lt;c:forEach begin=\"1\" end=\"4\" step=\"1\" varStatus=\"vs\"&gt; $&#123;vs.index&#125;--$&#123;vs.count&#125;--$&#123;vs.first&#125;--$&#123;vs.last&#125;&lt;br&gt;&lt;/c:forEach&gt;&lt;%--动态循环--%&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"varlist\"&gt; $&#123;varlist&#125;&lt;br&gt;&lt;/c:forEach&gt;&lt;%--JSTL方式创建表格--%&gt;&lt;table border=\"1px\"&gt; &lt;tr&gt; &lt;td&gt;字段名&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"s\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;%--遍历map集合--%&gt;&lt;c:forEach items=\"$&#123;map&#125;\" var=\"m\"&gt; $&#123;m.key&#125;:$&#123;m.value&#125; &lt;br&gt;&lt;/c:forEach&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"https://lao-biao.github.io/tags/jsp/"},{"name":"el","slug":"el","permalink":"https://lao-biao.github.io/tags/el/"},{"name":"jstl","slug":"jstl","permalink":"https://lao-biao.github.io/tags/jstl/"}]},{"title":"Servlet笔记","slug":"Servlet笔记","date":"2020-07-11T14:25:05.000Z","updated":"2020-07-12T05:43:38.599Z","comments":true,"path":"articles/bc07bc32.html","link":"","permalink":"https://lao-biao.github.io/articles/bc07bc32.html","excerpt":"Servlet概述 狭义的Servlet是指Java语言实现的一个接口 广义的Servlet是指任何实现了这个Servlet接口的类 Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，绝大数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 特点 运行在Java的应用服务器上 Servlet的实现遵循了服务器能够识别的规则，服务器会自动地根据请求调用对应地Servlet进行请求处理 简单方便，可移植性强 URL与URIurl：http://localhost:8080/servlet/my 服务器地址:端口号/webapps下的文件夹的名称[虚拟项目名]/类名全路径[别名] 服务器地址:端口号/虚拟项目名/servlet的别名 URI：虚拟项目名/servlet的别名 访问流程 浏览器发送请求到服务器 服务器根据请求URL地址中的URI信息在webapps目录下找到对应的项目文件夹 然后在web.xml中检索响应的Servlet 找到后调用并执行Servlet","text":"Servlet概述 狭义的Servlet是指Java语言实现的一个接口 广义的Servlet是指任何实现了这个Servlet接口的类 Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，绝大数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 特点 运行在Java的应用服务器上 Servlet的实现遵循了服务器能够识别的规则，服务器会自动地根据请求调用对应地Servlet进行请求处理 简单方便，可移植性强 URL与URIurl：http://localhost:8080/servlet/my 服务器地址:端口号/webapps下的文件夹的名称[虚拟项目名]/类名全路径[别名] 服务器地址:端口号/虚拟项目名/servlet的别名 URI：虚拟项目名/servlet的别名 访问流程 浏览器发送请求到服务器 服务器根据请求URL地址中的URI信息在webapps目录下找到对应的项目文件夹 然后在web.xml中检索响应的Servlet 找到后调用并执行Servlet Servlet的生命周期 从第一次调用到服务器关闭 如果Servlet在web.xml中配置了load-on-startup，生命周期为从服务器启动到服务器关闭 init()方法是对Servlet进行初始化的方法，会在Servlet第一次加载进行存储时执行 destroy()方法是在Servlet被销毁时执行，即服务器关闭时 方法 service() 可以处理get/post方式的请求，如果Servlet中有service方法会优先调用service方法对请求进行处理 doGet() 处理get方式请求 doPost() 处理post方式请求 注意:如果在覆写的service方法中又调用了父类的service方法，则service方法处理完成后，会再次根据请求方式响应的doGet和doPost方法执行。所以，一般情况下不在覆写的service方法中调用父类的service方法，避免出现405错误。 Servlet的常见错误 404错误：资源未找到原因1：在请求地址中的servlet的别名书写错误原因2：虚拟项目名称拼写错误 500错误：内容服务器错误 java.lang.ClassNotFoundException解决：在web.xml中校验Servlet类的全限定路径是否拼写错误逻辑错误：因为service方法的代码执行错误导致，根据错误提示对service方法体中的代码进行错误更改 405错误：请求方式不支持原因:请求方式和Servlet中的方法不匹配所造成解决:尽量使用service方法进行请求处理，并且不要再service方法中调用父类的service request对象request对象中封存了当前的所有请求信息 获取请求头数据 req.getMethod() 获取请求方式 req.getRequestURL() 获取请求URL信息 req.getRequestURI() 获取请求URI信息 req.getScheme() 获取协议 获取请求行数据 req.getHeader(“键名”) 返回指定的请求头信息 req.getHeaderNames() 返回请求头的键名的枚举集合 获取用户数据 req.getParameter(“键名”) 返回指定的用户数据 req.getParameterValues(“键名”) 返回同键不同值的请求数据 req.getParameterNames() 返回所有用户请求数据的枚举集合 如果要获取的请求数据不存在，不会报错，返回null 注意:request对象由tomcat服务器创建，并作为实参传递给处理请求的Servlet的service方法 1234567891011121314151617181920212223242526@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求头数据 String method = req.getMethod(); // 获取请求方式 StringBuffer requestURL = req.getRequestURL();// 获取请求URL String requestURI = req.getRequestURI(); String scheme = req.getScheme(); // 获取请求协议 System.out.println(\"method==&gt;\" + method + \" URL==&gt;\" + requestURL + \" URI==&gt;\" + requestURI + \" scheme==&gt;\" + scheme); // 获取行数据 String header = req.getHeader(\"User-Agent\"); // 获取指定的请求行信息 System.out.println(header); Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); // 获取所有请求行的枚举 while (headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); String value = req.getHeader(name); System.out.println(name + \"==&gt;\" + value); &#125; // 获取用户数据 String uname = req.getParameter(\"uname\"); String pwd = req.getParameter(\"pwd\"); System.out.println(\"uname==&gt;\" + uname + \" pwd==&gt;\" + pwd); String[] favs = req.getParameterValues(\"fav\"); for (String fav : favs) &#123; System.out.println(fav); &#125;&#125; 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"request\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"uname\" value=\"\"/&gt;&lt;br/&gt; 密码:&lt;input type=\"text\" name=\"pwd\" value=\"\"/&gt; &lt;br/&gt; 爱好:&lt;br/&gt; 1&lt;input type=\"checkbox\" name=\"fav\" value=\"1\"&gt;&lt;br/&gt; 2&lt;input type=\"checkbox\" name=\"fav\" value=\"2\"&gt;&lt;br/&gt; 3&lt;input type=\"checkbox\" name=\"fav\" value=\"3\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; response对象 作用：用来响应数据到浏览器的一个对象 使用： 设置响应头 setHeader(String name,String value) 在响应头中添加响应信息，但同键会覆盖 addHeader(String name,String value) 在响应头中添加响应信息，不会覆盖 设置响应状态sendError(int num,String msg) 自定义响应状态码 设置响应实体resp.getWriter().write(String str) 响应具体的数据给浏览器 设置响应编码格式resp.setContentType(“text/html;charset=utf-8”) service请求处理代码流程 设置响应编码格式 获取请求数据 处理请求数据 数据库操作（MVC思想） 响应请求处理 请求中文乱码解决 使用String进行数据重新编码uname=new String(uname.getBytes(&quot;iso8859-1&quot;), &quot;utf-8&quot;); 使用公共配置 get方式req.setCharacterEncoding(&quot;utf-8&quot;);在tomcat的目录下的conf目录中修改server.xml文件,在Connector标签中增加属性useBodyEncodingForURI=&quot;true&quot; post方式req.setCharacterEncoding(&quot;utf-8&quot;); Servlet流程总结 浏览器发起请求到服务器 服务器接收浏览器的请求,进行解析，创建request对象存储请求数据 服务器调用对应的Servlet进行请求处理，并将request对象作为实参传递给Servlet的方法 Servlet的方法执行进行请求处理 设置请求编码格式 设置响应编码格式 获取请求信息 处理请求信息创建业务层对象调用业务层对象的方法 响应结果处理 请求转发作用：实现多个Servlet联动操作处理请求，避免代码冗余,让Servlet的职责更加明确 使用：req.getRequestDispatcher(&quot;要转发的地址&quot;).forward(req,resp);地址：相对路径,直接书写Servlet的别名即可 特点：一次请求，浏览器地址信息不变 注意：请求转发后直接return结束即可 request对象的作用域使用： request.setAttribute(Object name,Object value); request.getAttribute(Object obj); 作用：解决了一次请求内的不同Servlet的数据(请求数据+其他数据)共享问题 作用域：基于请求转发,一次请求中的所有Servlet共享 注意：使用Request对象进行数据流转,数据只在一次请求内有效 特点： 服务器创建 每次请求都会创建 生命周期为一次请求 重定向解决表单重复提交的问题，以及当前Servlet为无法处理的请求的问题 使用： response.sendRedirect(&quot;路径&quot;); 本地路径为：URI 网络路径为：定向资源的URL信息 特点： 两次请求，两个request对象 浏览器地址信息改变 时机： 如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向 如果请求被Servlet接收后，无法进行处理，建议使用重定向定位到可以处理的资源 Cookie作用：解决发送的不同请求的数据共享问题 Cookie的创建和存储 创建Cookie对象Cookie cookie=new Cookie(String name,String value); 设置Cookie(可选)设置有效期 cookie.setMaxAge(int seconds);设置有效路径 cookie.setPath(String uri);响应Cookie信息给客户端 resp.addCookie(cookie); Cookie的获取 获取Cookie信息数组Cookie[] cookies=req.getCookies(); 遍历数组获取Cookie信息使用for循环遍历 1234567if(cookies!=null) &#123; for (Cookie c : cookies) &#123; String name = c.getName(); String value = c.getValue(); System.out.println(name + \":\" + value); &#125;&#125; 注意：一个Cookie对象存储一条数据，多条数据，可以创建多个Cookie对象进行存储。 特点 Cookie是浏览器端的数据存储技术 存储的数据声明在服务器端 临时存储:存储在浏览器的运行内存中，浏览器关闭即失效 定时存储:设置了Cookie的有效期，存储在客户端的硬盘中，在有效期内符合路径要求的请求都会附带信息 默认Cookie信息存储好之后，每次请求都会附带，除非设置有效路径 Session问题：一个用户的不同请求处理的数据共享 原理用户第一次访问服务器，服务器会创建一个session对象给此用户，并将该session对象的JSESSIONID使用Cookie技术存储到浏览器中，保证用户的其他请求能够获取到同一个session对象，也保证了不同请求能够获取到共享的数据。 特点 存储在服务器端 服务器进行创建 依赖Cookie技术 一次会话 默认存储时间是30分钟 作用解决了一个用户不同请求处理的数据共享问题 使用创建session对象/获取session对象HttpSession hs = req.getSession(); 如果请求中拥有session的标识符JSESSIONID，则返回其对应的session对象。 如果请求中没有session的标识符JSESSIONID，则创建新的session对象，并将其JSESSIONID作为cookie数据存储到浏览器端。 如果session对象失效了，也会重新创建一个session对象，并将其JSESSIONID存储在浏览器内存中。 设置session存储时间hs.setMaxInactiveInterval(int seconds); 注意：在指定的时间内session对象没有被使用则销毁，如果使用了则重新计时。 设置session强制失效hs.invalidate(); 存储和获取数据 存储：hs.setAttribute(String name,Object object); 获取：hs.getAttribute(String name); 返回的数据类型为Object 注意:存储的动作和取出的动作发生在不同的请求中，但是存储要先与取出执行。 使用时机：一般用户在登录web项目时会将用户的个人信息存储到session中，供该用户的其他请求使用。 总结session解决了一个个用户的不同请求的数据共享问题，只要在JSESSIONID不失效的情况下，用户的任意请求在处理时都能获取到同一个session对象 作用域 一次会话 在JSESSIONID和session对象不失效的情况下为整个项目内 session失效处理将用户请求中的JSESSIONID和后台获取到的session对象进行比对时 如果一致，则session没有失效， 如果不一致则说明session失效了，重定向到登录页面，让用户重新登录 注意： JSESSIONID存储在了Cookie的临时存储空间中，浏览器关闭即失效 模拟登录案例问题解决主页面用户名显示为null问题 原因：因为在用户登录成功后使用重定向显示主界面，两次请求，而用户的信息在第一次请求中，第二次请求中没有用户数据，所以显示为null 解决：使用session技术 使用ServletContext对象完成网页计数器：在用户登录校验中创建计数器并自增，然后存储到ServletContext对象中，在主页面里取出计数器数据显示给用户。 ServletContext对象解决不同用户使用相同的数据 特点 服务器创建 用户共享 生命周期：服务器启动到服务器关闭 在web.xml中配置 12345678910111213&lt;!--配置全局数据--&gt;&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhangsan&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;com.web.servlet.ServletContextServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;url-pattern&gt;/context&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用 获取ServletContext对象 123ServletContext sc1 = this.getServletContext(); // this对象直接获取ServletContext sc2 = this.getServletConfig().getServletContext(); // 通过ServletConfig获取ServletContext sc3 = req.getSession().getServletContext(); // 通过Session获取 使用ServletContext对象完成数据共享 数据存储sc.setAttribute(String name,Object value); 数据获取sc.getAttribute(String name); 返回的是Object类型 注意：不同的用户可以给ServletContext对象进行数据存取，获取的数据不存在返回null 获取项目中web.xml文件的全局配置数据sc.getInitParameter(&quot;name&quot;); 返回String类型，如果数据不存在返回nullsc.getParameterNames(); 返回键名的枚举配置方式一组&lt;context-param&gt;标签只能存储一组键值对数据，多组可以声明多个&lt;context-param&gt;进行存储。 1234&lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt;&lt;/context-param&gt; 作用：将静态数据和代码进行解耦 获取项目web下的资源的绝对路径String path = sc.getRealPath(String path);获取的路径为项目根目录，参数为项目根目录中的路径 获取web下的资源的流对象InputStream is = sc.getResourceAsStream(&quot;doc/1.txt&quot;);注意：此种方式只能获取项目根目录下的资源流对象，class文件的流对象需要使用类加载器获取 ServletConfig对象解决在web.xml中给每个Servlet单独配置的数据 在web.xml中配置 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;sg&lt;/servlet-name&gt; &lt;servlet-class&gt;com.web.servlet.ServletConfigServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;sg&lt;/servlet-name&gt; &lt;url-pattern&gt;/sg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用： 获取ServletConfig对象 ServletConfig sc = this.getServletConfig(); 获取web.xml中的配置数据 String config = sc.getInitParameter(&quot;config&quot;); web.xml文件作用：存储项目相关配置信息，保护Servlet；解耦一些数据对程序的依赖。 使用位置 每个web项目中 Tomcat服务器中（在服务器目录conf目录中） 区别 Web项目下的web.xml文件为局部配置，针对本项目的位置 Tomcat下的web.xml文件为全局配置，配置公共信息 内容（核心组件） 全局上下文配置（全局配置参数）[ServletContext、context-param] Servlet配置 过滤器配置[filter] 监听器配置[listener] 加载顺序：Web容器会按ServletContext-&gt;context-param-&gt;listener-&gt;filter-&gt;servlet顺序加载组件，这些元素可配置在web.xml文件中的任意位置。 加载时机：服务器启动时 Server.xml文件核心组件Tomcat的server.xml结构 1234567891011&lt;Server&gt; &lt;Service&gt; &lt;Connector/&gt; &lt;Connector/&gt; &lt;Engine&gt; &lt;Host&gt; &lt;Context/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 热部署：&lt;Context path=&quot;/项目虚拟名&quot; reloadable=&quot;true&quot; docBase=&quot;项目路径&quot;/&gt; 开发时使用冷部署，需要重启服务器。 过滤器问题引入：Servlet的作用是针对浏览器发起的请求，进行请求的处理。通过Servlet技术可以灵活的进行请求的处理，但是我们不但要对请求进行处理，还需要对服务器的资源进行统一的管理，比如请求编码格式的统一设置，资源的统一分配等等，如何解决？ 解决：使用过滤器 作用：对服务器资源进行管理、保护Servlet。 过滤器生命周期：从服务器启动到服务器关闭 使用 创建一个实现了Filter接口的普通java类 覆写接口的方法 init()方法:服务器启动即执行，资源初始化 doFilter()方法:拦截请求，在此方法中可以对资源实现管理 注意:需要手动对请求进行放行 destroy()方法:服务器关闭时执行 Filter过滤器的配置：在web.xml中配置过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;mf&lt;/filter-name&gt; &lt;filter-class&gt;com.web.filter.MyFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;mf&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注解的形式：@WebFilter(filterName = &quot;MyFilter&quot;, urlPatterns = {&quot;/*&quot;}) 注意 url-pattern:/* 表示拦截所有的请求 url-pattern:*.do 表示所有以.do结尾的请求，一般是用来进行模块拦截处理 url-pattern:/ServletUrlPattern 表示拦截指定url的请求，针对某个Servlet的请求拦截，保护Servlet 执行流程浏览器发起请求到服务器，服务器接收到请求后根据URI信息在web.xml中找到对应的过滤器执行doFilter()方法，该方法对此次请求进行处理后如果符合要求则放行，放行后如果还有符合要求的规律其则继续进行过滤，找到对应的Servlet进行处理。Servlet对请求处理完毕后，也就是service()方法结束了。还需要继续返回相应的doFilter()方法继续执行。 案例 统一管理字符编码 统一编码格式设置 session管理 权限管理 资源管理(统一水印，和谐词汇等) 监听器问题引入在Servlet技术中学习了request、session、application作用域对象，其主要作用是实现数据在不同的场景中的灵活流转。但是数据的具体流转过程是无法看到的，比如作用域对象是什么时候创建和销毁的，数据是什么时候存取，改变和删除的。因为具体的流转过程是不可见的，所以无法在指定的实际对数据和对象进行操作，比如session销毁的时候，在线人数-1。 解决：使用监听器Listener 概念Servlet监听器时Servlet规范中定义的一种特殊类，用于监听ServletContext、HttpSession和ServletReqeust等域对象的创建与销毁事件，以及监听这些域对象中属性发生修改的事件。 监听对象 Request Session Application 监听内容：创建、销毁、属性改变事件 监听作用：在事件发生之前，之后进行一些处理，比如统计在线人数 使用1、创建一个实现了指定接口的java类 监听request 监听request–&gt;ServletRequestListener 监听request对象的创建和销毁 requestInitialized(ServletRequestEvent sre) 创建 requestDestroyed(ServletRequestEvent sre) 销毁 注意：形参获取监听的request对象 sre.getServletRequest() 监听request–&gt;ServletRequestAttributeListener 监听request作用域数据的增加、修改、删除 attributeAdded(ServletRequestAttributeEvent srae) attributeReplaced(ServletRequestAttributeEvent srae) attributeRemoved(ServletRequestAttributeEvent srae) 注意：形参可以获取被监听的数据 srae.getName() 获取监听数据的键名 srae.getValue() 获取监听数据的值 监听session 监听session–&gt;HttpSessionListener 监听session的创建和销毁 sessionCreated(HttpSessionEvent se) sessionDestroyed(HttpSessionEvent se) 注意:形参可以获取被监听的session对象 se.getSession(); 监听session–&gt;HttpSessionAttributeListener 监听session数据的创建和销毁 attributeAdded(HttpSessionBindingEvent se) attributeReplaced(HttpSessionBindingEvent se) attributeRemoved(HttpSessionBindingEvent se) 注意:形参可以获取被监听的数据 se.getName() 获取数据的键名 se.getValue() 获取数据的值 监听application 监听application–&gt;ServletContextListener 监听application对象的初始化和销毁 contextInitialized(ServletContextEvent sce) 初始化 服务器启动 contextDestroyed(ServletContextEvent sce) 销毁 服务器关闭 注意:形参可以获取当前application对象sce.getApplication() 监听application–&gt;ServletContextAttributeListener attributeAdded(ServletContextAttributeEvent scae) attributeReplaced(ServletContextAttributeEvent scae) attributeRemoved(ServletContextAttributeEvent scae) 注意:形参可以获取被监听的数据 scae.getName() 获取数据的键名 scae.getValue() 获取数据的值 2、在web.xml中配置监听类(可配置多个监听器) 123&lt;listener&gt; &lt;listener-class&gt;com.web.listener.MyListener&lt;/listener-class&gt;&lt;/listener&gt; 注解形式：@WebListener(value = &quot;/ml&quot;) 案例统计网站在线人数","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lao-biao.github.io/tags/servlet/"}]},{"title":"AQS笔记","slug":"AQS笔记","date":"2020-07-11T12:29:29.000Z","updated":"2020-07-12T05:43:38.546Z","comments":true,"path":"articles/74f18f35.html","link":"","permalink":"https://lao-biao.github.io/articles/74f18f35.html","excerpt":"AQSAbstract Queued Synchronizer 抽象队列同步器所在包：java.util.concurrent.locks.AbstractQueuedSynchronizer; AQS是基于先进先出队列（FIFO），CLH（一种基于单向链表的高性能、公平的自旋锁） 基于AQS实现的锁 ReentrantLock 可重入锁[悲观锁] Semaphore 信号量 CountDownLatch 倒数 ReentrantReadWriteLock 可重入读写锁 偏向锁、轻量级锁、重量级锁偏向锁：偏向第一个线程(JDK 1.6) JVM内部 轻量级锁：由偏向锁升级而来，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。 自旋锁：一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。 自旋锁–(自旋10次)–&gt;重量级锁（悲观锁） 乐观锁与悲观锁 悲观锁：总是假设最坏的情况，每次拿数据都认为别的线程会修改数据，所以要加锁，别的线程只能等待，直到当前线程释放锁才能拿到锁 乐观锁：总是假设最好的情况，每次拿数据都认为别的线程不会修改数据，所以不会加锁，但是更新的时候，会判断在此期间有没有线程修改过 CASCompare and Swap比较和交换 CAS 必须是原子操作 现代CPU都支持CAS CAS属于乐观锁 AbstractQueuedSynchronizer官方实现Lock模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Mutex implements Lock, java.io.Serializable &#123; // Our internal helper class private static class Sync extends AbstractQueuedSynchronizer &#123; // Acquires the lock if state is zero public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // Releases the lock by setting state to zero protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (!isHeldExclusively()) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // Reports whether in locked state public boolean isLocked() &#123; return getState() != 0; &#125; public boolean isHeldExclusively() &#123; // a data race, but safe due to out-of-thin-air guarantees return getExclusiveOwnerThread() == Thread.currentThread(); &#125; // Provides a Condition public Condition newCondition() &#123; return new ConditionObject(); &#125; // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isLocked(); &#125; public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125;&#125;","text":"AQSAbstract Queued Synchronizer 抽象队列同步器所在包：java.util.concurrent.locks.AbstractQueuedSynchronizer; AQS是基于先进先出队列（FIFO），CLH（一种基于单向链表的高性能、公平的自旋锁） 基于AQS实现的锁 ReentrantLock 可重入锁[悲观锁] Semaphore 信号量 CountDownLatch 倒数 ReentrantReadWriteLock 可重入读写锁 偏向锁、轻量级锁、重量级锁偏向锁：偏向第一个线程(JDK 1.6) JVM内部 轻量级锁：由偏向锁升级而来，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。 自旋锁：一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。 自旋锁–(自旋10次)–&gt;重量级锁（悲观锁） 乐观锁与悲观锁 悲观锁：总是假设最坏的情况，每次拿数据都认为别的线程会修改数据，所以要加锁，别的线程只能等待，直到当前线程释放锁才能拿到锁 乐观锁：总是假设最好的情况，每次拿数据都认为别的线程不会修改数据，所以不会加锁，但是更新的时候，会判断在此期间有没有线程修改过 CASCompare and Swap比较和交换 CAS 必须是原子操作 现代CPU都支持CAS CAS属于乐观锁 AbstractQueuedSynchronizer官方实现Lock模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Mutex implements Lock, java.io.Serializable &#123; // Our internal helper class private static class Sync extends AbstractQueuedSynchronizer &#123; // Acquires the lock if state is zero public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // Releases the lock by setting state to zero protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (!isHeldExclusively()) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // Reports whether in locked state public boolean isLocked() &#123; return getState() != 0; &#125; public boolean isHeldExclusively() &#123; // a data race, but safe due to out-of-thin-air guarantees return getExclusiveOwnerThread() == Thread.currentThread(); &#125; // Provides a Condition public Condition newCondition() &#123; return new ConditionObject(); &#125; // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isLocked(); &#125; public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125;&#125; 多线程高并发常见问题引入使用100个线程完成1000个1相加的运算，每个线程都是100次自增的for循环，最后结果却小于1000。 这是因为线程操作的是当前中内存中的值，当m+2，实际上却只执行m+1了 123456789101112131415161718192021public class Main &#123; public static int m = 0; public static void main(String[] args) throws InterruptedException &#123; Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; // 以匿名内部类的方式声明100个线程 threads[i] = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; m++; &#125; &#125;); &#125; for (Thread t : threads) &#123; t.start(); // 线程开始 &#125; for (Thread t : threads) &#123; t.join(); // 加入当前线程 &#125; System.out.println(m); &#125;&#125; 解决方案——Synchronized加锁在线程访问时进行加锁，其他线程阻塞，线程完成累加后解锁，其他线程再进行访问，循环此操作，直到100个线程完成累加。 12345678threads[i] = new Thread(() -&gt; &#123; synchronized (Main.class) &#123; //线程访问时加锁，结束时打开，其他线程再访问时，加锁状态时线程阻塞 for (int j = 0; j &lt; 100; j++) &#123; m++; &#125; &#125;&#125;);&#125; 解决方案——ReentrantLock使用ReentrantLock可重入锁，JDK 1.5之后添加的，互斥锁，底层实现是AQS lock() 加锁 unlock() 解锁 ReentrantLock部分源码 1234public class ReentrantLock implements Lock, java.io.Serializable &#123; private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer&#123;&#125; // 底层实现是AQS&#125; Synchronized 在JDK 1.5之前被视为重量级锁，在JDK 1.6以后视为轻量级锁 JVM–OS(操作系统) 用户–kernel（实时操作系统）费时 在JDK1.5之后在JVM添加各种锁（Lock接口），不需要再与OS交互 Synchronized与CAS高并发性能比较Synchronized 适合高并发（超高并发，锁代码执行时间长） 调用wait()，阻塞线程，不消耗 cpu CAS 适合锁的竞争不激烈 for循环或while(true)， 消耗cpu Lock源码123456789101112131415161718/** * @since 1.5 * @author Doug Lea*/public interface Lock &#123; void lock(); // 加锁 void lockInterruptibly() throws InterruptedException; boolean tryLock(); // boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); // 解锁 Condition newCondition();&#125; ReentrantLock解决100个线程累加求和问题12345678910111213public static Lock lock = new ReentrantLock(); // JDK1.5之后添加的，互斥锁，底层实现是AQS// 线程操作threads[i] = new Thread(() -&gt; &#123; try &#123; lock.lock(); //加锁 for (int j = 0; j &lt; 100; j++) &#123; m++; &#125; &#125; finally &#123; lock.unlock(); //解锁 &#125;&#125;); 解决方案——Lock+volatilevolatile关键字 线程（内存）在写入变量后立即提交给主线程（内存），其他线程可见其改变 禁止指令重排序，可参考单例模式中懒汉式的相关代码 synchronized 防止指令重排instance=new Instance() 只执行第2步和第4步 半初始化，使用volatile修饰instance禁止指令重排序 自定义Lock，使用volatile关键字定义当前线程状态，在当前线程被占用时，循环等待，直到线程被释放。等待的过程也可以用CAS自旋来实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MLock implements Lock &#123; private volatile int i = 0; // 0被释放，1锁定 @Override public void lock() &#123; synchronized (this) &#123; while (i != 0) &#123; // 已经有线程占用 try &#123; this.wait(); // 等待，也可使用CAS（Compare and switch）自旋 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; i = 1; &#125; &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; &#125; @Override public boolean tryLock() &#123; return false; &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return false; &#125; @Override public void unlock() &#123; synchronized (this) &#123; i = 0; this.notifyAll(); // 唤醒其他等待该锁的线程 &#125; &#125; @Override public Condition newCondition() &#123; return null; &#125;&#125; 主类 1234567891011121314151617181920212223242526public class Main &#123; public static int m = 0; public static Lock lock = new MLock(); public static void main(String[] args) throws InterruptedException &#123; Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(() -&gt; &#123; try &#123; lock.lock(); // 加锁 for (int j = 0; j &lt; 100; j++) &#123; m++; &#125; &#125; finally &#123; lock.unlock(); // 解锁 &#125; &#125;); &#125; for (Thread t : threads) &#123; t.start(); // 开始线程 &#125; for (Thread t : threads) &#123; t.join(); // 加入当前线程 &#125; System.out.println(m); &#125;&#125; 解决方案——Sync+Lock修改MLock.java，主类Main.java不变，使用Sync来替代volatile 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MLock implements Lock &#123; private Sync sync = new Sync(); @Override public void lock() &#123; sync.acquire(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; &#125; @Override public boolean tryLock() &#123; return false; &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return false; &#125; @Override public void unlock() &#123; sync.release(1); // 释放 &#125; @Override public Condition newCondition() &#123; return null; &#125; /** * 使用内部类--推荐写法 */ private class Sync extends AbstractQueuedSynchronizer &#123; @Override public boolean tryAcquire(int acquires) &#123; if (compareAndSetState(0, 1)) &#123; // 竞争锁 // 互斥锁 共享锁 setExclusiveOwnerThread(Thread.currentThread()); // 设定当前线程持有该锁 return true; &#125; return false; &#125; @Override protected boolean tryRelease(int releases) &#123; // 释放 setExclusiveOwnerThread(null); setState(0); return true; &#125; @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; &#125;&#125; 解决方案——使用CountDownLatchCountDownLatch倒计数100，每个线程执行完后调用countDown()自减1，主线程中await()等待直到为0。 1234567891011121314151617181920212223242526public class Main &#123; public static int m = 0; public static Lock lock = new MLock(); public static CountDownLatch latch = new CountDownLatch(100); public static void main(String[] args) throws InterruptedException &#123; Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(() -&gt; &#123; try &#123; lock.lock(); // 加锁 for (int j = 0; j &lt; 100; j++) &#123; m++; &#125; &#125; finally &#123; lock.unlock(); // 解锁 &#125; latch.countDown(); &#125;); &#125; for (Thread t : threads) &#123; t.start(); // 开始线程 &#125; latch.await(); // 线程等待 System.out.println(m); &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"AQS","slug":"AQS","permalink":"https://lao-biao.github.io/tags/AQS/"},{"name":"并发编程","slug":"并发编程","permalink":"https://lao-biao.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Web技术复习笔记","slug":"Web技术复习笔记","date":"2020-07-08T00:54:33.000Z","updated":"2020-07-08T02:34:56.308Z","comments":true,"path":"articles/71c32ee5.html","link":"","permalink":"https://lao-biao.github.io/articles/71c32ee5.html","excerpt":"C/S架构与B/S架构C/S架构：client/server socket、serversocket、awt/swing做一个客户端软件 建好socket连接后，通过io流来交换，数据格式开发者自定义绑定 B/S架构：browser/server 浏览器也是一种客户端软件 HTTP协议定义了浏览器和服务器通讯的基本规则之一 浏览器和服务器之间的交互 交互模式：请求-响应 客户端先发出请求，服务器根据请求内容发送响应的内容，客户端根据响应内容进行显示","text":"C/S架构与B/S架构C/S架构：client/server socket、serversocket、awt/swing做一个客户端软件 建好socket连接后，通过io流来交换，数据格式开发者自定义绑定 B/S架构：browser/server 浏览器也是一种客户端软件 HTTP协议定义了浏览器和服务器通讯的基本规则之一 浏览器和服务器之间的交互 交互模式：请求-响应 客户端先发出请求，服务器根据请求内容发送响应的内容，客户端根据响应内容进行显示 客户端发出请求的格式 请求行：服务器的地址、端口、资源地址 请求头 请求实体 注：客户端向服务器传参，如果将参数放到请求行，即为get方式，如果将参数放在实体中，即为post请求 服务器收到请求内容后发送响应内容 响应内容定义 状态行 200、404、500 响应行 响应实体 客户端收到响应内容后，显示内容 HTML超文本标记语言 HTML元素动态 javascript（livescript） 控制页面元素 css Cascading Style Sheets层叠样式表 服务器根据请求内容发送响应的内容 收请求内容 建立监听，ServletSocket s.accept() 启动一个线程（轻量级进程），为请求的客户提供服务 为了封装客户端提供的请求信息，定义一个对象：HttpServletRequest 为了封装回送给服务端的相应内容，定义一个对象：HTTPServletResponse 根据请求内容调用相应的程序（Servlet） 通过web.xml中定义的url和Servlet的关系，找到对应的Serlvet程序 定义了HttpServlet抽象类，service(HttpServletRequset req,HttpServletResponse resp)方法 将response对象中的信息，转译成基于http协议的响应内容，再将这些响应内容通过socket传送给客户端为了统一处理上述流程，使用Tomcat服务器，也成为web容器，Servlet容器 规范、增强Servlet程序 浏览器发送给服务器的请求内容 HttpServletRequest对象 服务器回送给浏览器的相应内容 HttpServletResponse对象 Serlvet类读取web.xml中自己的配置信息 ServletConfig 需要读取web.xml中的公共信息 &lt;context-param&gt; ServletContext 将所有Servlet放入一个容器中统一管理 ServletContext 保存以前操作的状态 客户端保存Cookie 服务器保存SessionServlet擅于业务逻辑处理，不擅于页面展示的代码处理 改进Servlet—&gt;JSP统一的转译程序，将jsp文件内容转译成java类代码，产生了jsp引擎（一般服务器自带了这个功能） ajax异步模式局部刷新效果XmlHttpRequest 通过增加XMLHttpRequet对象，使用XHR对象发送请求，获得数据后，也是先传给XHR对象，再通过js代码操作dom模型，实现局部刷新效果。 HTML非表单标签 b粗体 u下划线 i斜体 del删除效果 a 超链接 href 、target img 图片 frameset 框架 （frame）框架集 table表格 th、tr、td（单元格table data cell）colspan、rowspan单元格合并 ul li ol 列表标签 embed 用来播放MP3、视频等 div 虚拟矩形区域 span 行内元素（不会换行） 表单标签 form表单标签 action提交表单的地址 method表单提交的方式（） name（命名方式：regFrm） 表单域（表单域一定要有name属性，否则该表单域的值不会被提交） 文本域 text单行文本域、password密码框、textarea多行文本域 radio单选按钮（组，name属性一致即为一组，每组只能提交一个值） chcekbox复选框（组，name属性一致即为一组，每组恶意体骄傲多个值） select option下拉框（可以实现多选一，多选多） file 文件域，用来实现文件上传（method=past,enctype=”multipart/form-data”） hidden 隐藏域（不需要用用户输入，但是服务器又需要的值） reset 重置 submit 提交按钮 button 普通按钮（通常用来激活一个js函数） CSS 引用css信息 通过html元素的style属性，class属性 通过&lt;style&gt;块 通过引入外部的css文件&lt;link&gt; css选择器 id选择器 #id名字 class选择器 .类名 元素选择器 css属性 文本属性 定位属性 静态定位、相对定位、绝对定位、固定定位、z-index 列表属性 布局属性 边框属性 JavScriptjs的基本语法 基本数据类型 undefined、null、number、字符串、Boolean、Object 变量定义 var 控制语句 内置语句 eval()、escape()、unescape() 常用的对象 Date、Math、String、RegExp 数组 var a=[]; var b=new Array(); 对象的定义 JSON: 声明：var user=(name:””,pwd:””,sleep:function(){}); 使用：user.sleep; 函数也是对象 继承是通过prototype属性来模拟 String prototype.trim=function(){return this.replace(“(^\\s+)||(\\s+$)”,””)} “ 123 “.trim() 对话框 alert警告框 prompt询问框 confirm确认框 浏览器对象 window open 打开子窗口 close关闭窗口 定时操作 setTimeout,clearTimeout setInterval,clearInterval navigator：浏览器信息 history：访问历史 history.go(1) location：地址栏信息 dom操作 获取节点 直接获得 id name class tagName 间接获得 通过父节点获得子节点 childNode firstChild、lastChild 通过子节点获得父节点：parentNode 兄弟节点：nextSibling、preSibling 操作节点 判断节点类型 nodeType 1元素节点 3文本节点 节点的属性 通过点操作符 节点的文本内容 innerHTML 改变DOM结构 增加节点 appendChild，insertBefore 删除节点 removeChild 替换节点 replaceChild 表单的操作 通用属性 value，disabled，表单对象.elements 单选按钮和复选框操作的时候，一般采用遍历 表单验证 &lt;submit value onclick=”return check(this.from)” &lt;form onsubmit=”return check(this)” HTTP协议Tomcat服务器 server.xml web.xml 目录结构的作用 lib work（存放jsp编译后的Java文件） webapps（项目部署） conf Servlet浏览器发送给服务器的请求内容 HttpServletRequest对象 getParameter()，getParameterValues()处理复选框 作用域方法：setAttribute()，getAttibute()，removeAttribue() getReqeustURL()，getReqeuestURI()，getQueryString()，getContextPath() 获取客户端ip和端口：getRemoteAddr(),getRemotePort() request.setCharacterEncoding() 设置请求实体的编码，对post请求有效，对get请求无效（可通过Tomcat调整server.xml） 请求转发：rqeuset.getReqeustDispatcher().forward(requset,response) 服务器回送给浏览器的相应内容 HttpServletResponse对象 setCharacterEndoding()设置响应编码格式 setContentType()设置响应内容 getWriter()输出文本 getOutSteam() 输出非文本 重定向：resposne.sendRedire() Serlvet类读取web.xml中自己的配置信息 ServletConfig getInitParameter 需要读取web.xml中的公共信息 &lt;context-param&gt; ServletContext 获取：this.getServletContext() 作用域：可以被所有的Servlt共享 其他方法：getRealPath()，getResourcePaths() 将所有Servlet放入一个容器中统一管理 ServletContext 保存以前操作的状态 客户端保存Cookie 服务器保存Session 客户端保存cookie流程 服务器端写代码：Cookie c=new Cookie(); response.setCookie(c); 响应头中就会有一个SetCookie 浏览器收到以后，先放到内存中，如果cookie设置了有效期，则会写到硬盘的cookie文件中 浏览器以后访问服务器时，就会自动携带（请求头）有效的cookie信息 服务器端保存信息session的跟踪机制 服务器会new一个session对象，同时指定一个id给session对象 通过响应头设置 浏览器收到sessionId这个信息，下次访问一定会携带sessionId 服务器收到session后，根据session找到对应的session对象，然后就可以查看对象里面的内容，从而，确定之前我们进行了什么操作，也就是实现了状态的保存 Servlet生命周期 加载 第一个请求的时候（Servlet是单例，只有一个Servlet对象） 如果配置了load-on-startup，启动时加载 初始化：执行init() 调用：service()、doGet()、doPost() 销毁：destroy() 过滤器 实现Filter相关接口 doFilter 配置位于&lt;servlet&gt;之前 监听器 实现Listener相关接口 配置位于&lt;filter&gt;之后，&lt;servlet&gt;之前 JSP&lt;%%&gt;java脚本段 &lt;%=%&gt;表达式 &lt;%! %&gt; 声明 &lt;%—-%&gt; 注释 &lt;%@ include file=”” %&gt;静态导入，两个jsp文件编译时合并到一起 &lt;jsp:include&gt;相当于一个类调用另一个类 jsp九个内置对象： page：java.lang.object request：javax.servlet.http.HttpServletrequest 获取用户的请求信息 resposne：javax.servlet.http.HttpServletResponse 服务器向客户端的回应信息 out ：javax.servlet.jsp.jspWriter 页面输出 session：javax.servlet.http.HttpSession 用来保存每一个用户的信息 pageContext：javax.servlet.jsp.PageContext JSP的页面容器 exception：java.lang.Throwable config：javax.servlet.ServletConfig 服务器配置信息，可以取得初始化参数 application：javax.servlet.ServletContext表示所有用户的共享信息 EL和JSTLEL表达式：操作的是作用域中的属性 使用：${} JSTL标签库: foreach if choose when otherwise set remove import 菜鸟教程JSTL：https://www.runoob.com/jsp/jsp-jstl.html ajax核心技术：通过XHR对象发送请求，通过XHR对象接收响应，再通过js操作dom对象，将收到的新的信息，赋给某个元素，实现局部刷新效果 基本流程 创建XHR对象 创建一个请求 设置监听，处理服务器发送的响应内容 发送请求 XMLXML基本语法 XML的解析（DOM方式、SAX方式、JDOM、DOM4J） dtd/schema 定义xml数据的语法规则 xslt 定义xml数据的显示方式","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[]},{"title":"Redis笔记","slug":"Redis笔记","date":"2020-07-08T00:48:27.000Z","updated":"2020-07-08T02:34:56.277Z","comments":true,"path":"articles/bf90371e.html","link":"","permalink":"https://lao-biao.github.io/articles/bf90371e.html","excerpt":"Redis简介Redis解释Redis是一个基于key-value形式进行存储的内存型数据库 数据存储方式为key-value键值对 数据存储在内存中 优点：效率高理论：每秒10k数据读取 定位：数据库软件 作用：存储数据 NoSql数据库Redis是一个NoSql数据库。 不使用sql命令操作数据库软件 NoSql：Not Only Sql，表示在应用程序开发时，不是必须使用关系型数据库，可以使用NoSql替代关系型数据库的部分功能。 目前NoSql不能完全替代关系型数据库，使用关系型数据库结合NoSql数据库进行项目完成。 当数据比较复杂时不适用于NoSql数据库 关系数据库依然作为数据存储的主要软件 NoSql数据库当作缓存工具来使用 把关系数据库中某些使用频率较高的的内容，不仅仅存储到关系型数据库，还存到NoSql数据库中。 要考虑NoSql和关系型数据库之间的同步问题 Redis持久化策略rdb 默认的持久化策略 每隔一定时间后把内存中数据持久化到dump.rdb文件中 缺点 数据过于集中 可能导致最后的数据没有持久化到dump.rdb中 解决办法：使用命令SAVE或BGSAVE手动持久化 aof监听Redis的日志文件，监听如果发现执行了修改、删除、新增命令，立即根据这条命令把数据持久化 缺点 效率降低","text":"Redis简介Redis解释Redis是一个基于key-value形式进行存储的内存型数据库 数据存储方式为key-value键值对 数据存储在内存中 优点：效率高理论：每秒10k数据读取 定位：数据库软件 作用：存储数据 NoSql数据库Redis是一个NoSql数据库。 不使用sql命令操作数据库软件 NoSql：Not Only Sql，表示在应用程序开发时，不是必须使用关系型数据库，可以使用NoSql替代关系型数据库的部分功能。 目前NoSql不能完全替代关系型数据库，使用关系型数据库结合NoSql数据库进行项目完成。 当数据比较复杂时不适用于NoSql数据库 关系数据库依然作为数据存储的主要软件 NoSql数据库当作缓存工具来使用 把关系数据库中某些使用频率较高的的内容，不仅仅存储到关系型数据库，还存到NoSql数据库中。 要考虑NoSql和关系型数据库之间的同步问题 Redis持久化策略rdb 默认的持久化策略 每隔一定时间后把内存中数据持久化到dump.rdb文件中 缺点 数据过于集中 可能导致最后的数据没有持久化到dump.rdb中 解决办法：使用命令SAVE或BGSAVE手动持久化 aof监听Redis的日志文件，监听如果发现执行了修改、删除、新增命令，立即根据这条命令把数据持久化 缺点 效率降低 Redis安装Windows版本下载地址https://github.com/tporadowski/redis/releases 下载对应版本，解压到Redis文件夹下 将Redis文件路径添加到环境变量path中 用命令行窗口执行redis-server.exe命令或redis-server.exe redis.windows.conf（没有配置环境变量时） 1234567891011121314151617181920212223242526&gt;redis-server.exe&gt;redis-server.exe redis.windows.conf[4572] 30 Jun 15:39:59.717 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo[4572] 30 Jun 15:39:59.717 # Redis version=5.0.9, bits=64, commit=9414ab9b, modified=0, pid=4572, just started[4572] 30 Jun 15:39:59.717 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server.exe /path/to/redis.conf _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.9 (9414ab9b/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 4572 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-'[4572] 30 Jun 15:39:59.723 # Server initialized[4572] 30 Jun 15:39:59.724 * DB loaded from disk: 0.000 seconds[4572] 30 Jun 15:39:59.724 * Ready to accept connections 打开新的cmd窗口输入redis-cli.exe -h 127.0.0.1 -p 6379，即可进行相关命令操作 12345&gt;redis-cli.exe -h 127.0.0.1 -p 6379127.0.0.1:6379&gt; set name \"Hello World\"OK127.0.0.1:6379&gt; get name\"Hello World\" 注意：在加载设置文件条件下启动时需要在Redis目录下执行命令redis-server.exe redis.windows.conf 12&gt;cd Redis&gt;redis-server.exe redis.windows.conf Redis常用命令命令手册网址 Redis命令参考 Redis常用数据类型 String字符串 Hash哈希表 List列表 Set集合 SortedSet有序集合 Redis常用概念 Redis默认有16384 solts（槽），每个槽可存储多个hash值。 Redis默认不需要密码 在redis.windows.conf文件中去除requirepass foobared的注释，即可设置密码 设置密码后需要通过 -h 主机ip -p 端口 -a 密码 1redis-cli -h 127.0.0.1 -p 6379 -a f foobared JedisJedis是Redis客户端工具jar 123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 使用非集群版实例代码 12345678910111213141516171819Jedis jedis = new Jedis(\"127.0.0.1\", 6379);// 测试插入String res = jedis.set(\"address\", \"Hubei\");System.out.println(\"insert--&gt;\" + res);// 测试查询String get = jedis.get(\"address\");System.out.println(\"select--&gt;\" + get);// 测试修改String set = jedis.set(\"address\", \"China\");System.out.println(\"update--&gt;\" + set);// 测试查询String get2 = jedis.get(\"address\");System.out.println(\"select--&gt;\" + get2);// 测试删除Long del = jedis.del(\"address\");System.out.println(\"delete--&gt;\" + del);// 测试查询String get3 = jedis.get(\"address\");System.out.println(\"select--&gt;\" + get3); Redis集群集群的概念多个业务单元协同工作完成的整体称为集群。 每个业务单元都是相同的 当集群中业务单元中超过或等于二分之一个down掉时整个集群不可用（建议使用奇数个，整体down掉几率小） 一主一备模式给每个业务单元创建一个备份业务单元，原来的业务单元（master）后产生的叫做（slave）。 集群和伪集群集群：每个业务单元都安装到单独的服务器上 伪集群：每个业务单元都安装到同一个服务器上，通过端口区分不同的业务单元。 使用jedis访问集群 JedisCluster(Set&lt;HostAndPort&gt; nodes) 集群的ip和端口 123456789Set&lt;HostAndPort&gt; hostAndPortSet=new HashSet&lt;&gt;();hostAndPortSet.add(new HostAndPort(\"127.0.0.1\",7001));hostAndPortSet.add(new HostAndPort(\"127.0.0.1\",7002));hostAndPortSet.add(new HostAndPort(\"127.0.0.1\",7003));hostAndPortSet.add(new HostAndPort(\"127.0.0.1\",7004));hostAndPortSet.add(new HostAndPort(\"127.0.0.1\",7005));hostAndPortSet.add(new HostAndPort(\"127.0.0.1\",7006));JedisCluster jedisCluster=new JedisCluster(hostAndPortSet);jedisCluster.get(\"address\"); 通过xml形式配置集群 1234567891011121314151617181920212223242526272829303132&lt;!-- jedisCluster --&gt;&lt;bean id=\"jedisClients\" class=\"redis.clients.jedis.JedisCluster\"&gt; &lt;constructor-arg name=\"poolConfig\" ref=\"jedisPoolConfig\"/&gt; &lt;constructor-arg name=\"nodes\"&gt; &lt;set&gt; &lt;bean class=\"redis.clients.jedis.HostAndPort\"&gt; &lt;constructor-arg name=\"host\" value=\"127.0.0.1\"/&gt; &lt;constructor-arg name=\"port\" value=\"7001\"/&gt; &lt;/bean&gt; &lt;bean class=\"redis.clients.jedis.HostAndPort\"&gt; &lt;constructor-arg name=\"host\" value=\"127.0.0.1\"/&gt; &lt;constructor-arg name=\"port\" value=\"7002\"/&gt; &lt;/bean&gt; &lt;bean class=\"redis.clients.jedis.HostAndPort\"&gt; &lt;constructor-arg name=\"host\" value=\"127.0.0.1\"/&gt; &lt;constructor-arg name=\"port\" value=\"7003\"/&gt; &lt;/bean&gt; &lt;bean class=\"redis.clients.jedis.HostAndPort\"&gt; &lt;constructor-arg name=\"host\" value=\"127.0.0.1\"/&gt; &lt;constructor-arg name=\"port\" value=\"7004\"/&gt; &lt;/bean&gt; &lt;bean class=\"redis.clients.jedis.HostAndPort\"&gt; &lt;constructor-arg name=\"host\" value=\"127.0.0.1\"/&gt; &lt;constructor-arg name=\"port\" value=\"7005\"/&gt; &lt;/bean&gt; &lt;bean class=\"redis.clients.jedis.HostAndPort\"&gt; &lt;constructor-arg name=\"host\" value=\"127.0.0.1\"/&gt; &lt;constructor-arg name=\"port\" value=\"7006\"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 配置jedis连接池 12345678910111213141516171819202122232425262728293031323334&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd\"&gt; &lt;!-- 配置jedis连接池 --&gt; &lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=\"maxTotal\" value=\"30\"/&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=\"maxIdle\" value=\"10\"/&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=\"numTestsPerEvictionRun\" value=\"1024\"/&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"30000\"/&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"1800000\"/&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=\"softMinEvictableIdleTimeMillis\" value=\"10000\"/&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=\"maxWaitMillis\" value=\"1500\"/&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=\"testOnBorrow\" value=\"true\"/&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=\"testWhileIdle\" value=\"true\"/&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true --&gt; &lt;property name=\"blockWhenExhausted\" value=\"false\"/&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://lao-biao.github.io/tags/redis/"}]},{"title":"GitHub删除文件夹","slug":"GitHub删除文件夹","date":"2020-07-07T12:07:52.000Z","updated":"2020-07-07T12:30:34.910Z","comments":true,"path":"articles/bab8a3bc.html","link":"","permalink":"https://lao-biao.github.io/articles/bab8a3bc.html","excerpt":"","text":"删除步骤 进入项目文件下，使用Git Bash Here（或cmd窗口）打开命令行窗口。 git pull或(git pull origin master)从远程仓库里面的项目拉下来，dir（Windows系统）查看文件目录结构。 例如需要删除target文件夹，git rm -f --cached target git commit -m &quot;Delete target.&quot;提交，添加操作说明。 git push或(git push -u origin master)将本次更改推送到远程仓库。 123456789101112131415161718192021222324252627$ git pull origin masterFrom https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;BlogSystem * branch master -&gt; FETCH_HEADAlready up to date.$ git rm -r --cached targetrm &#39;target&#x2F;classes&#x2F;application.yml&#39;rm &#39;target&#x2F;classes&#x2F;com&#x2F;study&#x2F;BlogApplication.class&#39;...$ git commit -m &quot;Delete target.&quot;[master f5ef2bf] Delete target. 44 files changed, 67 deletions(-) delete mode 100644 target&#x2F;classes&#x2F;application.yml delete mode 100644 target&#x2F;classes&#x2F;com&#x2F;study&#x2F;BlogApplication.class ...$ git pushEnumerating objects: 3, done.Counting objects: 100% (3&#x2F;3), done.Delta compression using up to 4 threadsCompressing objects: 100% (2&#x2F;2), done.Writing objects: 100% (2&#x2F;2), 219 bytes | 219.00 KiB&#x2F;s, done.Total 2 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1&#x2F;1), completed with 1 local object.To https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;BlogSystem.git 661f345..f5ef2bf master -&gt; master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://lao-biao.github.io/tags/git/"}]},{"title":"MyBatis笔记","slug":"MyBatis笔记","date":"2020-06-30T06:52:53.000Z","updated":"2020-07-06T03:22:33.785Z","comments":true,"path":"articles/93fcac00.html","link":"","permalink":"https://lao-biao.github.io/articles/93fcac00.html","excerpt":"MyBatis简介原始jdbc操作原始jdbc开发存在的问题： 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化可能较大，sql变动需要改变java代码 查询操作时，需要手动将结果集中的数据封装到实体中；插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 解决方案： 使用数据库连接池初始化连接资源 将sql语句抽取到xml配置文件中 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 MyBatis MyBatis是一个优秀的基于Java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 MyBatis框架执行sql将结果映射为java对象并返回。采用ORM（Object Relational Mapping 对象关系映射）思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节。","text":"MyBatis简介原始jdbc操作原始jdbc开发存在的问题： 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化可能较大，sql变动需要改变java代码 查询操作时，需要手动将结果集中的数据封装到实体中；插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 解决方案： 使用数据库连接池初始化连接资源 将sql语句抽取到xml配置文件中 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 MyBatis MyBatis是一个优秀的基于Java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 MyBatis框架执行sql将结果映射为java对象并返回。采用ORM（Object Relational Mapping 对象关系映射）思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节。 MyBatis快速入门开发步骤 在pom.xml中添加MyBatis坐标（依赖） 创建user数据表 编写User实体类 编写映射文件UserMapper.xml 编写核心文件SqlMapConfig.xml 编写测试类 具体代码实现添加MyBatis坐标12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--log输出管理--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建user数据表1234567891011# 创建表CREATE TABLE user ( uid int(10) NOT NULL AUTO_INCREMENT, uname varchar(50) NOT NULL, password varchar(50) NOT NULL, PRIMARY KEY (uid));# 插入测试数据INSERT INTO user VALUES(1,&quot;zhangsan&quot;,&quot;123&quot;);INSERT INTO user VALUES(2,&quot;lisi&quot;,&quot;456&quot;);INSERT INTO user VALUES(3,&quot;wangwu&quot;,&quot;789&quot;); 编写User实体类123456public class User &#123; private int uid; private String uname; private String password; getter/setter...&#125; 编写映射文件UserMapper.xml123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"userMapper\"&gt; &lt;select id=\"query\" resultType=\"com.study.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写核心文件SqlMapConfig.xml12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置数据源环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/study/mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写测试类1234567891011121314151617public class MyBatisTest &#123; @Test public void testQuery() throws IOException &#123; // 获取核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 获取sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); // 获取sqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行操作 List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.query\"); System.out.println(userList); // 释放资源 sqlSession.close(); &#125;&#125; MyBatis映射文件概述&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;映射文件DTD约束头 &lt;mapper&gt;&lt;/mapper&gt;根标签 namespace=&quot;userMapper&quot;命名空间，与下面语句的id组成查询的标识 &lt;select&gt;&lt;/select&gt;查询操作，可选的还有insert、update、delete id=&quot;query&quot;语句的id标识，与上面的命令空间组成查询的标识 resultType=&quot;com.study.domain.User&quot;查询结果对应的实体类型 select * from user要执行的sql语句 MyBatis增删改查操作MyBatis的插入数据操作 编写映射文件UserMapper.xml 修改编写实体User的代码 编写映射文件UserMapper.xml123&lt;insert id=\"add\" parameterType=\"com.study.domain.User\"&gt; insert into user values(#&#123;uid&#125;,#&#123;uname&#125;,#&#123;password&#125;)&lt;/insert&gt; 修改编写实体User的代码123456789101112131415161718192021@Testpublic void testAdd() throws IOException &#123; // 模拟User对象 User u = new User(); u.setUname(\"zhaoliu\"); u.setPassword(\"000\"); // 获取核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 获取sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); // 获取sqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行操作 int res = sqlSession.insert(\"userMapper.add\", u); System.out.println(res); // 事务提交 sqlSession.commit(res &gt; 0); // 释放资源 sqlSession.close();&#125; 插入操作注意的问题 插入语句使用insert标签 在映射问文件中使用parameterType属性指定要插入的数据类型 sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(&quot;命名空间.id&quot;,具体实体对象) 插入操作设计数据库数据变化，所以要用sqlSession对象显式的提交即sqlSession,commit() MyBatis的修改数据操作编写映射文件UserMapper.xml123&lt;update id=\"update\" parameterType=\"com.study.domain.User\"&gt; update user set uname=#&#123;uname&#125;,password=#&#123;password&#125; where uid=#&#123;uid&#125;&lt;/update&gt; 修改编写实体User的代码12345678910111213141516171819202122@Testpublic void testUpdate() throws IOException &#123; // 模拟User对象 User u = new User(); u.setUid(3); u.setUname(\"wangwu333\"); u.setPassword(\"333\"); // 获取核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 获取sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); // 获取sqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行操作 int res = sqlSession.update(\"userMapper.update\", u); System.out.println(res); // 事务提交 sqlSession.commit(res &gt; 0); // 释放资源 sqlSession.close();&#125; 修改操作注意的问题 修改语句使用update标签 修改操作使用的API是sqlSession.updae(“命名空间.id”,具体实体对象) MyBatis的删除数据操作编写映射文件UserMapper.xml123&lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where uid=#&#123;uid&#125;&lt;/delete&gt; 修改编写实体User的代码12345678910111213141516@Testpublic void testDelete() throws IOException &#123; // 获取核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 获取sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); // 获取sqlSession会话对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行操作 int res = sqlSession.delete(\"userMapper.delete\", 6); System.out.println(res); // 事务提交 sqlSession.commit(res &gt; 0); // 释放资源 sqlSession.close();&#125; 删除操作注意的问题 删除语句使用delete标签 sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); MyBatis核心配置文件概述MyBatis核心配置文件层级关系configuration配置 properties 属性 settings 设置 typeAliases 类型别名 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 MyBatis常用配置解析environments标签数据库环境的配置，支持多环境配置 12345678910111213141516171819&lt;!--指定默认的环境名称--&gt;&lt;environments default=\"development\"&gt; &lt;!--指定当前的环境名称--&gt; &lt;environment id=\"development\"&gt; &lt;!--指定事务管理器类型是JDBC--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--指定当前数据源类型是连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源驱动--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;!--url--&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/&gt; &lt;!--用户名--&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;!--密码--&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 其中，事务管理器（transactionManager）类型有两种 JDBC：使用JDBC的提交和回滚事务设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文）。默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection设置为false来组织它默认的关闭行为。 数据源（datasource）类型有三种 UNPOOLED：这种数据源实现只是每次被请求时打开和关闭连接 POOLED：这种数据源的实现利用“池”的概念将JDBC连接对象组织起来 JNDI：这种数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后在放置一个JNDI上下文的引用。 mappers标签mappers标签的作用是加载映射，加载方式 使用相对类路径的资源引用，例如：&lt;mapper resource=&quot;org/mybtatis/builder/AuthorMapper.xml&quot;/&gt; 使用完全限定资源定位符（URL），例如：&lt;mapper =&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; 使用映射器接口实现类的完全限定类名，例如：&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; 将包内的映射器接口实现全部注册为映射器，例如：package name=&quot;org.mybatis.builder&quot; properties标签jdbc.properties文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/studyjdbc.username=rootjdbc.password=123456 SqlMapConfig.xml文件 123456789101112131415&lt;!--引入外部properties配置文件--&gt;&lt;properties resource=\"jdbc.properties\"/&gt;&lt;!--配置数据源环境--&gt;&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; typeAliases标签类型别名是为java类型设置别名，配置typeAliases为com.sutdy.domain.User定义为别名 123&lt;typeAliases&gt; &lt;typeAlias type=\"com.study.domain.User\" alias=\"user\"/&gt;&lt;/typeAliases&gt; 123&lt;select id=\"query\" resultType=\"user\"&gt; select * from user&lt;/select&gt; MyBatis框架已定义常用的类型别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean MyBatis相应APISqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactoryBuilder().build(InputStream inputStream);通过加载MyBatis的核心文件的输入流的形式构建一个SqlSessionFactory对象。 1234// 获取核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");// 获取sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); 其中，Resources工具类在org.apache.ibatis,io包中，Resources类从类路径下、文件系统或一个web URL中加载资源文件。 SqlSession工厂对象SQLSessionFactorySqlSessionFactory有多个方法创建SqlSession实例，常用方法： 方法 解释 openSession() 会默认开启一个事务，但事务不会自动提交，需要手动提交该事务，更新操作（增删改）才会持久化到数据库中 openSession(boolean autoCommit) 参数为是否自动提交事务，如果设置为true，则不需要手动提交事务 SqlSessionj会话对象SqlSession实例，包含执行语句、提交、回滚事务和获取映射器实例的方法。 执行语句的方法 12345&lt;T&gt; T selectOne(String statement, Object parameter);&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter);int insert(String statement, Object parameter);int update(String statement, Object parameter);int delete(String statement, Object parameter); 操作事务的方法 12void commit(boolean paramter);void rollback(); MyBatis的Dao层实现传统方式 编写UserDao接口和UserDaoImpl实现类 编写UserService接口和UserServiceImpl实现类 编写客户端测试类 代理开发方式采用MyBatis的代理开发方式实现Dao层的开发。 Mapper接口方法只需要编写Mapper接口（相当于Dao接口），由MyBatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体与传统的Dao接口实现类方法相同。 Mapper接口开发需要遵循的规范： mapper.xml文件中的namespace与Mapper接口的全限定名相同 Mapper几口方法名和Mapper.xml中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 MyBatis映射文件MyBatis映射文件Mapper.xml标签 &lt;select&gt;：查询 &lt;insert&gt;：插入 &lt;update&gt;：修改 &lt;delete&gt;：删除 &lt;where&gt;：where条件 &lt;if&gt;：if判断 &lt;foreach&gt;：循环 &lt;sql&gt;：sql片段抽取 动态sql语句MyBatis的映射文件中，业务逻辑复杂时，sql语句是动态变化的。 if choose(when,otherwise) trim(where,set) foreach if标签and多条件类型 select * from where uid=? and uname=? and password=? 123456789101112131415&lt;select id=\"findByCondition\" parameterType=\"user\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"uid!=0\"&gt; and uid = #&#123;uid&#125; &lt;/if&gt; &lt;if test=\"uname!=null\"&gt; and uname = #&#123;uname&#125; &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach标签or多条件类型 select * from where uid in(?,?,...) 12345678&lt;select id=\"findByIds\" resultType=\"user\" parameterType=\"int\"&gt; select * from user &lt;where&gt; &lt;foreach collection=\"list\" open=\"uid in(\" close=\")\" item=\"uid\" separator=\",\"&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; sql片段抽取将sql语句中重复的部分抽取出来，使用时用include引用即可，达到sql重用的目的。 1234567&lt;!--sql抽取--&gt;&lt;sql id=\"selectUser\"&gt; select * from user&lt;/sql&gt;&lt;!--引用--&gt;&lt;include refid=\"selectUser\"/&gt; MyBatis核心配置文件typeHandlers标签无论是MyBatis在预处理语句（PrepareStatement）中设置一个参数时，还是从结果中取出一个值，都会用类型处理器将获取的值以合适的方式转换称Java类型。 默认的类型处理器 类处理器 Java类型 JDBC类型 BooleantTypeHandler java.lang.Boolean,boolean 数据库兼容的BOOLEAN ByteTypeHandler java.lang.Byte,byte 数据库兼容的NUMERIC或BYTE ShortTypeHandler java.lang.Short,short 数据库兼容的NUMERIC或SHORT INTEGER IntegerTypeHandler java.lang.Integer,int 数据库兼容的NUMERIC或INTEGER LongTypeHandler java.lang.Long,long 数据库兼容的NUMERIC或LONG INTEGER 可以重写类型处理器或创建自定义的类型处理器来处理不支持或非标准的类型。 具体做法 方法一：实现org.apach.ibatis.type.TypeHandler接口 方法二：继承org.apach.ibatis.type.BaseTypeHandler类，然后选择性地将它映射到一个JDBC类型。 自定义类型处理器开发步骤 定义转换类继承BaseTypeHandler&lt;T&gt; 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法 123456789101112131415161718192021222324public class DateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; // java--&gt;数据库 public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; preparedStatement.setLong(i, date.getTime()); &#125; // 数据库--&gt;java public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; long time = resultSet.getLong(s); return new Date(time); &#125; // 数据库--&gt;java public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; long time = resultSet.getLong(i); return new Date(time); &#125; // 数据库--&gt;java public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; long time = callableStatement.getLong(i); return new Date(time); &#125;&#125; 在MyBatis核心配置文件中进行注册 1234&lt;!--自定义类型处理器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"com.study.handler.DateTypeHandler\"/&gt;&lt;/typeHandlers&gt; 测试转换是否正确 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHandler是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据。 开发步骤 导入PagerHelper坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 在MyBatis核心配置文件中配置PageHelper插件 123456&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!--PageHelper4.0以后不用配置--&gt; &lt;!--&lt;property name=\"dialect\" value=\"mysql\"/&gt;--&gt; &lt;/plugin&gt;&lt;/plugins&gt; 测试分页数据获取 12// 当前页码，每一页内容数量PageHelper.startPage(int pageNum, int pageSize); 其他分页信息获取 123456789101112Logger logger = Logger.getLogger(UserMapperTest.class);// 获取与分页相关参数PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(res);logger.debug(\"当前页：\" + pageInfo.getPageNum());logger.debug(\"总页数：\" + pageInfo.getPages());logger.debug(\"总条数：\" + pageInfo.getTotal());logger.debug(\"每页显示的数量：\" + pageInfo.getPageSize());logger.debug(\"上一页：\" + pageInfo.getPrePage());logger.debug(\"下一页：\" + pageInfo.getNextPage());logger.debug(\"是否是首页：\" + pageInfo.isIsFirstPage());logger.debug(\"是否是尾页：\" + pageInfo.isIsLastPage()); MyBatis多表操作12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; select * from user_mb;+-----+-----------+----------+---------------+| uid | uname | password | birthday |+-----+-----------+----------+---------------+| 1 | zhangsan | 123 | 1593414232744 || 2 | lisi | 456 | 1593414233749 || 3 | wangwu333 | 333 | 1593414234745 || 7 | tom | 222 | 1593414234749 |+-----+-----------+----------+---------------+mysql&gt; select * from order_mb;+-----+---------------------+---------+-----+| oid | orderTime | total | uid |+-----+---------------------+---------+-----+| 1 | 2020-06-29 16:16:03 | 1000.00 | 1 || 2 | 2020-06-29 16:16:25 | 1500.00 | 1 || 3 | 2020-06-29 16:16:42 | 2000.00 | 2 || 4 | 2020-06-29 16:17:14 | 3000.00 | 3 |+-----+---------------------+---------+-----+mysql&gt; select * from role_mb;+-----+-----------------+| rid | rolename |+-----+-----------------+| 1 | 程序员 || 2 | 前端设计师 || 3 | 项目经理 || 4 | 测试人员 || 5 | 架构师 |+-----+-----------------+mysql&gt; select * from user_role_mb;+-----+-----+| uid | rid |+-----+-----+| 1 | 1 || 1 | 2 || 2 | 3 || 3 | 4 |+-----+-----+ 一对一查询模型：用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户。 配置：&lt;resultMap&gt; 映射方式一 1234567891011121314151617181920212223&lt;mapper namespace=\"com.study.mapper.OrderMapper\"&gt; &lt;!-- 指定字段与实体属性的映射关系 column:数据表的字段名称 property:实体的属性名称--&gt; &lt;resultMap id=\"orderMap\" type=\"order\"&gt; &lt;id column=\"oid\" property=\"oid\"/&gt; &lt;result column=\"orderTime\" property=\"orderTime\"/&gt; &lt;result column=\"total\" property=\"total\"/&gt; &lt;result column=\"uid\" property=\"user.uid\"/&gt; &lt;result column=\"uname\" property=\"user.uname\"/&gt; &lt;result column=\"password\" property=\"user.password\"/&gt; &lt;result column=\"birthday\" property=\"user.birthday\"/&gt; &lt;/resultMap&gt; &lt;!--查询--&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; select * from order_mb o, user_mb u where o.uid = u.uid &lt;/select&gt;&lt;/mapper&gt; 映射方式二 123456789101112131415&lt;resultMap id=\"orderMap\" type=\"order\"&gt; &lt;id column=\"oid\" property=\"oid\"/&gt; &lt;result column=\"orderTime\" property=\"orderTime\"/&gt; &lt;result column=\"total\" property=\"total\"/&gt; &lt;!-- property:当前实体(order)中的属性名称(private User user); javaType:当前实体(order)中的属性的类型(com.study.domain.User) --&gt; &lt;association property=\"user\" javaType=\"user\"&gt; &lt;id column=\"uid\" property=\"uid\"/&gt; &lt;result column=\"uname\" property=\"uname\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"birthday\" property=\"birthday\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对多查询用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。 一对一查询的需求：查询用户，与此同时查询出该用户的所有订单。 配置：&lt;resultMap&gt;+&lt;collection&gt; 12345678910111213141516171819202122232425&lt;mapper namespace=\"com.study.mapper.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"user\"&gt; &lt;id column=\"uid\" property=\"uid\"/&gt; &lt;result column=\"uname\" property=\"uname\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"birthday\" property=\"birthday\"/&gt; &lt;!-- 配置集合 property:集合名称 ofType:当前集合中的数据类型 --&gt; &lt;collection property=\"order\" ofType=\"order\"&gt; &lt;id column=\"oid\" property=\"oid\" /&gt; &lt;result column=\"total\" property=\"total\"/&gt; &lt;result column=\"orderTime\" property=\"orderTime\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select * from user_mb u, order_mb o where u.uid = o.uid &lt;/select&gt;&lt;/mapper&gt; 多对多查询用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 配置：&lt;resultMap&gt;+&lt;collection&gt; 1234567891011121314151617181920&lt;resultMap id=\"userRoleMap\" type=\"user\"&gt; &lt;id column=\"uid\" property=\"uid\"/&gt; &lt;result column=\"uname\" property=\"uname\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"birthday\" property=\"birthday\"/&gt; &lt;collection property=\"role\" ofType=\"role\"&gt; &lt;id column=\"rid\" property=\"rid\"/&gt; &lt;result column=\"rolename\" property=\"rolename\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findUserRole\" resultMap=\"userRoleMap\"&gt; select * from user_mb u, role_mb r, user_role_mb ur where u.uid = ur.uid and r.rid = ur.rid&lt;/select&gt; MyBatis注解开发常用注解 @Insert：实现新增 @Update：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与Result一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 增删改查123456789101112131415161718public interface UserMapper &#123; @Insert(\"insert into user_mb values(#&#123;uid&#125;,#&#123;uname&#125;,#&#123;password&#125;,#&#123;birthday&#125;)\") void save(User user); @Update(\"update user_mb set uname=#&#123;uname&#125;,password=#&#123;password&#125;,birthday=#&#123;birthday&#125; where uid=#&#123;uid&#125;\") void update(User user); @Delete(\"delete from user_mb where uid=#&#123;uid&#125;\") void delete(int uid); @Select(\"select * from user_mb where uid=#&#123;uid&#125;\") User findById(int uid); @Select(\"select * from user_mb\") List&lt;User&gt; findAll();&#125; 12345&lt;!--加载映射关系--&gt;&lt;mappers&gt; &lt;!--指定Mapper接口所在的包--&gt; &lt;package name=\"com.study.mapper\"/&gt;&lt;/mappers&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class AnnotationTest &#123; public static final Logger logger = Logger.getLogger(AnnotationTest.class); private UserMapper mapper; @Before public void before() throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); mapper = sqlSession.getMapper(UserMapper.class); &#125; @Test public void testSave() &#123; User user = new User(); user.setUname(\"tianqi\"); user.setPassword(\"222\"); user.setBirthday(new Date()); mapper.save(user); &#125; @Test public void testUpdate() &#123; User user = new User(); user.setUid(8); user.setUname(\"tianqi555\"); user.setPassword(\"555\"); user.setBirthday(new Date()); mapper.update(user); &#125; @Test public void testDelete() &#123; mapper.delete(8); &#125; @Test public void testFindById() &#123; User user = mapper.findById(2); logger.debug(user); &#125; @Test public void testFindAll() &#123; List&lt;User&gt; result = mapper.findAll(); logger.debug(result); &#125;&#125; 复杂映射开发 注解 说明 @Results 代替的是标签&lt;resultMap&gt;,该注解中可以使用单个@Result注解，也可以使用@Result结合。使用格式：@Results({@Result(),@Result()})或@Results(@Result()) @Result 代替了&lt;id&gt;标签和&lt;result&gt;标签@Result中属性介绍column：数据库的列名property：需要装配的属性名one：需要使用的@One注解，@Result(one=@One()many：需要使用的@Many注解，@Result(many=@Many()) @One一对多 代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One注解属性介绍select：指定用来多表查询的sqlmapper使用格式：@Result(column=””.propety=””,one=@One(select=””)) @Many多对一 代替了&lt;collection&gt;标签，是多表查询的关键，在注解中用来指定子查询返回对象集合，使用格式：@Result(column=””.propety=””,many=@Many(select=””)) 一对多查询User实体中的属性 private int uid; private String uname; private String password; private Date birthday; Order实体中的属性 private int oid; private Date orderTime; private double total; private User user; UserMapper接口方法 1234public interface UserMapper &#123; @Select(\"select * from user_mb where uid=#&#123;uid&#125;\") User findById(int uid);&#125; OrderMapper接口方法 1234567891011121314151617public interface OrderMapper &#123; @Select(\"select * from order_mb\") @Results( &#123;@Result(id = true, column = \"oid\", property = \"oid\"), @Result(column = \"total\", property = \"total\"), @Result(column = \"orderTime\", property = \"orderTime\"), @Result( column = \"uid\", // 根据该字段去查询user表的数据 property = \"user\", // 要封装的属性名称 javaType = User.class, // 要封装的实体类型 one = @One(select = \"com.study.mapper.UserMapper.findById\") ) &#125; ) List&lt;Order&gt; findAll();&#125; 测试 1234567891011121314151617public static final Logger logger = Logger.getLogger(AnnotationOMTest.class);private OrderMapper mapper;@Beforepublic void before() throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); mapper = sqlSession.getMapper(OrderMapper.class);&#125;@Testpublic void findAll() &#123; List&lt;Order&gt; result = mapper.findAll(); logger.debug(result);&#125; 多对一查询User实体中的属性 private int uid; private String uname; private String password; private Date birthday; private List&lt;Order&gt; orders; Order实体中的属性 private int oid; private Date orderTime; private double total; private User user; OrderMapper接口方法 1234public interface OrderMapper &#123; @Select(\"select * from order_mb where uid=#&#123;uid&#125;\") List&lt;Order&gt; findById(int uid);&#125; UserMapper接口方法 123456789101112131415public interface UserMapper &#123; @Select(\"select * from user_mb\") @Results(&#123; @Result(id = true, column = \"uid\", property = \"uid\"), @Result(column = \"uname\", property = \"uname\"), @Result(column = \"password\", property = \"password\"), @Result(column = \"birthday\", property = \"birthday\"), @Result( column = \"uid\", property = \"orders\", javaType = List.class, many = @Many(select = \"com.study.mapper.OrderMapper.findById\")) &#125;) List&lt;User&gt; findUserAndOrderAll();&#125; 测试 1234567891011121314151617public static final Logger logger = Logger.getLogger(AnnotationMOTest.class);private UserMapper mapper;@Beforepublic void before() throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); mapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testFindUserAndOrderAll() &#123; List&lt;User&gt; result = mapper.findUserAndOrderAll(); logger.debug(result);&#125; 多对多查询User实体中的属性 private int uid; private String uname; private String password; private Date birthday; private List&lt;Role&gt; roles; Role实体中的属性 private int rid; private String rolename; RoleMapper接口方法 1234public interface RoleMapper &#123; @Select(\"select * from user_role_mb ur,role_mb r where ur.uid=#&#123;uid&#125; and ur.rid=r.rid\") List&lt;Role&gt; findByUid(int uid);&#125; UserMapper接口方法 123456789101112131415public interface UserMapper &#123; @Select(\"select * from user_mb\") @Results(&#123; @Result(id = true, column = \"uid\", property = \"uid\"), @Result(column = \"uname\", property = \"uname\"), @Result(column = \"password\", property = \"password\"), @Result(column = \"birthday\", property = \"birthday\"), @Result( column = \"uid\", property = \"roles\", javaType = List.class, many = @Many(select = \"com.study.mapper.RoleMapper.findByUid\")) &#125;) List&lt;User&gt; findUserAndRoleAll();&#125; 测试 1234567891011121314151617public static final Logger logger = Logger.getLogger(AnnotationMMTest.class);private UserMapper mapper;@Beforepublic void before() throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); mapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testFindUserAndOrderAll() &#123; List&lt;User&gt; result = mapper.findUserAndRoleAll(); logger.debug(result);&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://lao-biao.github.io/tags/mybatis/"}]},{"title":"SpringBoot笔记","slug":"SpringBoot笔记","date":"2020-06-29T01:35:50.000Z","updated":"2020-07-06T03:24:26.594Z","comments":true,"path":"articles/e94425f6.html","link":"","permalink":"https://lao-biao.github.io/articles/e94425f6.html","excerpt":"SpringBoot笔记 官方文档：springboot SpringBoot基础特征 创建独立的Spring应用程序 直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件） 提供“入门”依赖项，以简化构建配置 尽可能自动配置Spring和3rd Party库 提供可用于生产的功能，例如指标，运行状况检查和外部化配置 完全没有代码生成，也不需要XML配置 版本介绍SNAPSHOT：开发版 CURRENT：最新版，不一定是稳定版 GA：General Availability 正式发布的版本","text":"SpringBoot笔记 官方文档：springboot SpringBoot基础特征 创建独立的Spring应用程序 直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件） 提供“入门”依赖项，以简化构建配置 尽可能自动配置Spring和3rd Party库 提供可用于生产的功能，例如指标，运行状况检查和外部化配置 完全没有代码生成，也不需要XML配置 版本介绍SNAPSHOT：开发版 CURRENT：最新版，不一定是稳定版 GA：General Availability 正式发布的版本 创建基于SpringBoot的项目 官网 IDEA的脚手架工具 IDEA的Maven项目 官网 spring initializr 填写完信息后点击Generate即可生成文件，下载解压后就是一个项目 IDEA的脚手架工具使用 IDEA 的 Spring Initalizr 工具创建 SpringBoot 项目 打开创建项目,选择 Spring Initializr ，选择对应的JDK路径和URL 填写项目设置 添加依赖和SpringBoot版本 选择项目名和路径，以及其他设置 IDEA的Maven项目使用IDEA创建Maven项目后，修改pom.xml文件 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;!-- SpringBoot版本 --&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- JDK版本 --&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- SpringBoot Web启动器，项目不使用可以不需要添加 --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!-- SpringBoot测试启动器，可以不添加 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!-- SpringBoot打包插件，必须有 --&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; SpringBoot项目结构POM文件继承123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; SpringBoot的父级依赖，只有继承它才是SpringBoot项目spring-boot-starter-parent 是一个特殊的starter，它用来提供相关的Maven默认依赖。使用它之后，常用的包依赖可以省去version标签 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 启动器依赖举例：web启动器 可使用第三方启动器 插件12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; spring-boot-maven-plugin 插件是将springboot的应用程序打包成jar包的插件。将所有应用启动运行所需要的jar包都包含进来，从逻辑上将具备了独立运行软件的条件。当运行mvn package进行打包后，使用java-jar命令就可以直接运行 启动类Spring Boot 的启动类的作用是启动Spring Boot 项目，是基于Main方法来运行的启动类在启动时会做注解扫描(@Controller、@Service、@Repository…) 启动类与启动器区别启动类：项目的启动入口 启动器：jar包的坐标 创建启动类1234567@SpringBootApplication //注解public class SpringBootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootDemoApplication.class, args); //启动类 &#125; &#125; INFO 13284 — [ main] c.s.s.SpringBootDemoApplication : Starting SpringBootDemoApplication on Dell with PID 13284INFO 13284 — [ main] c.s.s.SpringBootDemoApplication : No active profile set, falling back to default profiles: defaultINFO 13284 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)INFO 13284 — [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]INFO 13284 — [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.33]INFO 13284 — [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContextINFO 13284 — [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 2335 msINFO 13284 — [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService ‘applicationTaskExecutor’INFO 13284 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ‘’INFO 13284 — [ main] c.s.s.SpringBootDemoApplication : Started SpringBootDemoApplication in 4.181 seconds (JVM running for 9.543) 启动器Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starter ，只要在项目里引入这些 starter 相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景，在jar包上管理非常方便，最终实现一站式开发 Spring Boot 提供多达 44 个启动器 spring-boot-starter 核心启动器，包含了自动配置、日志和YAML spring-boot-starter-actuator 帮助监控和管理应用 spring-boot-starter-web 支持全栈式Web开发，包括Tomcat 和 spring-webmvc spring-boot-starter-amqp 通过spring-rabbit 来支持AMQP协议(Advanced Message Queuing Protocol) spring-boot-starter-jdbc 支持JDBC数据库 … 官网：springboot文档 配置文件Spring Boot 提供一个名称为application的全局配置文件，支持两种格式：Properties格式和YAML格式 Properties格式配置Tomcat监听端口 1server.port=3000 YAML格式YAML格式的扩展名可以是.yaml或.yml 基本格式： 区分大小写 使用缩进代表层级关系 相同的部分只出现一次 配置Tomcat监听端口 123server: port: 3000 host: xxxx 配置文件存放位置 项目根目录中 项目根目录下的一个congfig子目录中 项目的resources即classpath根路径中 项目的resources即classpath根路径下的config目录中 配置文件加载顺序不同格式的加载顺序如果在同一个目录下有application.yml 也有 application.properties，默认先读取application.properties 如果同一个配置属性，在多个配置文件都配置了，默认使用第一个读取到的，后面读取的不覆盖前面读取的 不同位置的加载顺序项目根目录下的config子目录(最高)config/application.propertiesconfig/applicaiton.yml 项目根目录(其次)application.propertiesapplicaiton.yml 项目的resources即classpath根路径下的config目录(一般)resources/config/application.propertiesresources/config/application.yml 项目的resources即classpath根路径(最后)resources/application.propertiesresources/application.yml 配置文件中的占位符占位符语法语法：${} 占位符作用${}中可以获取框架提供的方法中的值，如：random.int … 占位符可以获取配置文件中的键的值赋给另一个键作为值 生成随机数${random.value} 类似于uuid的随机数，没有 - 连接 ${random.int} 随机取整型范围内的一个值 ${random.long} 随机取长整型范围内的一个值 ${random.uuid} 生成一个uuid，有 - 连接 ${random.int(value)} 随机生成value以内的整型的值 ${random.int(value,max)} 随机生成value-max之间的整型的值 bootstrap配置文件Spring Boot中有两种上下文对象：bootstrap ， applicationbootstrap是应用程序的父上下文，其加载优先于application，bootstrap主要从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源bootstrap里面的属性会优先加载，它们默认也不能被本地相同配置覆盖 bootstrap配置文件特征bootstrap 由父ApplicationContext加载，比application优先加载 bootstrap里面的属性不能被覆盖 应用场景application 配置文件主要用于Spring Boot项目的自动化配置 bootstrap 配置文件应用场景： 使用Spring Cloud Config 配置中心时，需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息 一些固定的不能被覆盖的属性 一些加密/解密的场景 SpringBoot核心注解@SpringBootApplication配置Spring Boot的启动类 等同于 @Configuration + @EnableAutoConfiguration + @ComponentScan 的组合 @SpringBootConfiguration@SpringBootConfiguration 是 @Configuration 注解的派生注解，跟 @Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是 springboot的注解，而@Configuration 是 spring的注解 @Configuration通过对bean对象的操作替代 spring 中 的xml 配置文件 @EnableAutoConfigurationSpring Boot 自动配置：根据添加的jar依赖自动配置Spring应用是 @AutoConfiguration 和 @Import({AutoConfigurationImportSelector.class})注解的组合 @AutoConfigurationPackage自动注入主类下所在包下所有的加了注解的类(@Controller，@Service) @Import({AutoConfigurationImportSelector.class})直接导入普通的类导入实现了 ImportSelector 接口的类 导入实现了ImportBeanDefinitionRegister 接口的类 @ComponentScan组件扫描，可自动发现和装载一些 Bean ConfigurationPropertiesScan扫描配置属性 作用：使用 @ConfigurationProperties 注解的类生效 编写HelloWord 项目创建 修改POM文件 修改Tomcat端口 创建启动类 创建Controller 1234567891011/** * 处理请求 Controller */@RestController // @Controller + @ResponseBody 直接返回字符串（json）public class DemoController &#123; @RequestMapping(\"/helloWorld\") public String showHello() &#123; return \"Hello world\"; &#125;&#125; 启动应用后 访问 http://localhost:8080/helloWorld SpringBoot在Controller中常用注解@RestController相当于 @Controller + @ResponseBody 注解组合 如果使用 @RestController 注解，Controller中的方法无法返回页面，相当于在方法上面自动加了 @ResponseBody 注解，所以没办法跳转并传输数据到另一个页面，所以 InternalResourceResolver 也不起作用，返回的内容就是 return 里面的内容 @GetMappingRequestMapping(method = RequestMethod.Get) 的缩写 @PostMappingRequestMapping(method = RequestMethod.Post) 的缩写 @PutMappingRequestMapping(method = RequestMethod.Put) 的缩写 @DeleteMappingRequestMapping(method = RequestMethod.Delete) 的缩写 SpringBoot整合Web层技术整合Servlet整合Servlet方式一通过注解扫描完成Servlet组件的注册 创建Servlet 123456789/** * 整合Servlet方式一 */@WebServlet(name = \"FirstServlet\", urlPatterns = \"/first\")public class FirstServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(\"This is from first servlet\"); &#125;&#125; 修改启动类，添加@ServletComponentScan注解 在SpringBoot启动时会扫描@WebServlet注解，并将该类实例化 整合Servlet方式二通过方法完成Servlet组件的注册 创建Servlet servlet/SecondServlet.java 12345678/** * 整合Servlet方式二 */public class SecondServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(\"This is from second servlet.\"); &#125;&#125; 创建Servlet配置类 config/ServletConfig.java 1234567891011121314151617/** * Servlet组件注册类 */@Configurationpublic class ServletConfig &#123; /** * 完成Servlet组件的注册 * * @return */ @Bean public ServletRegistrationBean getServletConfigurationBean() &#123; ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet()); bean.addUrlMappings(\"/second\"); return bean; &#125;&#125; 整合Filter整合Filter方式一通过注解扫描完成Filter组件的注册 创建Filter filter/FisrtFilter.java 1234567891011121314151617181920212223/** * 整合Filter方式一 */// urlPatterns = &#123;\"*.do\", \"*.jsp\"&#125; 匹配多个url@WebFilter(filterName = \"FirstFilter\", urlPatterns = \"/first\")public class FirstFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"--------in first filter--------\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"--------out first filter--------\"); &#125; @Override public void destroy() &#123; &#125;&#125; 修改启动类，添加 @ServletComponentScan 注解 整合Filter方式二通过方法完成Filter组件的注册 创建Filter filter/SecondFilter.java 1234567891011121314151617181920212223/** * 整合Filter方式二 */public class SecondFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"--------in Second filter--------\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"--------out Second filter--------\"); &#125; @Override public void destroy() &#123; &#125;&#125; 创建Filter配置类 config/SecondFilter.java 1234567891011121314/** * Filter配置类 */@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean getFilterRegistrationBean() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()); //bean.addUrlPatterns(\"*.do\", \"*.jsp\"); //不定项参数，可以不使用 new String[]&#123;&#125; bean.addUrlPatterns(\"/second\"); return bean; &#125;&#125; 整合Listener整合Listener方式一通过注解扫描完成Listener组件注册 编写Listener listener/FirstListener.java 123456789101112131415161718192021222324/** * 整合Listener方式一 * ServletContextListener 监听上下文 */@WebListenerpublic class FirstListener implements ServletContextListener &#123; /** * 初始化 * * @param event */ public void contextInitialized(ServletContextEvent event) &#123; System.out.println(\"Listener--initialized\"); &#125; /** * 销毁 * * @param event */ public void contextDestroyed(ServletContextEvent event) &#123; &#125;&#125; 修改启动类 添加 @ServletComponentScan 注解 整合Listener方式二通过方法完成Listener组件的注册 创建Listener listener/SecondListener.java 1234567891011121314151617181920212223/** * 整合Listener方式二 * ServletContextListener 监听上下文 */public class SecondListener implements ServletContextListener &#123; /** * 初始化 * * @param event */ public void contextInitialized(ServletContextEvent event) &#123; System.out.println(\"Second Listener--initialized\"); &#125; /** * 销毁 * * @param event */ public void contextDestroyed(ServletContextEvent event) &#123; &#125;&#125; 创建Listener配置类 config/ListenerConfig.java 1234567891011/** * Listener配置类 */@Configurationpublic class ListenerConfig &#123; @Bean public ServletListenerRegistrationBean getServletListenerRegistrationBean() &#123; ServletListenerRegistrationBean bean = new ServletListenerRegistrationBean(new SecondListener()); return bean; &#125;&#125; SpringBoot访问静态资源在SpringBoot项目中没有常规web开发的WebContent(WebApp)，它只有src目录。在src/main/resources下面有两个文件夹，static和templates。SpringBoot默认在static目录存放静态页面，而templates中放动态页面。 static目录SpringBoot 通过classpath/static 目录访问静态资源 存放静态资源的目录名称必须是static 文件：static/index.html 直接访问：http://localhost:8080/index.html 通过controller跳转访问 controller/IndexPageController.java 1234567@Controllerpublic class IndexPageController &#123; @RequestMapping(\"/index\") public String showIndexPage() &#123; return \"index.html\"; &#125;&#125; 文件：static/index.html 访问地址：http://localhost:8080/index templtates目录SpringBoot 中不推荐使用jsp作为视图层技术，而是默认使用Thymeleaf来做动态页面 Teammates目录用来存放Thymeleaf的页面 静态资源存放其他位置SpringBoot访问静态资源的位置 classpath: 与java文件夹同级的resources目录 classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 自定义静态资源位置在application.properties文件中配置 1spring.resources.static-locations=classpath:/自定义资源位置1/,classpath:/自定义资源位置2/ SpringBoot文件上传 创建项目 配置POM文件 编写启动类 编写上传页面 12345678910111213&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;SpringBoot文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/fileUploadController\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"OK\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写Controller 1234567891011121314151617@RestControllerpublic class FileUploadController &#123; /** * 文件上传 * * @param file 参数名必须与fileupload.xml中的input标签的value值一致 * @return * @throws IOException */ @PostMapping(\"/fileUploadController\") public String fileUpload(MultipartFile file) throws IOException &#123; System.out.println(file.getOriginalFilename()); file.transferTo(new File(\"D:/upload/\" + file.getOriginalFilename())); return \"OK\"; &#125;&#125; 修改上传文件大小 1234# 设置单文件上传的容量限制spring.servlet.multipart.max-file-size=2MB# 配置在一次请求中上传文件总容量的限制spring.servlet.multipart.max-request-size=20MB SpringBoot整合视图层技术SpringBoot整合JSP技术创建项目 修改POM文件，添加JSP引擎与JSTL标签库 12345678910&lt;!--添加jsp引擎依赖，SpringBoot内置Tomcat没有此依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jsper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--添加JSTL标签库依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 创建webapp目录 main目录下与java、resource同级 标记为web目录 创建JSP 修改配置文件，配置视图解析器 1234# 前缀spring.mvc.view.prefix=/WEB-INF/jsp/# 后缀spring.mvc.view.suffix=.jsp 创建Controller 12345678@Controllerpublic class PageController &#123; // 页面跳转 @GetMapping(\"/&#123;page&#125;\") public String showPage(@PathVariable String page) &#123; return page; &#125;&#125; 如果在IDEA中项目为聚合工程，在运行jsp时是需要指定路径。 SpringBoot整合Freemarker创建项目 修改POM文件，添加Freemarker启动器 12345&lt;!--Freemarker依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 创建User实体 1234567891011121314151617181920212223242526272829303132333435363738public class User &#123; private String uname; private String gender; private int age; public User() &#123; &#125; public User(String uname, String gender, int age) &#123; this.uname = uname; this.gender = gender; this.age = age; &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 创建Controller 123456789101112@Controllerpublic class UserController &#123; @GetMapping(\"/showUsers\") public String showUsers(Model model) &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(\"张三\", \"男\", 20)); list.add(new User(\"李四\", \"男\", 22)); list.add(new User(\"王五\", \"男\", 18)); model.addAttribute(\"list\", list); return \"userlist\"; &#125;&#125; 创建视图 templates/userlist.ftl 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringBoot整合Freemarker&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1px\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Gender&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;#list list as user&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.uname&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 配置Freemarker文件后缀（SpringBoot2.x后默认为.ftlh） 1spring.freemarker.suffix=.ftl","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"https://lao-biao.github.io/tags/spring-boot/"}]},{"title":"SpringMVC笔记","slug":"SpringMVC笔记","date":"2020-06-28T13:29:57.000Z","updated":"2020-07-06T03:24:35.176Z","comments":true,"path":"articles/e545fed0.html","link":"","permalink":"https://lao-biao.github.io/articles/e545fed0.html","excerpt":"SpringMVCSpringMVC概述SpringMVC是基于Java实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在SpringWebFlow中。 SpringMVC通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口，同时支持RESTful编程风格的请求。","text":"SpringMVCSpringMVC概述SpringMVC是基于Java实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在SpringWebFlow中。 SpringMVC通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口，同时支持RESTful编程风格的请求。 开发步骤 导入SpringMVC相关依赖包 配置SpringMVC核心控制器DispatcherServlet 编写Controller类和视图页面–”@Controller与@RequestMapping” 将Controller使用注解配置到Spring容器中 配置spring-mvc.xml文件(配置组件扫描) 客户端发起请求测试 SpringMVC中重要组件DispatcherServlet：前端控制器，接收所有请求（如果配置/不包含jsp） HandlerMapping：解析请求格式，判断希望要执行哪个具体的方法 HandlerAdapter：负责调用具体的方法 Handler：处理器 ViewResolver：视图解析器，解析结果，准备跳转到具体的物理视图 View：视图 SpringMVC运行原理 客户端向Tomcat发送请求 前端控制器DispatcherServlet–请求查询Handler 处理器映射器HandlerMapping HandlerAdapter Controller ViewResolver 前端控制器返回处理器执行链HandlerExecuctionChain SpringMVC注解@RequestMappping@RequestMappping作用：用于建立请求URL和处理方法之间的对应关系 位置 类：请求URL的第一级访问目录，此处不写就相当于应用的根目录 方法：请求URL的第二级访问目录，与类上使用的@RequestMapping标注的一级目录一起组成访问虚拟路径 属性 value：用于指定请求的URL，和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件，它支持简单的表达式，要求请求参数的key和value必须和配置的一模一样 params={“accountName”}：表示请求参数必须有accountName params={“moeny!100”}：表示请求参数中money不能是100 视图解析器配置1234567&lt;!--配置内部资源视图解析器--&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--配置前缀--&gt; &lt;property name=\"prefix\" value=\"/jsp/\"/&gt; &lt;!--配置后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; SpringMVC的数据响应页面跳转 直接返回字符串：将返回的字符串与视图解析的前后缀拼接后跳转 举例 返回”index” 前缀为/jsp/ 后缀为.jsp 转发资源 /jsp/index.jsp 转发 forward:/jsp/index.jsp 重定向 redirect:/index.jsp 通过ModelAndView对象返回 回写数据 直接返回字符串（json）：使用@ResponseBody注解 通过SpringMVC框架注入的response对象，使用response.getWriter.write()回写数据，此时不需要视图跳转，业务方法返回值为void json格式 12345678910111213141516&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;!--配置编码格式--&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置jackson转换器--&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 返回对象或集合mvc注解驱动替代上述配置 12&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven/&gt; 在SpringMVC各个组件中，处理器映射器、处理器适配器、视图解析器成为SpringMVC的三大组件，使用&lt;mvc:annotation-driven/&gt;自动加载RequestMappingHandlerMapping（）处理映射器和RequestMappingHanlderAdapter（处理适配器），可用在spring-xml.xml配置文件中使用&lt;mvc:annotation-driven/&gt;替代注解注解处理器和适配器的配置。 使用&lt;mvc:annotation-driven/&gt;默认底层就会继承jackson进行对象或集合的json格式字符串的转换 SpringMVC获取请求数据客户端请求参数的格式是：name=value&amp;name=value… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收的参数类型为 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 获取基本类型参数Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。 12345@RequestMapping(\"/param\")@ResponseBodypublic void param(String uname, int age) &#123; System.out.println(uname + \":\" + age);&#125; 获取POJO类型参数Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 1234567891011121314/*POJO实体*/public class User &#123; private String uname; private String gender; private int age; getter/setter...&#125;/*Controller*/@Controller@RequestMapping(\"/parampojo\")@ResponseBodypublic void paramPojo(User user) &#123; System.out.println(user.getUname() + \":\" + user.getGender() + \":\" + user.getAge());&#125; 获取数组类型参数Controller中的业务方法的数组名称与请求参数的name一致，参数值会自动映射匹配。 12345@RequestMapping(\"/paramarray\")@ResponseBodypublic void paramArray(String[] arr) &#123; System.out.println(Arrays.toString(arr));&#125; 获得集合类型参数获取集合参数时，要将集合包装到一个POJO中。 1234567891011/*POJO包装集合参数*/public class ViewObject &#123; private List&lt;User&gt; lu; getter/setter&#125;/*Controller*/@RequestMapping(value = \"/paramset\", method = RequestMethod.POST)@ResponseBodypublic void paramSet(ViewObject vo) &#123; System.out.println(vo);&#125; 12345678910111213141516171819202122232425&lt;%--form.jsp--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;title&gt;测试获取集合类型参数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"paramset\" method=\"post\"&gt; unmae:&lt;input type=\"text\" name=\"lu[0].uname\"&gt;&lt;br&gt; gender:&lt;input type=\"text\" name=\"lu[0].gender\"&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"lu[0].age\"&gt;&lt;br&gt; &lt;hr&gt; unmae:&lt;input type=\"text\" name=\"lu[1].uname\"&gt;&lt;br&gt; gender:&lt;input type=\"text\" name=\"lu[1].gender\"&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"lu[1].age\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 当使用ajax提交时，可以指定contentType为json形式，在方法参数位置使用@ReqeustBody可以直接接收集合数据而无需使用POJO进行包装。 123456789101112131415&lt;%--ajax.jsp--%&gt;&lt;!--引入jquery--&gt;&lt;script src=\"js/jquery-3.3.1.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var userList = []; userList.push(&#123;uname: \"张三\", gender: \"Male\", age: 19&#125;); userList.push(&#123;uanme: \"李四\", gender: \"Female\", age: 20&#125;); $.ajax(&#123; type: \"POST\", url: \"paramajax\", data: JSON.stringify(userList), contentType: \"application/json;charset=utf-8\" &#125;)&lt;/script&gt; 123456/*Controller*/@RequestMapping(value = \"/paramajax\", method = RequestMethod.POST)@ResponseBodypublic void paramAjax(@RequestBody List&lt;User&gt; userList) &#123; System.out.println(userList);&#125; 需要在spring-mvc.xml中需要配置文件资源路径 1234&lt;!--配置文件资源路径映射--&gt;&lt;mvc:resources mapping=\"/js/*\" location=\"/js/\"/&gt;&lt;!--或者使用--&gt;&lt;mvc:default-servlet-handler/&gt; 参数绑定注解@RequestParam当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显式的绑定。 value：请求参数名称 required：在指定的请求参数是否必须包括，默认是true，提交时没有此参数则报错 defaultValue：当没有指定请求参数时，则使用指定的默认值赋值 获取Restful风格的参数Restful是一种架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互的软件，基于这个歌风格设计的软件更简洁，更有层次，更易于实现缓存机制。 Restful风格的请求是使用”url+请求方式”表示一次请求的目的，HTTP协议里面四个表示操作方式 GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 SpringMVC中使用占位符进行参数绑定，地址/user/1可以携程/user/{id}，占位符{id}对应的就是1的值，在业务方法中可以使用@PathVariable注解进行占位符的匹配获取。 自定义类型转换器SpringMVC默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int类型进行参数设置。 自定义类型转换器开发步骤 定义转换器类实现Convert接口 在配置文件中声明转换器 在&lt;annotation-driven&gt;标签中引用转换器 自定义日期类型转换器12345678910111213141516171819public class DateConverter implements Converter&lt;String, Date&gt; &#123; public Date convert(String s) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = null; try &#123; date = sdf.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125;/*Controller*/@RequestMapping(value = \"/param/&#123;date&#125;\")@ResponseBodypublic void paramDate(@PathVariable(value = \"date\") Date date) &#123; System.out.println(date);&#125; 12345678&lt;!--配置自定义转换器--&gt;&lt;bean id=\"myConverter\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.study.converter.DateConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 1&lt;mvc:annotation-driven conversion-service=\"myConverter\"/&gt; 获取请求头使用@RequestHeader注解可以获取请求头信息，相当于request.getHeader(String name) value：请求头的名称 required：是否必须携带此请求头 使用@CookieValue注解可以获取指定Cookie信息 value：指定cookie的名称 required：是否必须携带此cookie 文件上传文件上传客户端三要素 表单项 type=”file” 表单的提交方式时post 表单的enctype属性是多部分表单形式，即enctype=”multipart/form-data” 12345&lt;form action=\"upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件名:&lt;input type=\"text\" name=\"filename\"&gt;&lt;br&gt; 文件:&lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt; 文件上传原理 当form表单修改为多部分表单时，request.getParameter将失效 enctype=”application/x-www-form-urlencoded”时，form表单正文内容格式是key=value&amp;key=value… 当form表单的enctype的取值是multipart/form-data时，请求正文内容为多部分形式 单文件上传步骤 导入fileupload和io坐标 配置文件上传解析器 编写文件上传代码 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 123456789&lt;!--配置文件上传解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--上传文件的编码格式--&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!--上传文件总大小--&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;!--上传单个文件大小--&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"5242880\"/&gt;&lt;/bean&gt; 12345678910@RequestMapping(value = \"/upload\")@ResponseBodypublic void uploadFile(String uname, MultipartFile file) throws IOException &#123; System.out.println(\"ParamController.upload\"); // 获取文件名称 String filename = file.getOriginalFilename(); System.out.println(uname + \"上传了\" + filename); // 存储 file.transferTo(new File(\"D:/upload/\" + filename));&#125; 多文件上传只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型改为MultipartFile[]即可。 123456&lt;form action=\"upload-multiply\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名:&lt;input type=\"text\" name=\"uname\"&gt;&lt;br&gt; 文件1:&lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; 文件2:&lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt; 123456789101112@RequestMapping(value = \"/upload-multiply\")@ResponseBodypublic void uploadMultiplyFile(String uname, MultipartFile[] file) throws IOException &#123; System.out.println(\"ParamController.upload\"); for (MultipartFile multipartFile : file) &#123; // 获取文件名称 String filename = multipartFile.getOriginalFilename(); System.out.println(uname + \"上传了\" + filename); // 存储 multipartFile.transferTo(new File(\"D:/upload/\" + filename)); &#125;&#125; SpringMVC拦截器拦截器（interceptor） SpringMVC的拦截器类似于Servlet开发中的过滤器Filter，用于对处理器的预处理和后处理。 将拦截器按一定的顺序联结成一条链，称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 拦截器是AOP思想的具体实现 拦截器与过滤器的区别 区别 过滤器 拦截器 使用范围 过滤器是Servlet规范中的一部分，任何JavaWeb工程都可以使用 SpringMVC框架，只有使用了SpringMVC框架的工程才能使用 拦截范围 在url-pattern中配置了/*之后，可以对所有要访问的资源拦截 只会拦截访问的控制器方法，如果访问的是jsp，html，css，image或者js是不会进行拦截 自定义拦截器步骤 创建拦截器类实现HandlerInterceptor接口 配置拦截器 测试拦截器的拦截效果 HandlerInterceptor接口源码 123456789101112public interface HandlerInterceptor &#123; // 执行于目标方法之前 default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; // true表示放行，false表示不放行 &#125; // 执行于目标方法之后，视图对象返回之前 default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; // 执行于视图对象返回之后 default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; 在spring-mvc.xml中配置拦截器 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/*\"/&gt; &lt;bean class=\"自定义的Interceptor实现类全路径\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器方法说明 方法名 说明 preHandle() 该方法在请求处理之前进行调用，其返回值为boolean类型，当它返回false时，表示请求结束，后续的Interceptor和Controller都不会在执行；当它返回true时，会继续调用下一个Interceptor的preHandle方法。 postHandle() 该方法实在当前请求进行处理之后被调用，前提是preHandle方法的返回值为true时才能被调用，且它会在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。 afterCompletion() 该方法将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图对象之后执行，前提是preHandle方法放行才能被调用。 SpringMVC异常处理机制异常处理的思路系统中异常包括两类：预期异常和运行异常RuntimeException，前者能通过捕获异常从而获取异常信息，或者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理。 客户端–请求–&gt;前端控制器–请求–&gt;Controller–请求–&gt;Service–请求–&gt;Dao处理：前端控制器–&gt;HandlerExceptionResolver SpringMVC异常处理两种方式 使用MVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandlerExceptionResolver自定义异常处理器 简单异常处理器SimpleMappingExceptionResolver123456789101112&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;!--默认错误视图--&gt; &lt;property name=\"defaultErrorView\" value=\"error\"/&gt; &lt;!--异常映射--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;map&gt; &lt;entry key=\"com.study.exception.MyException\" value=\"error\"/&gt; &lt;entry key=\"java.lang.ClassCastException\" value=\"error\"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理步骤 创建异常处理类实现HandlerExceptionResolver 配置异常处理器 编写异常页面 测试异常跳转 12345678910111213141516171819202122public class MyExceptionResolver implements HandlerExceptionResolver &#123; /** * @param req 请求 * @param resp 响应 * @param o * @param e 异常对象 * @return 要跳转的错误视图信息 */ public ModelAndView resolveException(HttpServletRequest req, HttpServletResponse resp, Object o, Exception e) &#123; ModelAndView mav = new ModelAndView(); if (e instanceof MyException) &#123; mav.addObject(\"info\", \"自定义异常\"); mav.setViewName(\"my-error\"); &#125; else if (e instanceof ClassCastException) &#123; mav.addObject(\"info\", \"类型转换异常\"); mav.setViewName(\"class-cast-error\"); &#125; else &#123; mav.setViewName(\"error\"); &#125; return mav; &#125;&#125; 12&lt;!--配置自定义异常处理器--&gt;&lt;bean class=\"com.study.resolver.MyExceptionResolver\"/&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"https://lao-biao.github.io/tags/spring-mvc/"}]},{"title":"Spring5笔记","slug":"Spring5笔记","date":"2020-06-27T14:55:36.000Z","updated":"2020-07-06T03:24:16.490Z","comments":true,"path":"articles/70b6ad8d.html","link":"","permalink":"https://lao-biao.github.io/articles/70b6ad8d.html","excerpt":"Spring框架概述1、Spring是轻量级的开源JavaEE框架2、Spring可以解决企业级应用开发的复杂性3、Spring的两个核心部分：IOC和Aop IOC：控制反转，把创建对象过程交给Spring管理 Aop：面向切面编程，不修改源代码进行功能增强 4、Spring特点 方便解耦，简化开发 Aop编程支持 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低API开发难度 5、Spring5","text":"Spring框架概述1、Spring是轻量级的开源JavaEE框架2、Spring可以解决企业级应用开发的复杂性3、Spring的两个核心部分：IOC和Aop IOC：控制反转，把创建对象过程交给Spring管理 Aop：面向切面编程，不修改源代码进行功能增强 4、Spring特点 方便解耦，简化开发 Aop编程支持 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低API开发难度 5、Spring5 入门案例Spring主页 Spring框架 IOCIOC（概念和原理）IOC（Inversion of Control） 控制反转，把对象创建和对象之间额调用过程交给Spring进行管理 使用IOC目的：为了耦合度降低 入门案例就是IOC实现 IOC底层原理xml解析、工厂模式、反射 IOC过程xml配置文件，配置创建的对象 &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt; Service类和Dao类，创建工厂类 12345678class UserFactory&#123; public static UserFactory getDao()&#123; String classValue=class属性值; // xml解析 // 通过反射创建对象 Class clazz=Class.forName(classValue); return (UserDao)clazz.newInstance(); &#125;&#125; 进一步降低耦合度 IOC接口 IOC思想基于IOC容器完成，IOC底层就是对象工厂 Spring提供IOC容器实现的两种方式（2个接口）BeanFactory：IOC容器基本实现，是Spring内置接口，不提供开发人员进行使用 加载配置文件时不会创建对象， 在获取对象或适用对象时才会创建 ApplicationContext：BeanFactory接口的子接口，提供更强大的功能，一般由开发人员进行使用加载配置文件时就会把在配置文件对象进行创建 ApplicationContext接口实现类FileSystemXmlApplicationContextClassPathXmlApplicationContext IOC操作Bean管理Bean管理 Bean管理指的是两个操作 Spring创建对象 Spring注入属性 Bean管理操作两种方式 基于xml配置文件方式实现 基于注解方式实现 IOC操作Bean管理（基于xml）基于xml方式创建对象 在Spring配置文件中，使用bean标签，标签里面添加对应的属性，就可以实现对象创建 在bean标签中有很多属性，常用属性id属性：唯一标识class属性：类全路径（包名路径）name属性：旧版本常用与id类似 创建对象时，默认执行无参构造方法完成对象创建 基于xml方式注入属性DI：依赖注入，注入属性 第一种注入方式：使用set方法进行注入 创建类，定义属性和相应的set方法 在Spring配置文件 1234&lt;bean id=\"book\" class=\"com.spring5.Book\"&gt; &lt;!--使用property完成属性注入--&gt; &lt;property name=\"name\" value=\"Spring5\"/&gt;&lt;/bean&gt; 第二种注入方式：使用有参构造方法进行注入 创建类，定义属性，创建相应的有参构造方法 在Spring配置文件中 1234&lt;bean id=\"order\" class=\"com.spring5.Order\"&gt; &lt;constructor-arg name=\"name\" value=\"Food\"/&gt; &lt;constructor-arg name=\"address\" value=\"China\"/&gt;&lt;/bean&gt; p名称空间注入使用p名称空间注入，可以简化基于xml注入方式 添加p名称空间在配置文件中xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 进行属性注入，在bean标签里面进行操作 1&lt;bean id=\"b\" class=\"com.spring5.Book\" p:name=\"Spring5\"&gt;&lt;/bean&gt; IOC操作Bean管理（xml注入其他类型属性）字面量null值 123&lt;property name=\"\"&gt; &lt;null/&gt;&lt;/property&gt; 属性值包含特殊符号 &lt;&gt;尖括号进行转译 lt; gt; 把特殊符号内容写到CDATA 例如：&lt;&lt;value&gt;&gt; 12345&lt;property name=\"name\"&gt; &lt;value&gt; &lt;![CDATA[&lt;&lt;value&gt;&gt;]]&gt; &lt;/value&gt;&lt;/property&gt; 注入属性~外部bean创建两个类Service类和Dao类在Service类调用Dao类里面的方法在Spring配置文件中进行配置 12345&lt;bean id=\"us\" class=\"com.spring5.service.UserService\"&gt; &lt;!--注入UserDao对象--&gt; &lt;property name=\"ud\" ref=\"udi\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"udi\" class=\"com.spring5.dao.UserDaoImpl\"&gt;&lt;/bean&gt; 注入属性~内部bean一对多关系：部门和员工在实体类之间表示一对多关系在Spring配置文件中进行配置 1234567891011&lt;bean id=\"emp\" class=\"com.spring5.bean.Employee\"&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=\"name\" value=\"Tom\"/&gt; &lt;property name=\"gender\" value=\"man\"/&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=\"dep\"&gt; &lt;bean class=\"com.spring5.bean.Department\"&gt; &lt;property name=\"name\" value=\"program\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 注入属性~级联赋值方法一1234567891011121314&lt;bean id=\"emp\" class=\"com.spring5.bean.Employee\"&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=\"name\" value=\"Tom\"/&gt; &lt;property name=\"gender\" value=\"man\"/&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=\"dep\"&gt; &lt;bean class=\"com.spring5.bean.Department\"&gt; &lt;property name=\"name\" ref=\"dep\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dep\" class=\"com.spring5.bean.Department\"&gt; &lt;property name=\"name\" value=\"program\"&gt;&lt;/property&gt;&lt;/bean&gt; 方法二需要生成Employee类中Department属性的set方法 1234567891011121314&lt;bean id=\"emp\" class=\"com.spring5.bean.Employee\"&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=\"name\" value=\"Tom\"/&gt; &lt;property name=\"gender\" value=\"man\"/&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=\"dep\" ref=\"dep\"&gt; &lt;/property&gt; &lt;property name=\"dep.name\" value=\"program\"&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dep\" class=\"com.spring5.bean.Department\"&gt; &lt;property name=\"name\" value=\"program\"&gt; &lt;/property&gt;&lt;/bean&gt; IOC操作Bean管理（xml注入集合属性） 注入数组类型属性 注入List集合类型属性 注入Map集合类型属性 注入Set集合类型属性 123456789101112131415161718192021222324252627282930&lt;bean id=\"stu\" class=\"com.spring5.Stu\"&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=\"courses\"&gt; &lt;array&gt; &lt;value&gt;Java&lt;/value&gt; &lt;value&gt;SQL&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list类型属性注入--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map类型属性注入--&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"Java\" value=\"java\"/&gt; &lt;entry key=\"Python\" value=\"python\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set类型属性注入--&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;Java&lt;/value&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 在集合里面设置对象类型值 把集合的注入部分提取出来在Spring配置文件中引入名称空间util使用util标签完成诸如部分的提取 IOC操作Bean管理（FactoryBean）Spring有两种类型bean，一种是普通bean，另一种是工厂bean（FactoryBean）普通bean：在配置文件中定义bean类型就是返回类型工厂bean：在配置文件中定义bean类型可以和返回类型不一样 创建类，让这个类作为工厂bean，实现接口FactoryBean 实现接口里面的方法，在实现的方法中定义返回的bean类型 IOC操作Bean管理（bean作用域）在Spring里面，设置创建bean实例是单实例还是多实例在Spring里面，默认情况下，bean是单实例对象 在Spring配置文件中bean标签里面有属性值（scope）用于设置单实例还是多实例 scope属性 singleton表示单实例[默认值] prototype：表示多实例singleton与prototype区别 singleton单实例，prototype多实例 设置scope值是singleton时，加载Spring配置文件时候就会创建单实例对象 设置scope值是prototype，不是在加载Spring配置文件时不会创建bean对象，在调用getBean()方法时创建多实例对象request、session IOC操作Bean管理（生命周期） 通过构造器创建bean实例（无参构造） 为bean的属性设置值和其他bean引用（调用set方法） 调用bean的初始化的方法（需要进行配置初始化的方法）bean标签init-method属性 bean可以使用（已获取对象） 当容器关闭时，调用bean的销毁的方法（需要进行配置销毁的方法）bean标签destroy-method属性 bean的后置处理器，bean生命周期的七步 通过构造器创建bean实例（无参构造） 为bean的属性设置值和其他bean引用（调用set方法） 把bean实例传递bean后置处理器的方法postProcessBeforeInitialization(Object bean, String beanName) 调用bean的初始化的方法（需要进行配置初始化的方法） 把bean实例传递bean后置处理器的方法postProcessAfterInitialization(Object bean, String beanName) bean可以使用（已获取对象） 当容器关闭时，调用bean的销毁的方法（需要进行配置销毁的方法） 后置处理器接口：BeanPostProcessor IOC操作Bean管理（xml自动装配）自动装配根据指定装配规则（属性名称或属性类型），Spring自动将配置的属性值进行注入 bean标签autowire属性 byName根据属性名称注入，注入值bean的id值和类属性名称一样 byType根据属性类型注入 自动装配过程根据属性名称自动注入 根据属性类型自动注入 IOC操作Bean管理（外部属性文件）直接配置数据库信息配置连接池–德鲁伊druid（Alibaba） 123456&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt; 引入外部属性文件配置数据库连接池 创建外部属性文件，properties格式文件，写数据库信息 1234prop.driverClass=com.mysql.jdbc.Driverprop.url=jdbc:mysql://localhost:3306/studyprop.userName=rootprop.password=123456 把外部properties属性文件引入到Spring配置文件引入context名称空间 12xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=”http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\" 在Spring配置文件中使用标签 1234567&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;prop.driverClass&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;prop.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;prop.userName&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;prop.password&#125;\"/&gt;&lt;/bean&gt; IOC操作Bean管理（基于注解方式）Spring针对Bean管理中创建对象提供的注解 @Component @Service 业务逻辑层 @Controller Web层 @Repository Dao层 以上四个注解功能时一样的，都可以用来创建bean实例 基于注解方式实现对象创建 引入依赖 spring-aop.jar 开启组件扫描使用context命名空间&lt;context:component-scan base-package=&quot;&quot;/&gt; 创建类，在类上面添加相应的注解 123use-default-filters=\"false\" 不适用默认的filter&lt;context:include-filter type=\"\" expression=\"\"/&gt; 设置扫描哪些内容&lt;context:exclude-filter type=\"\" expression=\"\"/&gt;设置哪些内容不进行扫描 基于注解方式实现属性注入 @Autowired：根据属性类型进行自动装配把service和dao对象创建，在service和dao实现类添加创建对象注解在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解 @Qualifier：根据属性名称进行注入 @Qualifier注解的使用和@Autowired一起使用 12@Autowired@Qualifier(value = \"userDaoImpl\") // 根据名称进行注入 @Resource：可以根据类型注入；可以根据名称注入 12@Resource // 根据类型注入@Resource(name = \"userDaoImpl\") // 根据名称注入 @Value：注入普通类型属性 12@Value(value = \"Spring\")private String name; 完全注解开发 创建配置类，替代xml配置文件 1234@Configuration@ComponentScan(basePackages = &#123;\"com.spring5\"&#125;)public class SpringConfig &#123;&#125; 编写测试类 123456@Testpublic void testService2() &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); UserService us = ac.getBean(\"userService\", UserService.class); us.add();&#125; AOPAOP（概念）面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 不通过修改源代码方式，在主干功能里面添加新功能 登录–权限判断模块 AOP（底层原理）AOP底层使用动态代理两种情况动态代理 有接口情况，使用JDK动态代理创建接口实现类的代理对象，增强类的方法 没有接口情况，使用CGLIB动态代理创建当前类子类的代理对象，增强类的方法 AOP（JDK动态代理）使用Proxy类里面的方法创建代理对象 调用newProxyInstance()方法 ClassLoader:类加载器 &lt;?&gt;[]interface:增强方法所在的类，这个类实现的接口，支持多接口 InvocationHandler:实现这个接口，创建代理对象，写增强的方法 AOP（术语）连接点：类里面可以被增强的方法 切入点：实际被真正增强的方法 通知（增强）：实际增强的逻辑部分通知有多种类型 前置通知 后置通知 环绕通知 异常通知 最终通知 切面：把通知应用到切入点过程 AOP操作（准备） Spring框架一般基于AspectJ实现AOP操作AspectJ：独立的AOP框架 基于AspectJ实现AOP操作 基于xml配置文件实现 基于注解方式实现 在项目工程里面引入AOP相关依赖cglib.jaraopalliance.jarweaver.jarspring-aspects.jar 切入点表达式切入点表达式作用：知道对哪个类里面的哪个方法进行增强语法结构：exexcution([权限修饰符][返回类型][类全路径][方法名称]([参数列表])) AOP操作（AspectJ注解） 创建类，在类里面定义方法 创建增强类（编写增强逻辑）在增强类里面创建方法，让不同方法待变不同通知类型 进行通知的配置 在Spring配置文件中，开启注解扫描 使用注解创建User和UserProxy对象 在增强类上面添加注解@Aspect 在Spring配置文件中开启生成代理对象 配置不同类型的通知在增强类里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 相同切入点抽取 有多个增强类中在同一个方法增强，设置增强类的优先级在增强类上面添加注解@Order(数字类型值)，数字类型值越小优先级越高 AOP操作（AspectJ配置文件） 创建两个类，增强类和被增强类，创建方法 在Spring配置文件中创建两个类对象 在Spring配置文件中配置切入点 JdbcTemplateJdbcTemplate（概念和准备）JdbcTemplate：Spring框架对JDBC进行封装，使用JDBCTemplate方便实行数据库操作 准备 引入相关jar包druidmysql-connectorspring-jdbcspring-txspring-orm 在Spring配置文件配置数据库连接池 配置JdbcTemplate对象，注入DataSource 创建service类，创建dao类，在service中注入dao对象，在dao中注入JdbcTemplate对象 JdbcTemplate操作数据库（添加） 对应数据库创建实体类 编写service和dao 在dao进行数据库添加操作 调用JdbcTemplate对象里面update(String sql,Object.. args)方法实现添加操作 参数1：sql语句 参数2：可变参数，设置sql语句值 测试类 JdbcTemplate操作数据库（查询、修改、删除）调用JdbcTemplate对象里面update(String sql,Object.. args)方法 JdbcTemplate操作数据库（查询）查询表里面有多少条记录，返回是某个值 使用JdbcTemplate对象里面selectForObject(String sql,Class requiredType)方法实现查询操作 参数1：sql语句 参数2：返回类型.class JdbcTemplate操作数据库（查询返回对象）查询表返回对象 使用JdbcTemplate对象里面selectForObject(String sql,RowMapper&lt;? extends Object&gt; rowMapper,Object ..args )方法实现查询操作 参数1：sql语句 参数2：RowMapper,接口，返回不同的数据类型，使用这个接口的实现类完成数据封装 参数3：sql语句值 JdbcTemplate操作数据库（查询返回集合）查询表返回集合 使用JdbcTemplate对象里面query(String sql,RowMapper&lt;? extends Object&gt; rowMapper,Object ..args )方法实现查询操作 参数1：sql语句 参数2：RowMapper,接口，返回不同的数据类型，使用这个接口的实现类完成数据封装 参数3：sql语句值 JdbcTemplate操作数据库（批量添加）批量操作：操作表里面多条记录 JdbcTemplate实现批量操作batchUpdate(String sql,List&lt;Object[]&gt; batchArgs) 参数1：sql语句 参数2：List集合，添加多条记录数据 JdbcTemplate操作数据库（批量修删除）批量操作：操作表里面多条记录 JdbcTemplate实现批量操作batchUpdate(String sql,List&lt;Object[]&gt; batchArgs) 参数1：sql语句 参数2：List集合，添加多条记录数据 事务事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果一个失败所有操作都失败 典型场景：银行转账 事务四个特性（ACID） 原子性 一致性 隔离性 持久性 问题引入 创建数据库表，添加记录 创建service，搭建dao，完成对象创建和注入关系service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource 在dao创建两个方法，多钱和少钱，在service创建方法（转账的方法），调用dao中的两个方法 在执行过程中出现异常时，数据会出错 解决方法：使用事务 事务操作过程 开启事务 进行业务操作 没有异常，提交事务 出现异常，事务回滚 事务操作（Spring事务管理介绍） 事务添加到Java EE三层结构里面Service层（业务逻辑层） 在Spring进行事务管理操作编程式事务管理和声明式事务管理（使用） 声明式事务管理 基于注解方法 基于xml配置文件方式 在Spring进行声明式事务管理，底层使用AOP原理 SPring事务管理APIPlatformTransactionManager 接口–事务管理器，针对不同框架提供不同实现类 事务操作（注解声明式事务管理） 在Spring配置文件配置事务管理器 在Spring配置文件中，开启事务注解 在Spring配置文件中引入名称空间tx 开启事务注解 在Service类上面（或者Service类方法上面）添加事务注解 @Transactional 类：所有的方法都添加事务 方法：只为当前方法添加事务 事务操作（注解声明式事务管理参数配置） 在Service类上面添加注解@Transactional，注解参数配置 Propagation：事务传播行为多事务方法（对数据库表数据进行变化的操作）进行调用 行为 描述 REQUIRED 如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行 REQUIRED_NEW 当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起 SUPPORTS 如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中 NOT_SUPPORTS 当前的方法不应该运行在事务中，如果有运行的事务，将它挂起 MANDATORY 当前的方法必须运行在事物内部，如果没有正在运行的事务，就抛出异常 NEVER 当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常 NESTED 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行 Ioslation：事务隔离级别事务有特性称为隔离性，多事务操作之间不会产生影响，不考虑隔离性产生很多问题读问题：脏读、不可重复读、虚（幻）读 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交的事务读取到另一提交事务修改的数据 虚读：一个未提交事务读取到另一提交事务添加数据 隔离级别 脏读 不可读 虚读 READ_UNCOMMITED（读未提交） 有 有 有 READ_COMMITTED（读已提交） 无 有 有 REPEATABLE_READ（可重复读） 无 无 有 SERIALIZABLE（串行化） 无 无 无 TimeOut：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚默认值是-1，设置时间以秒为单位进行计算 ReadOnly：是否只读读：查询操作，写：添加修改删除操作 默认值为false，表示可以查询，可以添加修改删除操作 设置为true，表示只能查询 RollbcakFor：回滚设置出现哪些异常进行事务回滚 NoRollbackFor：不回滚设置出现哪些异常不进行事务回滚 事务操作（XML声明式事务管理）在Spring配置文件中进行配置 配置事务管理器 配置通知 配置切入点和切面 事务操作（完全注解声明式事务管理）创建配置类，使用配置类代替 Spring5框架新特性 整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除 Spring5框架自带了通用的日志封装Spring5已经移除Log4jConfigListener，官方建议使用Log4j2Spring5框架整合Log4j2 引入jar包log4j-api-2log4j-core-2log4j-slf4j-impl-2slf4j-api 创建log4j2.xml Spring5框架核心容器支持@Nullable注解@Nullable注解可以用在方法、属性、参数上，表示方法返回值可以为空，属性值可以为空，参数值可以为空 Spring5核心容器支持函数式风格GenericApplicationContext注册对象 Spring5支持整合JUnit5 整合JUnit4 引入Spring相关针对测试依赖spring-test 编写测试类@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(“classpath:.xml”) 注意：@Test导入的包为import org.junit.Test; 整合JUnit5 引入JUnit的jar包 编写测试类@ExtendWith(SpringExtension.class)@ContextConfiguration(“classpath:.xml”) 注意：@Test导入的包为import org.junit.jupiter.api.Test; 使用复合注解@SpringJUnitConfig(locations=”classpath:.xml”) Spring5框架新功能SpringWebFluxSpring5新添加的模块，用于web开发的，功能SpringMVC类似的，WebFlux使用当前比较流程响应式编程出现的框架 传统web框架，例如SpringMVC，基于Servlet容器 WebFlux是一种异步非阻塞的框架，异步非阻塞的框架只在Servlet3.1以后才支持，核心是基于Reactor的相关API实现的 异步非阻塞异步与同步–调用者，调用者发送请求，对方回应后就去做其他事情–同步，不等待回应就去做其他事情–异步 非阻塞与阻塞–被调用者，被调用者收到请求之后，收到请求任务之后才给出反馈–阻塞，收到请求后马上给出反馈再去做其他事情–非阻塞 WebFlux特点非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以Reactor为基础实现响应式编程 函数式编程：Spring5框架基于Java8，webFlux使用Java8函数式编程方式实现路由请求 比较SpringMVC 都可以使用注解方式，运行在Tomcat等容器中 SpringMVC采用命令式编程，WebFlux采用异步响应式编程 响应式编程ReactiveProgramming响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。 Java8及其之前版本提供的观察者模式两个类Observer和Observable –伪响应式编程 Flow：Publisher、Subscriber 响应式编程Reactor实现 响应式编程操作中，满足Reactive规范框架 Mono和Flux两个类都实现了接口Publisher，提供丰富操作符 Flux对象实现发布者，返回N个元素 Mono实现发布者，返回0或1个元素 Flux和Mono都是数据流的发布者，使用Flux和Mono都可以发出三种数据信号元素值、错误信号、完成信号错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束错误信号终止数据流同时把错误信息传递给订阅者 代码演示引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;version&gt;3.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 三种信号特点 错误信号和完成信号都是终止信号，不能共存 如果没有发送任何元素值，而是直接发送错误信号或者完成信号，表示是空数据流 如果没有错误信号，没有完成信号，表示是无限数据流 调用just或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生的subscribe() 操作符对数据流进行一道道操作，称为操作符 map 元素映射为新元素 flatMap 元素映射为流把每个元素转换成流，把转换后的多个流合成更大的流 WebFlux执行流程和核心APISpringWebFlux基于Reactor，默认容器是Netty，Netty是高性能的NIO框架，异步非阻塞的框架 Netty BIO：Blocking I/O NIO：Non-Blocking I/O SpringWebFlux执行过程和SpringMVC相似SpringWebFlux核心控制器 DispatchHandler，实现接口WebHandler 123public interface WebHandler &#123; Mono&lt;Void&gt; handle(ServerWebExchange var1);&#125; SpringWebFlux里面DispatchHandler，负责请求的处理 HandlerMapping：请求查询到处理的方法 HandlerAdapter：真正负责请求处理 HandlerResultHandler：响应结果处理 SpringWebFlux实现函数式编程，两个接口：RouterFunction（路由处理）,HandlerFunction（处理函数） SpringWebFlux（基于注解编程模型）只需要把相关依赖配置到项目中，SpringBoot自动配置相关运行容器，默认情况下使用Netty容器 举例：SpringBoot 2.2.1.RELEASE 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt; 配置启动端口号 创建相关包和类service、controller 说明： SpringMVC方式实现，同步阻塞的方式，基于SpringMVC+Servlet+Tomcat SpringWebFlux方式实现，异步非阻塞方式，基于SpringWebFlux+Reactor+Netty SpringWebFlux（基于函数式编程模型） 在使用函数式编程模型操作时，需要自己初始化服务器 基于函数式编程模型，两个核心接口： RouterFunction：实现路由功能，请求转发给对应的handler HandlerFunction：处理请求生成响应的函数 核心任务定义两个函数式接口的实现并且启动需要的服务器 SpringWebFlux请求和响应不再是ServletRequest和ServletResponse，而是ServerRequest和ServerResponose 具体流程 配置项目 创建相关包和类service 创建Handler 初始化服务器，编写Router 创建服务器完成适配 普通调用或使用WebClient调用","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lao-biao.github.io/tags/spring/"}]},{"title":"Java--AOP编程","slug":"Java-AOP编程","date":"2020-06-04T07:44:45.000Z","updated":"2020-07-06T03:36:58.614Z","comments":true,"path":"articles/d97d56d4.html","link":"","permalink":"https://lao-biao.github.io/articles/d97d56d4.html","excerpt":"","text":"AOP编程AOP：Aspect Oriented Programming 面向切面编程 vs 面向对象编程 (Object Oriented Programming) 面向对象(OOP)：将需求功能划分为不同的、独立，封装良好的类，并让它们通过继承和多态实现相同和不同行为。 面向切面：将通用需求功能从众多类中分离出来，使得很多类共享一个 行为，一旦发生变化，不必修改很多类，而只需要修改这个行为即可 特点 分离代码的耦合(高内聚，低耦合) 业务逻辑变化不需要修改源代码/不用重启 加快编程和测试速度 AOP编程是一个概念/规范，没有限定语言 不是取代OOP编程，而是OOP的补充，和数据库的触发器有点相似 主要内容 Aspect ：配置文件，包括一些Pointcut和相应的Advice Joint point：在程序中明确定义的点，如方法调用、对类成员访问等 Pointcut：一组joint point, 可以通过逻辑关系/通配符/正则等组合起来，定义了相应advice将要发生的地方 Advice：定义了在pointcut处要发生的动作,通过before/after/around/来关联 weaving：advice代码在具体joint point的关联方式 Java的AOP实现 AspectJ(Eclipse)， https://www.eclipse.org/aspectj/ Spring AOP，https://spring.io/projects/spring-framework Spring AOP 与 AspectJ 比较：https://www.baeldung.com/spring-aop-vs-aspectj","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"aop","slug":"aop","permalink":"https://lao-biao.github.io/tags/aop/"}]},{"title":"Java--反射","slug":"Java-反射","date":"2020-05-31T14:01:42.000Z","updated":"2020-07-06T03:37:26.233Z","comments":true,"path":"articles/87b8a7bb.html","link":"","permalink":"https://lao-biao.github.io/articles/87b8a7bb.html","excerpt":"反射reflection 程序可以访问、检测和修改它本身状态或行为的能力，即自描述和自控制。 可以在运行时加载、探知和使用编译期间完全未知的类。 给Java插上动态语言特性的翅膀，弥补强类型语言的不足。 java.lang.reflect包，在Java 2就有，在Java 5得到完善 功能 在运行中分析类的能力 在运行中查看和操作对象 基于反射自由创建对象 反射构建出无法直接访问的类 set或者get到无法访问的成员变量 调用不可访问的方法 实现通用的数组操作代码 类似函数指针的功能","text":"反射reflection 程序可以访问、检测和修改它本身状态或行为的能力，即自描述和自控制。 可以在运行时加载、探知和使用编译期间完全未知的类。 给Java插上动态语言特性的翅膀，弥补强类型语言的不足。 java.lang.reflect包，在Java 2就有，在Java 5得到完善 功能 在运行中分析类的能力 在运行中查看和操作对象 基于反射自由创建对象 反射构建出无法直接访问的类 set或者get到无法访问的成员变量 调用不可访问的方法 实现通用的数组操作代码 类似函数指针的功能 五种创建对象的方式1.静态编码和编译12345public class A &#123; public void hello() &#123; System.out.println(\"Hello from A.\"); &#125;&#125; 直接new 调用构造函数 12A obj1 = new A();obj1.hello(); 2.克隆(clone) 123456789public class B implements Cloneable &#123; public void hello() &#123; System.out.println(\"Hello from B.\"); &#125; protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 使用克隆的方法创建对象 12345B obj2 =new B();obj2.hello();B obj3=(B) obj2.clone();obj3.hello(); 3.序列化(serialization)和反序列化(deserialization)123456public class C implements Serializable&#123; private static final long serialVersionUID=1L; // 序列化id public void hello()&#123; System.out.println(\"Hello from C.\"); &#125;&#125; 使用 transient 关键字可以使变量不被序列化 123456789C obj4 = new C();ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data.obj\"));out.writeObject(obj4);out.close();ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data.obj\"));C obj5 = (C) in.readObject();in.close();obj5.hello(); 注意：序列化会引发安全漏洞，未来将被移除出JDK 4.5.反射 第四种 通过Class.forName(String className).newInstance();动态获取实例 注意：className 需要加上包名，否则会报 java.lang.ClassNotFoundException 的异常 1234Object obj6 = Class.forName(\"com.reflection.A\").newInstance();// A obj7 = (A) Class.forName(\"A\").newInstance();Method m = Class.forName(\"com.reflection.A\").getMethod(\"hello\");m.invoke(obj6); 第五种 newInstance 调用构造函数 123Constructor&lt;A&gt; constructor = A.class.getConstructor();A obj8 = constructor.newInstance();obj8.hello(); 反射关键类Class：类型标识 JVM为每个对象都保留其类型标识信息(Runtime Type Identification) 三种获取方式 123456789String s1=\"abc\";Class c1=s1.getClass();System.out.println(c1.getName());Class c2=Class.forName(\"java.lang.String\");System.out.println(c2.getName());Class c3=String.class;System.out.println(c3.getName()); 成员变量、方法、构造函数、修饰符、包、父类、父接口… 成员变量 FieldgetFields() 获取本类及父类所有的public字段 getDeclaredFields() 获取本类所有声明的字段 成员方法 MethodgetMethods() 获取public方法，包括父类和父接口getDeclaredMethod() 获取该类所有的方法 构造函数 Constructor [Class.]getConstructors() 获取本类的所有构造函数 [Constructor.]newInstance(Object …args) 有参和无参构造函数 父类/父接口 [Class.]getSuperClass() 获取父类[Class.]getInterfaces() 获取父接口 反射的应用 数据库连接 数组扩充器 动态执行方法 Json和Java对象互转 Tomcat的Servlet对象创建 MyBatis的OR/M Spring的Bean容器 org.reflections包介绍 数据库连接JDBC：Connection，连接到不同数据库 12345678// 构建Java和数据库之间的桥梁介质try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); // Class.forName(className,true,currentLoader); // 通知类加载器加载此类的class文件&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 123// 构建Java和数库之间的桥梁：URL，用户名，密码Connection conn = DriverManager.getConnection(url, \"root\", \"123456\");// DriverManager将会挑选加载合适的驱动类，并采用getConnection()方法连接 数组扩充给定一个数组(任意类型)，扩充指定到长度 Java的数组一旦创建，其长度是不再更改的 新建一个大数组(相同类型)，然后将旧数组的内容拷贝过去 12345678910111213public static Object arrCopy(Object oldArray, int newLength) &#123; // Array类型 Class clazz = oldArray.getClass(); // 获取数组中的单个元素类型 Class componentType = clazz.getComponentType(); // 旧数组长度 int oldLength = Array.getLength(oldArray); // 创建新数组 Object newArray = Array.newInstance(componentType, newLength); // 拷贝旧数据 System.arraycopy(newArray, 0, oldArray, 0, oldLength); return newArray;&#125; 动态执行方法给定类名，方法名，即可执行 加上定时器，即可做定时任务执行 123456789101112131415class Work&#123; public static void hello()&#123; System.out.println(\"Hello World!\"); &#125;&#125;class MyTask extends TimerTask &#123; public void run()&#123; try&#123; Method m= Class.forName(packageName+\"Work\").getMethod(\"hello\"); m.invoke(null); // 静态方法可以不用new对象 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 123456Timer timer=new Timer();Calendar now=Calendar.getInstance();now.set(Calendar.SECOND,now.get(Calendar.SECOND)+1);Date runDate=now.getTime();MyTask task=new Task();timer.scheduleAtFixedRate(task,runDate,3000); Json和Java对象互转12345678Gson gson=new Gson();// json 字符串转bean对象String s; // 待转换的json字符串[Bean] json=gson.fromJson(s,[Bean.class]);// json bean对象转字符串Bean bean;String t=gson.toJson(bean,[Bean.class]); Tomcat的Servlet创建详见源码 MyBatis的OR/MMyBatis: OR/M(Object-Relation Mapping)数据库表和Java的POJO/DAO类对应关系 Spring Framework的Bean容器Spring Framework: Java EE的主要框架IoC 的Bean容器(HashMap) org.reflectionsReflection的增强工具包 https://github.com/ronmamo/reflections Java runtime metadata analysis Java运行时元数据分析 获取某类的所有子类型 获取有特殊annotation的类型或者成员变量/方法 根据正则表达式获取资源(类/成员变量/方法) 根据组合条件查询相应的方法 编译器API反射 可以查看对象的类型标识 可以动态创建对象、访问其属性，调用其方法 前提：类(class文件)必须先存在 编译器API 对.java文件即时编译 对字符串即时编译 监听在编译过程中产生的警告和错误 在代码中运行编译器(并非：Runtime命令行调用javac命令) JavaCompiler 自Java 1.6 推出，位于javax.tools包中。 可用在程序文件中的Java编译器接口(代替javac.exe)。 在程序中编译java文件，产生class文件。 run方法(继承自java.tools.Tools)：可以编译java源文件，生成class文件，但不能指定输出路径,监控错误信息, 调用后就在源码所在目录生成class文件。 getTask方法：可以编译java源文件，包括在内存中的java文件(字符串)，生成class文件。 Java编译器API作用 Java EE的JSP编译 在线编程环境 在线程序评判系统(Online Judge系统) 自动化的构建和测试工具 基于JavaCompiler的集成工具 Janino，http://janino-compiler.github.io/janino InMemoryJavaCompile， https://github.com/trung/InMemoryJavaCompiler Java-Runtime-Compiler, https://github.com/OpenHFT/JavaRuntime-Compiler Apache Commons JCI(Java Compiler Interface), http://commons.apache.org/proper/commons-jci/index.html，适用于JDK1.5及以前的版本","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://lao-biao.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java--泛型","slug":"Java-泛型","date":"2020-05-29T11:38:50.000Z","updated":"2020-07-06T03:37:32.491Z","comments":true,"path":"articles/8b379c6c.html","link":"","permalink":"https://lao-biao.github.io/articles/8b379c6c.html","excerpt":"泛型引入集合：存放多个不同类型对象，容易出现转型错误 ClassCastException 泛型：Generic Programming JDK1.5推出的特性 编写的代码可以被很多不同类型的对象所重用 List &lt;String&gt; list = new ArrayList&lt;String&gt;(); List &lt;String&gt; list = new ArrayList&lt;&gt;();Java 7菱形语法 泛型类：ArrayList，HashSet，HashMap等 泛型方法：Collections.binarySearch()，Arrays.sort()等 泛型接口：List，Iterator等 泛型的本质：参数化类型，避免类型转换，代码可复用 同类： C++的模板(Template) C#的泛型 ArrayList源码 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 12345public E get(int index) &#123; rangeCheck(index); //检查是否越界 return elementData(index); //返回对应的元素值&#125;","text":"泛型引入集合：存放多个不同类型对象，容易出现转型错误 ClassCastException 泛型：Generic Programming JDK1.5推出的特性 编写的代码可以被很多不同类型的对象所重用 List &lt;String&gt; list = new ArrayList&lt;String&gt;(); List &lt;String&gt; list = new ArrayList&lt;&gt;();Java 7菱形语法 泛型类：ArrayList，HashSet，HashMap等 泛型方法：Collections.binarySearch()，Arrays.sort()等 泛型接口：List，Iterator等 泛型的本质：参数化类型，避免类型转换，代码可复用 同类： C++的模板(Template) C#的泛型 ArrayList源码 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 12345public E get(int index) &#123; rangeCheck(index); //检查是否越界 return elementData(index); //返回对应的元素值&#125; 自定义泛型设计泛型类 具有泛型变量的类 在类名后用代表引入类型 多个字母表示多个引入类型如&lt;T,U&gt;等 引入类型可以修饰成员变量 /局部变量/参数/返回值 没有专门的template关键字 12345678910111213public class Interval&lt;T&gt; &#123; private T lower; private T upper; public Interval(T lower, T upper) &#123; this.lower = lower; this.upper = upper; &#125; public T getLower() &#123; return this.lower; &#125;&#125; 泛型类调用 传入具体的类 12Interval&lt;Integer\\&gt; v1 = new Interval&lt;Integer\\&gt;(1,2); Interval&lt;Integer\\&gt; v1 = new Interval&lt;\\&gt;(1,2); 泛型方法 具有泛型参数的方法 该方法可在普通类/泛型类中 &lt;T&gt;在修饰符后，返回类型前 12345public class ArrayUtils &#123; public static &lt;T&gt; T getMiddle(T... a) &#123; return a == null ? null : a[a.length / 2]; &#125;&#125; 泛型接口 和泛型类相似，在类名后加&lt;T&gt; T用来指定方法返回值和参数 实现接口时，指定类型 T也可以再是一个泛型类，可嵌套 123public interface Calculator&lt;T&gt; &#123; public T add(T t1, T t2);&#125; 总结 泛型类：整个类都被泛化，包括变量和方法 泛型方法：方法被泛化，包括返回值和参数 泛型接口：泛化子类方法 泛型类型限定泛型 编写的代码可以被很多不同类型的对象所重用 特定场合下，需要对类型进行限定(使用某些特定方法) 泛型限定 &lt;T extends Comparable&gt;约定T必须是Comparable的子类 extends固定，后面可以多个，以&amp;拼接，如&lt;T extends Comparable &amp; Serializable&gt; extends限定可以有多个接口，但只能一个类，且类必须排第一位 –逗号隔参数，如&lt;T extends File &amp;Cloneable, U extends Serializable&gt; 泛型类之间的继承 Pair&lt;S&gt;和Pair&lt;T&gt;没有任何关系，无论S和T之间是什么关系 泛型类可以扩展或实现其他的类，如ArrayList&lt;T&gt; implemetsList&lt;T&gt; 上限界定符 Pair&lt;? extends S&gt; Pair能接收的参数类型，是S自身或子类 eg Pair&lt;? extends Fruit&gt;代表Pair&lt;Fruit&gt;, Pair&lt;Apple&gt;, Pair&lt;ornage&gt; 等 Apple extends FruitOrange extends Fruit 只能get/不能set，编译器只能保证出来的类型，但不保证放入的 对象是什么类型 ? extends Fruit getFirst(); //肯定可以转型到Fruit void setFirst(? extend Fruit) //未知具体的类型[错误] 下限界定符 Pair&lt;？super S&gt; Pair能接收的类型参数，是S的自身或超类 eg Pair&lt;? super Apple&gt; 代表 Pair&lt;Object&gt;,Pair&lt;Fruit&gt;,Pair&lt;Apple&gt;等 只能set/不能get，编译器保证放入的是S本身或超类，但不保证 出来是什么具体类型 void setFirst(? super Apple) //可以放入Apple及子类对象 ? super Apple getFirst() //无法得知出来的对象类型，只能是Object 泛型PECS原则 Producer Extends, Consumer Super 要从泛型类读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends，泛型类是生产者，往外输出 东西) 如果要向泛型类写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super，泛型类是消费者，往内增加东西) 如果既想写入又想读出，那就不用通配符 无限定类型的泛型 Pair&lt;T&gt;，原始类型 Pair&lt;?&gt; ，无限定通配符，表示任意类型 如Pair&lt;Obejct&gt;, Pair&lt;Apple&gt;, Pair&lt;Orange&gt; ? getFirst() //不确定出来是什么类型，只能赋值给Object void setFirst() //无法放入任何对象，甚至是Object 泛型实现的本质和约束JDK的版本是向后兼容的:即低版本的class文件可以在高版本的JDK上运行因此，JVM里面没有泛型对象，而是采用类型擦除技术， 只有普通的类和方法 类型擦除 擦除泛型变量，替换为原始类型(raw type)，无限定为Object 擦除泛型变量，替换为原始类型(raw type)，有限定则为第 一个类型 擦除泛型变量后，为了保证类型的安全性，需要自动进行类型转换 泛型表达式翻译 Fruit f=fruits.getFirst();Object o=fruits.getFirst(); Fruit f=(Fruit) o; 擦除泛型变量后，为了保证类型的安全性，需要自动进行 类型转换 重载泛型方法翻译(自动桥方法) 泛型的约束 不能用基本类型(8种)来实例化泛型 运行时类型查询只适用于原始类型 不能创建参数化类型的数组 可变参数警告 不能实例化类型变量 不能构造泛型数组 泛型类的静态上下文中类型变量无效 不能抛出或捕获泛型类的异常实例 可以消除对受查异常(checked exception)的检查 类型擦除后引发的方法冲突 Java类型协变和逆变面向对象语言，支持子类型(Subtyping) 类型变化关系(type variance) 更复杂类型中的子类型关系，与子类型之间的关系相关联。 Type Variance形式化定义: A、B是类型，f(·)表示类型转换，≤表示继承关系，如A ≤ B， 表示A继承于B f(·)是协变(covariant)的，如果A ≤ B，有f(A) ≤f(B) f(·)是逆变(contravariant)的，如果A ≤ B，有f(B) ≤f(A) f(·)是不变(invariant)的，当上述两种都不成立，即f(A)和f(B)没有关系 f(·)是双变(bivariant)的，如果A ≤ B，有f(B) ≤f(A) 和f(A) ≤f(B) 同时成立 Java数组是协变的 String是Object的子类，String[]是Object[]的子类 Java的(原始的)泛型是不变的 String是Object的子类，List&lt;String&gt;和List&lt;Object&gt;没有关系 泛型可采用通配符，支持协变和逆变(PECS原则) 假设 B是A的子类 ArrayList&lt;? extends A&gt; list3 = new ArrayList&lt;B&gt;(); 协变ArrayList&lt;? super B&gt; list4 = new ArrayList&lt;A&gt;(); 逆变 复合情况：数组协变，泛型不变 假设 B是A的子类，C是B的子类 1234567891011public static void testArrayAndList()&#123; B[] r1=test(new ArrayList&lt;B&gt;(); // 编译错误 A[] r2=test(new ArrayList&lt;B&gt;(); // 编译错误 Object[] r3=test(new ArrayList&lt;Object&gt;()); // 编译错误 A[] r4=test(new ArrayList&lt;A&gt;()); Object[] r5=test(new ArrayList&lt;A&gt;()); &#125;public static A[] test(ArratList&lt;A&gt; list)&#123; return new A[1];&#125; 方法情况 JDK 1.4 重写的方法参数和返回值要求一样 JDK 1.5 +重写的方法，参数要求一样的，返回值是协变的 12345678910111213141516class Father&#123; public B f1(B obj)&#123; System.out.println(\"Father.f1()\"); return new B(); &#125;&#125;class Son extends Father&#123; public B f1(B obj)&#123; //public C f1(B obj)&#123;&#125; 返回值是C，也是对的 System.out.println(\"Son.f1()\"); return new C(); &#125;&#125;// 调用Father foo=new Son();foo.f1(new B()); 总结Java类型变化(type variance) 数组是协变的(covariant) 原始的泛型是不变的(invariant) &lt;? extends A&gt;支持协变(covariant) &lt;? super B&gt;支持逆变(contravariant)","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"https://lao-biao.github.io/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"Java--混合编程","slug":"Java-混合编程","date":"2020-05-26T02:45:45.000Z","updated":"2020-07-06T03:37:38.359Z","comments":true,"path":"articles/6d00d2a2.html","link":"","permalink":"https://lao-biao.github.io/articles/6d00d2a2.html","excerpt":"","text":"Java混合编程Java调用Java程序RMI Java调用C程序JNI Java Native Interface Java调用JavaScript程序脚本引擎 Script Engine JDK8：Nashorn JDK6/7：Rhino Java调用Python程序Jython（JPython） 关键类 PythonInterpreter exec 执行语句 set 设置变量值 get 获取变量值 execfile 执行一个python文件 PyObjectPyFunction Java调用Web Servicewsimport Java调用命令行Runtime类 Process类","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"混合编程","slug":"混合编程","permalink":"https://lao-biao.github.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}]},{"title":"Java--并发编程","slug":"Java-并发编程","date":"2020-05-24T04:01:52.000Z","updated":"2020-07-06T03:37:14.608Z","comments":true,"path":"articles/f0f7baf0.html","link":"","permalink":"https://lao-biao.github.io/articles/f0f7baf0.html","excerpt":"Java并发编程串行 vs 并行业务：任务多，数据量大 串行 编程简单，并行编程困难 单个计算核频率下降，计算核数增多，整体性能变高 并行困难(任务分配和执行过程高度耦合) 如何控制粒度，切割任务 如何分配任务给线程，监督线程执行过程 并行模式 主从模式 (Master-Slave) Worker模式(Worker-Worker) Java并发编程 Thread/Runnable/Thread组管理 Executor框架 Fork-Join框架","text":"Java并发编程串行 vs 并行业务：任务多，数据量大 串行 编程简单，并行编程困难 单个计算核频率下降，计算核数增多，整体性能变高 并行困难(任务分配和执行过程高度耦合) 如何控制粒度，切割任务 如何分配任务给线程，监督线程执行过程 并行模式 主从模式 (Master-Slave) Worker模式(Worker-Worker) Java并发编程 Thread/Runnable/Thread组管理 Executor框架 Fork-Join框架 线程组ThreadGroup 线程的集合 树形结构，大线程组可以包括小线程组 可以通过enumerate方法遍历组内的线程，执行操作 能够有效管理多个线程，但是管理效率低 任务分配和执行过程高度耦合 重复创建线程、关闭线程操作，无法重用线程 Main类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 使用线程组管理多个线程 */public class ThreadGroupStudy &#123; public static void main(String[] args) &#123; //创建线程组 ThreadGroup threadGroup = new ThreadGroup(\"Search\"); Result result = new Result(); //创建线程任务 Searcher searchTask = new Searcher(result); for (int i = 0; i &lt; 10; i++) &#123; //以searchTask为模板创建线程 Thread thread = new Thread(threadGroup, searchTask); thread.start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"----------分割线----------\"); //查看线程组消息 System.out.printf(\"active count:%d\\n\", threadGroup.activeCount()); System.out.println(\"线程组信息明细\"); //打印线程组的所有信息 threadGroup.list(); System.out.println(\"----------分割线----------\"); //遍历线程组 Thread[] threads = new Thread[threadGroup.activeCount()]; //将线程组中active线程拷贝到数组中 threadGroup.enumerate(threads); for (int i = 0; i &lt; threadGroup.activeCount(); i++) &#123; System.out.printf(\"Thread %s: %s\\n\", threads[i].getName(), threads[i].getState()); &#125; System.out.println(\"----------分割线----------\"); //等待活动线程数小于10 waitFinish(threadGroup); //线程组发出中断命令 threadGroup.interrupt(); &#125; public static void waitFinish(ThreadGroup threadGroup) &#123; while (threadGroup.activeCount()&gt;9)&#123; try&#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 线程模板1234567891011121314151617181920212223242526272829public class Searcher implements Runnable &#123; private Result result; public Searcher(Result result) &#123; this.result = result; &#125; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); System.out.printf(\"Thread %s start\\n\", threadName); try &#123; doTask(); result.setName(threadName); &#125; catch (InterruptedException e) &#123; System.out.printf(\"Thread %s is interrupted\\n\", threadName); return; &#125; System.out.printf(\"Thread %s finished.\\n\", threadName); &#125; private void doTask() throws InterruptedException &#123; Random random = new Random(new Date().getTime()); int value = (int) (random.nextDouble() * 100); System.out.printf(\"Thread %s : %d\\n\", Thread.currentThread().getName(), value); TimeUnit.SECONDS.sleep(value); &#125;&#125; Bean类1234567891011public class Result &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 输出 输出 Thread Thread-0 startThread Thread-0 : 6Thread Thread-1 startThread Thread-1 : 4Thread Thread-2 startThread Thread-2 : 32Thread Thread-3 startThread Thread-3 : 23Thread Thread-4 startThread Thread-4 : 51Thread Thread-1 finished.Thread Thread-5 startThread Thread-5 : 42Thread Thread-6 startThread Thread-6 : 21Thread Thread-0 finished.Thread Thread-7 startThread Thread-7 : 12Thread Thread-8 startThread Thread-8 : 39Thread Thread-9 startThread Thread-9 : 30———-分割线———-active count:8线程组信息明细java.lang.ThreadGroup[name=Search,maxpri=10] Thread[Thread-2,5,Search] Thread[Thread-3,5,Search] Thread[Thread-4,5,Search] Thread[Thread-5,5,Search] Thread[Thread-6,5,Search] Thread[Thread-7,5,Search] Thread[Thread-8,5,Search] Thread[Thread-9,5,Search]———-分割线———-Thread Thread-2: TIMED_WAITINGThread Thread-3: TIMED_WAITINGThread Thread-4: TIMED_WAITINGThread Thread-5: TIMED_WAITINGThread Thread-6: TIMED_WAITINGThread Thread-7: TIMED_WAITINGThread Thread-8: TIMED_WAITINGThread Thread-9: TIMED_WAITING———-分割线———-Thread Thread-3 is interruptedThread Thread-5 is interruptedThread Thread-8 is interruptedThread Thread-6 is interruptedThread Thread-7 is interruptedThread Thread-4 is interruptedThread Thread-9 is interruptedThread Thread-2 is interrupted Process finished with exit code 0 Java并发框架Executor从JDK 5开始提供Executor FrameWork (==java.util.concurrent.*==) 分离任务的创建和执行者的创建 线程重复利用(new线程代价很大) 理解共享线程池的概念 预设好的多个Thread，可弹性增加 多次执行很多很小的任务 任务创建和执行过程解耦 程序员无需关心线程池执行任务过程 主要类：Executor Service, ThreadPoolExecutor，Future Executors.newCachedThreadPoolExecutors.newFixedThreadPool(指定线程数，一般为CPU核数的2/4倍) 创建线程池 Executor Service 线程池服务 Callable 具体的逻辑对象(线程类)，类似于Runnable接口，有返回值 Future 返回结果 Server实例代码 Main类 通过服务器调用100个任务 Server类 线程池管理 Task类 线程具体任务实现 12345678910111213public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; //创建一个服务器 Server server = new Server(); //创建100个任务，并发交给执行器，等待完成 for (int i = 0; i &lt; 100; i++) &#123; Task task = new Task(\"Task\" + i); Thread.sleep(10); server.submitTask(task); // 提交任务 &#125; server.endServer(); // 关闭服务器 &#125;&#125; 123456789101112131415161718192021222324252627public class Server &#123; //线程池 private ThreadPoolExecutor executor; public Server() &#123; //创建默认的线程池 executor = (ThreadPoolExecutor) Executors.newCachedThreadPool(); //创建指定个数的线程池 //executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(5); &#125; public void submitTask(Task task) &#123; System.out.print(\"Sever: A new task is arrived.\\n\"); //执行task executor.execute(task); System.out.printf(\"Server: Pool size is %d\\n\", executor.getPoolSize()); System.out.printf(\"Server: Active count is %d\\n\", executor.getActiveCount()); System.out.printf(\"Server: Completed task is %d\\n\", executor.getCompletedTaskCount()); &#125; public void endServer() &#123; //结束服务 executor.shutdown(); &#125;&#125; 1234567891011121314151617181920public class Task implements Runnable &#123; private String name; public Task(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; long duration = (long) (Math.random() * 1000); System.out.printf(\"Thread %s:doing a task during %d seconds\\n\", Thread.currentThread().getName(), duration); Thread.sleep(duration); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.printf(\"Thread %s is finished on %s.\\n\", Thread.currentThread().getName(), new Date()); &#125;&#125; Callable+Future回调结果实例 SumTest类 实现多线程运行1-1000的求和 SumTask类 每个线程的具体任务实现，并通过Callable回调结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SumTest &#123; public static void main(String[] args) &#123; // 执行线程池 ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(4); List&lt;Future&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;(); // 统计1-1000总和，分成10个任务计算，提交任务 for (int i = 0; i &lt; 10; i++) &#123; SumTask calculator = new SumTask(i * 100 + 1, (i + 1) * 100); Future&lt;Integer&gt; result = executor.submit(calculator); // 接收任务回调 resultList.add(result); &#125; // 每隔50ms，轮询等待10个任务结束 do &#123; System.out.printf(\"Main:已经完成%d个任务\\n\", executor.getCompletedTaskCount()); for (int i = 0; i &lt; resultList.size(); i++) &#123; Future&lt;Integer&gt; result = resultList.get(i); System.out.printf(\"Main:Task %d : %s\\n\", i, result.isDone()); &#125; try &#123; Thread.sleep(50); // 休眠50ms &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; while (executor.getCompletedTaskCount() &lt; resultList.size()); // 在所有任务结束，综合计算结果 int total = 0; for (Future&lt;Integer&gt; result : resultList) &#123; Integer sum = null; try &#123; sum = result.get(); total += sum; &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; // 输出最终结果 System.out.println(\"1-1000的总和：\"+total); // 关闭线程池 executor.shutdown(); &#125;&#125; 123456789101112131415161718192021222324public class SumTask implements Callable&lt;Integer&gt; &#123; // 定义每个线程计算的区间 private int startNumber; private int endNumber; public SumTask(int startNumber, int endNumber) &#123; this.startNumber = startNumber; this.endNumber = endNumber; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = startNumber; i &lt;=endNumber; i++) &#123; sum += i; &#125; Thread.sleep(new Random().nextInt(1000)); // 休眠一段时间 System.out.printf(\"%s:%d\\n\", Thread.currentThread().getName(), sum); return sum; &#125;&#125; Java并发框架Fork-Join Java 7 提供的一种并行框架：分解、治理、合并(分治编程) 适合用于整体任务量不好确定的场合(最小任务可确定) 关键类 ForkJoinPool 任务池 RecursiveAction RecursiveTask 使用Fork-Join框架执行1-10000000的求和 SumTest类 线程池管理线程 SumTask类 线程任务分解、治理、合并 123456789101112131415161718192021222324252627public class SumTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 创建执行线程池 ForkJoinPool pool = new ForkJoinPool(); //ForkJoinPool pool = new ForkJoinPool(4); // 创建任务 SumTask task = new SumTask(1, 10000000); // 提交任务 ForkJoinTask&lt;Long&gt; result = pool.submit(task); // 等待结果,每隔50ms检查一次 do &#123; System.out.println(\"Main:Active Thread Count--&gt;\" + pool.getActiveThreadCount()); System.out.println(\"Main:Parallelism--&gt;\" + pool.getParallelism()); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; while (!task.isDone()); // 输出结果 System.out.println(result.get().toString()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class SumTask extends RecursiveTask&lt;Long&gt; &#123; private int start; private int end; public static final int threadHold = 5; // 求和最小个数 public SumTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; Long sum = 0L; // 如果任务足够小就直接执行 boolean canCompute = (end - start) &lt;= threadHold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 任务大于阀值，分为2个任务 int middle = start + (end - start) / 2; SumTask sumTaskLeft = new SumTask(start, middle); SumTask sumTaskRight = new SumTask(middle + 1, end); invokeAll(sumTaskLeft, sumTaskRight); Long sumLeft = sumTaskLeft.join(); Long sumRight = sumTaskRight.join(); // 合并结果 sum = sumLeft + sumRight; &#125; return sum; &#125;&#125; Java并发数据结构常用的数据结构是线程不安全的 ArrayList, HashMap, HashSet 非同步的 多个线程同时读写，可能会抛出异常或数据错误 传统Vector，Hashtable等同步集合性能过差 并发数据结构：数据添加和删除 阻塞式集合：当集合为空或者满时，等待 非阻塞式集合：当集合为空或者满时，不等待，返回null或异常 常用数据结构List Vector 同步安全，写多读少 ArrayList 不安全 Collections.synchronizedList(List list) 基于synchronized，效率差 CopyOnWriteArrayList 读多写少，基于复制机制，非阻塞 Set HashSet 不安全 Collections.synchronizedSet(Set set) 基于synchronized，效率差 CopyOnWriteArraySet (基于CopyOnWriteArrayList实现) 读多写少， 非阻塞 Map Hashtable 同步安全，写多读少 HashMap 不安全 Collections.synchronizedMap(Map map) 基于synchronized，效率差 ConcurrentHashMap 读多写少，非阻塞 Queue &amp; Deque (JDK 1.5 提出) ConcurrentLinkedQueue 非阻塞 ArrayBlockingQueue/LinkedBlockingQueue 阻塞 Java并发协作控制Thread/Executor/Fork-Join 线程启动，运行，结束 线程之间缺少协作 synchronized 同步 限定只有一个线程才能进入关键区 简单粗暴，性能损失有点大 LockLock也可以实现同步的效果 实现更复杂的临界区结构 tryLock方法可以预判锁是否空闲 允许分离读写的操作，多个读，一个写 性能更好 ReentrantLock类，可重入的互斥锁 ReentrantReadWriteLock类，可重入的读写锁 lock和unlock函数 Semaphore信号量，由1965年Dijkstra提出的 信号量：本质上是一个计数器 计数器大于0，可以使用，等于0不能使用 可以设置多个并发量，例如限制10个访问 Semaphore acquire获取 release释放 比Lock更进一步，可以控制多个同时访问关键区 SemaphoreExample123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SemaphoreExample &#123; // 信号量，车位数为5 private final Semaphore placeSemaphore = new Semaphore(5); /** * 5个车位，10辆车需要停放，每次停放时，去申请信号量 * * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; int tryToParkCnt = 10; SemaphoreExample semaphoreExample = new SemaphoreExample(); Thread[] parker = new Thread[tryToParkCnt]; for (int i = 0; i &lt; tryToParkCnt; i++) &#123; parker[i] = new Thread(() -&gt; &#123; try &#123; long randomTime = (long) (Math.random() * 1000); Thread.sleep(randomTime); if (semaphoreExample.parking()) &#123; long parkingTime = (long) (Math.random() * 1200); Thread.sleep(parkingTime); semaphoreExample.leaving(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); parker[i].start(); &#125; for (int i = 0; i &lt; tryToParkCnt; i++) &#123; parker[i].join(); &#125; &#125; public boolean parking() &#123; if (placeSemaphore.tryAcquire()) &#123; System.out.println(Thread.currentThread().getName() + \":停车成功\"); return true; &#125; else &#123; System.out.println(Thread.currentThread().getName() + \":没有空位\"); return false; &#125; &#125; public void leaving() &#123; placeSemaphore.release(); System.out.println(Thread.currentThread().getName() + \":离开\"); &#125;&#125; Latch等待锁，是一个同步辅助类 用来同步执行任务的一个或者多个线程 不是用来保护临界区或者共享资源 CountDownLatch countDown() 计数减1 await() 等待latch变成0 Barrie集合点，也是一个同步辅助类 允许多个线程在某一个点上进行同步 CyclicBarrier 构造函数是需要同步的线程数量 await等待其他线程，到达数量后，就放行 CyclicBarrierExample1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class CyclicBarrierExample &#123; /** * 三个一维向量用三个线程分别求和，最后计算总和 * * @param args */ public static void main(String[] args) &#123; final int[][] numbers = new int[3][5]; final int[] results = new int[3]; int[] row1 = &#123;1, 2, 3, 4, 5&#125;; int[] row2 = &#123;6, 7, 8, 9, 10&#125;; int[] row3 = &#123;11, 12, 13, 14, 15&#125;; numbers[0] = row1; numbers[1] = row2; numbers[2] = row3; CalculateFinalResult finalResultCalculator = new CalculateFinalResult(results); CyclicBarrier barrier = new CyclicBarrier(3, finalResultCalculator); // 当有3个线程在barrier上await时，就执行finalResultCalculator for (int i = 0; i &lt; 3; i++) &#123; CalculateEachRow rowCalculator = new CalculateEachRow(numbers, i, results, barrier); new Thread(rowCalculator).start(); &#125; &#125;&#125;class CalculateEachRow implements Runnable &#123; final int[][] numbers; final int rowNumbers; final int[] res; final CyclicBarrier barrier; public CalculateEachRow(int[][] numbers, int rowNumbers, int[] res, CyclicBarrier barrier) &#123; this.numbers = numbers; this.rowNumbers = rowNumbers; this.res = res; this.barrier = barrier; &#125; @Override public void run() &#123; int[] row = numbers[rowNumbers]; int sum = 0; for (int datum : row) &#123; sum += datum; res[rowNumbers] = sum; &#125; try &#123; System.out.println(Thread.currentThread().getName() + \":计算第\" + (rowNumbers + 1) + \"行结束，结果为--&gt;\" + sum); barrier.await(); // 等待，只要超过3个，就放行 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class CalculateFinalResult implements Runnable &#123; final int[] eachRowRes; int finalRes; public CalculateFinalResult(int[] eachRowRes) &#123; this.eachRowRes = eachRowRes; &#125; public int getFinalRes() &#123; return finalRes; &#125; @Override public void run() &#123; int sum = 0; for (int datum : eachRowRes) &#123; sum += datum; &#125; finalRes = sum; System.out.println(\"最终结果为--&gt;\" + finalRes); &#125;&#125; Phaser允许执行并发多阶段任务，同步辅助类 在每一个阶段结束的位置对线程进行同步，当所有的线程都到达这步，再进行下一步 Phaser arrive() arriveAndAwaitAdvance() 等待 Exchanger允许在并发线程中互相交换消息 允许在2个线程中定义同步点，当两个线程都到达同步点， 它们交换数据结构 Exchanger exchange(), 线程双方互相交互数据 交换数据是双向的，传递null时不需要接受 Java定时任务执行Thread/Executor/Fork-Join 多线程 立刻执行 框架调度 定时执行 固定某一个时间点运行 以某一个周期执行 简单定时器机制设置计划任务，也就是在指定的时间开始执行某一个任务 TimerTask 封装任务 实现Runable接口 Timer类 定时器 scheduleAtFixedRate(TimerTask timerTask,Date firstTime,long period) 固定速率 cancel() 取消定时器 Executor +定时器机制ScheduledExecutorService 定时任务 schedule(Runable command,long delay,TimeUnit unit) 周期任务 scheduleAtFixedRate(Runable command,long initialDelay，long period,TimeUnit unit) 固定速率 以上一个任务开始的时间计时 scheduleWithFixedDelay(Runable command,long initialDelay,long delay,TimeUnit unit) shutdown() 结束 Quartz（第三方库）Quartz是一个较为完善的任务调度框架 trigger 触发器 job 任务 解决程序中Timer零散管理的问题 功能更加强大 Timer执行周期任务，如果中间某一次有异常，整个任务终止执行 Quartz执行周期任务，如果中间某一次有异常，不影响下次任务执行","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://lao-biao.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"国内镜像网站网址","slug":"国内镜像网站网址","date":"2020-05-15T14:43:13.000Z","updated":"2020-07-06T03:25:00.879Z","comments":true,"path":"articles/2e851ff5.html","link":"","permalink":"https://lao-biao.github.io/articles/2e851ff5.html","excerpt":"","text":"国内镜像网站： 中科大镜像站（地址：安徽）：http://mirrors.ustc.edu.cn清华大学镜像站：https://mirrors.tuna.tsinghua.edu.cn浙江大学镜像站：http://mirrors.zju.edu.cn重庆大学镜像站：http://mirrors.cqu.edu.cn兰州大学镜像站：http://mirror.lzu.edu.cn","categories":[],"tags":[]},{"title":"Java--多线程","slug":"Java-多线程","date":"2020-05-15T14:33:51.000Z","updated":"2020-07-06T03:37:20.452Z","comments":true,"path":"articles/83776954.html","link":"","permalink":"https://lao-biao.github.io/articles/83776954.html","excerpt":"多进程与多线程多进程当前的操作系统都是多任务OS ，每个独立执行的任务就是一个进程，OS将时间划分为多个时间片（时间很短） 每个时间片内将CPU分配给某一个任务，时间片结束，CPU将自动回收，再分配给另外任务。从外部看，所有任务是同时在执行。但是在CPU上，任务是按照串行依次运行（单核CPU）。如果是多核，多个进程任务可以并行。但是单个核上，多进程只能串行执行。 多进程的优点 可以同时运行多个任务 程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务 当系统有多个CPU时，可以为多个程序同时服务 CPU不再提高频率，而是提高核数 多核和并行程序才是提高程序性能的唯一办法 多进程的缺点：太笨重，不好管理，不好切换 多线程一个程序可以包括多个子任务，可串/并行，每个子任务可以称为一个线程 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作。这样CPU还是保留在本程序中，而不是被调度到别的程序(进程)去。这样，提高本程序所获得CPU时间和利用率。 多进程 vs 多线程 线程共享数据 线程通讯更高效 线程更轻量级，更容易切换 多个线程更容易管理","text":"多进程与多线程多进程当前的操作系统都是多任务OS ，每个独立执行的任务就是一个进程，OS将时间划分为多个时间片（时间很短） 每个时间片内将CPU分配给某一个任务，时间片结束，CPU将自动回收，再分配给另外任务。从外部看，所有任务是同时在执行。但是在CPU上，任务是按照串行依次运行（单核CPU）。如果是多核，多个进程任务可以并行。但是单个核上，多进程只能串行执行。 多进程的优点 可以同时运行多个任务 程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务 当系统有多个CPU时，可以为多个程序同时服务 CPU不再提高频率，而是提高核数 多核和并行程序才是提高程序性能的唯一办法 多进程的缺点：太笨重，不好管理，不好切换 多线程一个程序可以包括多个子任务，可串/并行，每个子任务可以称为一个线程 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作。这样CPU还是保留在本程序中，而不是被调度到别的程序(进程)去。这样，提高本程序所获得CPU时间和利用率。 多进程 vs 多线程 线程共享数据 线程通讯更高效 线程更轻量级，更容易切换 多个线程更容易管理 Java多线程实现多线程创建 java.lang.Thread 线程继承Thread类，实现run方法 java.lang.Runnable接口 线程实现Runnable接口，实现run方法 多线程启动 start方法，会自动以新进程调用run方法 直接调用run方法，将变成串行执行 同一个线程，多次start会报错，只执行第一次start方法 多个线程启动，其启动的先后顺序是随机的 线程无需关闭，只要其run方法执行结束后，自动关闭 main函数(线程)可能早于新线程结束，整个程序并不终止 整个程序终止是等所有的线程都终止(包括main函数线程) 多线程实现对比 Thread占据了父类的名额，不如Runnable方便 Thread 类实现Runnable Runnable启动时需要Thread类的支持 Runnable 更容易实现多线程中资源共享 结论：建议实现Runnable接口来完成多线程 Java多线程信息共享线程类 通过继承Thread或实现Runnable 通过start方法，调用run方法， run方法工作 线程run结束后，线程退出 粗粒度：子线程与子线程之间、和main线程之间缺乏交流 细粒度：线程之间有信息交流通讯 通过共享变量达到信息共享 JDK原生库暂不支持发送消息(类似MPI并行库直接发送消息) 信息共享通过共享变量在多个线程中共享消息 static变量 同一个Runnable类的成员变量 多线程信息共享问题 工作缓存副本 关键步骤缺乏加锁限制 举例：i++，并非原子性操作 读取主存i (正本)到工作缓存(副本)中 每个CPU执行(副本)i+1操作 CPU将结果写入到缓存(副本)中 数据从工作缓存(副本)刷到主存(正本)中 变量副本问题的解决方法 采用volatile 关键字修饰变量 保证不同线程对共享变量操作时的可见性 关键步骤加锁限制 互斥：某一个线程运行一个代码段(关键区)，其他线程不能同时 运行这个代码段 同步：多个线程的运行，必须按照某一种规定的先后顺序来运行 互斥是同步的一种特例 互斥的关键字是synchronized synchronized代码块/函数，只能一个线程进入 synchronized加大性能负担，但是使用简便 Java多线程管理线程类 通过继承Thread或实现Runnable 通过start方法，调用run方法，run方法工作 线程run结束后，线程退出 粗粒度：子线程与子线程之间、和main线程之间缺乏同步 细粒度：线程之间有同步协作 等待 通知/唤醒 终止 线程状态 NEW 刚创建(new) RUNNABLE 就绪态(start) RUNNING 运行中(run) BLOCK 阻塞(sleep) TERMINATED 结束 Thread APIThread的部分API已经废弃（不建议再使用） 暂停和恢复 suspend/resume 消亡 stop/destroy 线程阻塞/和唤醒 sleep，时间一到，自己会醒来 wait/notify/notifyAll，等待，需要别人来唤醒 join，等待另外一个线程结束 interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发InterruptedException(可解除阻塞)，并进行下一步处理 线程暂停和中止–主动与被动线程被动地暂停和终止 依靠别的线程来拯救自己 wait notify notifyAll 没有及时释放资源 线程主动暂停和终止 定期监测共享变量 如果需要暂停或者终止，先释放资源，再主动动作 暂停：Thread.sleep()，休眠 终止：run方法结束，线程终止 多线程死锁 每个线程互相持有别的线程需要的锁 预防死锁，对资源进行等级排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 测试死锁 */public class DeadLockThread &#123; public static Integer one = 1; public static Integer two = 2; public static void main(String[] args) throws InterruptedException &#123; Thread12 thread12 = new Thread12(); Thread21 thread21 = new Thread21(); thread12.start(); thread21.start(); &#125;&#125;class Thread12 extends Thread &#123; @Override public void run() &#123; //先拿1再拿2 synchronized (DeadLockThread.one) &#123; try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (DeadLockThread.two) &#123; System.out.println(\"Thread 12 is running\"); &#125; &#125; &#125;&#125;class Thread21 extends Thread &#123; @Override public void run() &#123; //先拿2再拿1 synchronized (DeadLockThread.two) &#123; try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (DeadLockThread.one) &#123; System.out.println(\"Thread 21 is running\"); &#125; &#125; &#125;&#125; 线程报错信息： “Monitor Ctrl-Break” #6 daemon prio=5 os_prio=0 tid=0x0000000018bce000 nid=0x1280 runnable [0x000000001908e000]java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:170) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) locked &lt;0x00000000d5fb3550&gt; (a java.io.InputStreamReader)at java.io.InputStreamReader.read(InputStreamReader.java:184)at java.io.BufferedReader.fill(BufferedReader.java:161)at java.io.BufferedReader.readLine(BufferedReader.java:324) locked &lt;0x00000000d5fb3550&gt; (a java.io.InputStreamReader) 守护(后台)线程Thread.setDaemon()设置线程为守护线程 普通线程的结束，是run方法运行结束 守护线程的结束，是run方法运行结束，或main函数结束 守护线程永远不要访问资源，如文件或数据库等 12345678910111213141516171819202122232425262728public class MultiThreading &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main thread is running.\"); ThreadOne threadOne = new ThreadOne(); //守护线程 threadOne.setDaemon(true); threadOne.start(); //主线程休眠2秒 Thread.sleep(2000); System.out.println(\"Main thread is finished.\"); &#125;&#125;class ThreadOne extends Thread &#123; @Override public void run() &#123; while (true) &#123; System.out.println(\"Thread one is running.\"); try &#123; //休眠1秒 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 输出： Main thread is running.Thread one is running.Thread one is running.Thread one is running.Main thread is finished. Process finished with exit code 0 线程查看工具 Jvisualvm 参考：Jvisualvm简单使用教程","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lao-biao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"LeetCode--#202快乐数","slug":"LeetCode-202快乐数","date":"2020-04-30T02:24:48.000Z","updated":"2020-07-06T03:21:39.884Z","comments":true,"path":"articles/6cd30686.html","link":"","permalink":"https://lao-biao.github.io/articles/6cd30686.html","excerpt":"快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。编写一个算法来判断一个数 n 是不是快乐数。 示例： 输入：19输出：true解释：$1^2$ + $9^2$ = 82$8^2$ + $2^2$ = 68$6^2$ + $8^2$ = 100$1^2$ + $0^2$ + $0^2$ = 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number","text":"快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。编写一个算法来判断一个数 n 是不是快乐数。 示例： 输入：19输出：true解释：$1^2$ + $9^2$ = 82$8^2$ + $2^2$ = 68$6^2$ + $8^2$ = 100$1^2$ + $0^2$ + $0^2$ = 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number 集合法通过用Set集合来保存数n去判断是否出现循环，当出现循环时，返回false 时间复杂度：$O(\\log_2{n})$ 空间复杂度：$O(\\log_2{n})$ 1234567891011121314151617181920/*** 集合法*/public static boolean isHappyBySet(int n) &#123; //List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //用Set比List快 Set&lt;Integer&gt; list = new HashSet&lt;&gt;(); while (n != 1 &amp;&amp; !list.contains(n)) &#123; list.add(n); int num = 0; //求n的每一位的平方和 while (n != 0) &#123; int bit = n % 10; num += bit * bit; n = n / 10; &#125; n = num; &#125; return n == 1;&#125; 快慢指针法 使用”快慢指针”思想找出循环：”快指针”每次走两步，”慢指针”每次走一步，二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。 参考题解： 作者：linux-man 链接：https://leetcode-cn.com/problems/happy-number/solution/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/ 来源：力扣（LeetCode） 时间复杂度：$O(\\log_2{n})$ 空间复杂度：$O(1)$ 12345678910111213141516171819202122232425/*** 快慢指针法 */public static boolean isHappy(int n) &#123; int slow = n, fast = n; do &#123; slow = bitSquareSum(slow); fast = bitSquareSum(fast); fast = bitSquareSum(fast); &#125; while (slow != fast); return slow == 1;&#125;/*** 求数n每一位的平方和*/private static int bitSquareSum(int n) &#123; int num = 0; while (n != 0) &#123; int bit = n % 10; num += bit * bit; n = n / 10; &#125; return num;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--#1095山脉数组中查找目标值","slug":"LeetCode-1095山脉数组中查找目标值","date":"2020-04-29T12:17:43.000Z","updated":"2020-07-06T03:21:46.841Z","comments":true,"path":"articles/8d630654.html","link":"","permalink":"https://lao-biao.github.io/articles/8d630654.html","excerpt":"山脉数组中查找目标值 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件： 首先，A.length &gt;= 3 其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）MountainArray.length() - 会返回该数组的长度 注意：对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。 示例 1： 输入：array = [1,2,3,4,5,3,1], target = 3输出：2解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。 示例 2： 输入：array = [0,1,2,4,2,1], target = 3输出：-1解释：3 在数组中没有出现，返回 -1。 提示：3 &lt;= mountain_arr.length() &lt;= 100000 &lt;= target &lt;= $10^9$0 &lt;= mountain_arr.get(index) &lt;= $10^9$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-in-mountain-array","text":"山脉数组中查找目标值 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件： 首先，A.length &gt;= 3 其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）MountainArray.length() - 会返回该数组的长度 注意：对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。 示例 1： 输入：array = [1,2,3,4,5,3,1], target = 3输出：2解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。 示例 2： 输入：array = [0,1,2,4,2,1], target = 3输出：-1解释：3 在数组中没有出现，返回 -1。 提示：3 &lt;= mountain_arr.length() &lt;= 100000 &lt;= target &lt;= $10^9$0 &lt;= mountain_arr.get(index) &lt;= $10^9$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-in-mountain-array 三次二分查找第一次二分查找：找到峰值 第二次二分查找：要返回最小的下标的目标值，从峰值左边开始二分查找，找到返回其索引，没找到则返回-1 第三次二分查找：当峰值左边没有目标值时，再对峰值右边进行二分查找，找到返回其索引，没找到则返回-1 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071interface MountainArray &#123; public int get(int index); public int length();&#125;//题解public int findInMountainArray(int target, MountainArray mountainArr) &#123; int len = mountainArr.length(); int top = findMountainTop(mountainArr, 0, len - 1); //找峰值的位置 int index = findFromMountainLeft(mountainArr, 0, top, target); // 在峰值左边进行二分查找 if (index == -1) return findFromMountainRight(mountainArr, top, len - 1, target); return index;&#125;/*** 二分法找峰值*/private int findMountainTop(MountainArray mountainArr, int left, int right) &#123; while (left &lt; right) &#123; // int mid =(left+right)/2; 可能会导致整形溢出 int mid = left + (right - left) / 2; if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) // 如果当前的数比右边的数小，它一定不是山顶 left = mid + 1; else right = mid; &#125; //峰值是一定存在的 return left;&#125;/*** 二分法在峰值左边查找*/private int findFromMountainLeft(MountainArray mountainArr, int left, int right, int target) &#123; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (mountainArr.get(mid) &lt; target) // 如果当前的数比目标值小，则目标数在大的一部分(右边) left = mid + 1; else right = mid; &#125; //剩余一个数时，判断是否是目标值 if (mountainArr.get(left) == target) return left; return -1;&#125;/*** 二分法在峰值右边查找*/private int findFromMountainRight(MountainArray mountainArr, int left, int right, int target) &#123; while (left &lt; right) &#123; //结束条件相当于left=right int mid = left + (right - left) / 2; if (mountainArr.get(mid) &gt; target) // 如果当前的数比目标值小，则目标数在小的一部分(右边) left = mid + 1; else right = mid; &#125; //剩余一个数时，判断是否是目标值 if (mountainArr.get(left) == target) return left; return -1;&#125; 参考题解：https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--#46全排列","slug":"LeetCode-46全排列","date":"2020-04-28T13:14:09.000Z","updated":"2020-07-06T03:21:01.436Z","comments":true,"path":"articles/6d9b5c12.html","link":"","permalink":"https://lao-biao.github.io/articles/6d9b5c12.html","excerpt":"全排列 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutations","text":"全排列 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutations 回溯法解析：https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/ 时间复杂度：$O(nn!)$，其中 *n 为序列的长度空间复杂度：$O(n)$，其中 n 为序列的长度 123456789101112131415161718192021222324252627282930313233343536/*** 回溯法** @param len* @param output* @param res* @param first*/public void backtrack(int len, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, int first) &#123; // 递归结束条件：所有数都填完了 if (first == len) res.add(new ArrayList&lt;&gt;(output)); for (int i = first; i &lt; len; i++) &#123; // 动态维护数组 Collections.swap(output, first, i); // 继续递归填下一个数 backtrack(n, output, res, first + 1); // 撤销操作 Collections.swap(output, first, i); &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; output = new ArrayList&lt;&gt;(); for (int num : nums) output.add(num); int len = nums.length; backtrack(len, output, res, 0); return res;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--#33搜索旋转排序数组","slug":"LeetCode-33搜索旋转排序数组","date":"2020-04-28T13:12:06.000Z","updated":"2020-07-06T03:20:52.800Z","comments":true,"path":"articles/69254e2b.html","link":"","permalink":"https://lao-biao.github.io/articles/69254e2b.html","excerpt":"搜索旋转排序数组 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array","text":"搜索旋转排序数组 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array 二分搜索算法时间复杂度要求必须是 O(log n) 级别，需要使用二分法求解，而数组不一定是完全有序的，是部分有序的，要考虑到旋转点的位置 1234567891011121314151617181920212223242526272829303132/*** 递归二分搜索** @param nums* @param target* @return*/public static int searchByRecursion(int[] nums, int target) &#123; if (nums == null || nums.length == 0) //判空，避免空指针异常和索引越界 return -1; return search(nums, target, 0, nums.length - 1);&#125;private static int search(int[] nums, int target, int left, int right) &#123; int mid = left + (right - left) / 2; //使用&gt;=可以避免数组索引越界 if (left &gt;= right &amp;&amp; target != nums[mid]) //递归结束条件：没找到 return -1; if (target == nums[mid]) //递归结束条件：找到 return mid; if (nums[0] &lt;= nums[mid]) &#123; if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) //target在前半部分 return search(nums, target, left, mid - 1); else return search(nums, target, mid + 1, right); &#125; else &#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.length - 1]) //target在后半部分 return search(nums, target, mid + 1, right); else return search(nums, target, left, mid - 1); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--#1两数之和","slug":"LeetCode-1两数之和","date":"2020-04-28T12:59:53.000Z","updated":"2020-07-06T03:20:39.584Z","comments":true,"path":"articles/eb1f9a79.html","link":"","permalink":"https://lao-biao.github.io/articles/eb1f9a79.html","excerpt":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum","text":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum 暴力解法(超时)枚举比较，从第一个数到最后一个数逐个求和比较，直至匹配成功 时间复杂度：$O(n^2)$空间复杂度：$O(1)$ 123456789101112131415/*** 暴力解法*/public int[] twoSumByBF(int[] nums, int target) &#123; if (nums == null || nums.length &lt; 2) return new int[]&#123;-1, -1&#125;; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (target == nums[i] + nums[j]) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return new int[]&#123;-1, -1&#125;;&#125; 两遍hash表第一遍：将数组转换成hash表，以数组的数值作为键，以索引作为值存储在hash表中第二遍：在hash表中查找，查找能与当前数组的元素的和为target的键 时间复杂度：O(n)空间复杂度：O(n) 12345678910111213141516171819202122/*** 两遍hash表* @param nums* @param target* @return*/public int[] twoSumByHashMap(int[] nums, int target) &#123; if (nums == null || nums.length &lt; 2) return new int[]&#123;-1, -1&#125;; Map&lt;Integer, Integer&gt; table = new HashMap&lt;&gt;(); //将数组转换成hash表 for (int i = 0; i &lt; nums.length; i++) table.put(nums[i], i); //以数值为键，索引为值 //查找 for (int i = 0; i &lt; nums.length - 1; i++) &#123; int searched = target - nums[i]; if (table.containsKey(searched) &amp;&amp; table.get(searched) != i) &#123; return new int[]&#123;i, table.get(searched)&#125;; &#125; &#125; return new int[]&#123;-1, -1&#125;;&#125; 一遍hash表一边插入hash表，一边查找 时间复杂度：O(n)空间复杂度：O(n) 123456789101112131415161718192021/*** 一遍hash表，边插入边查找* @param nums* @param target* @return*/public int[] twoSumByHashMapOnce(int[] nums, int target) &#123; if (nums == null || nums.length &lt; 2) return new int[]&#123;-1, -1&#125;; Map&lt;Integer, Integer&gt; table = new HashMap&lt;&gt;(); //将数组转换成hash表 for (int i = 0; i &lt; nums.length; i++) &#123; int searched = target - nums[i]; //先查找 if (table.containsKey(searched) &amp;&amp; table.get(searched) != i) //保证不是同一个元素 return new int[]&#123;table.get(searched), i&#125;; //后插入表中 table.put(nums[i], i); &#125; return new int[]&#123;-1, -1&#125;;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--面试题#56数组中数字出现的次数","slug":"LeetCode-面试题-56数组中数字出现的次数","date":"2020-04-28T12:39:36.000Z","updated":"2020-07-06T03:22:01.085Z","comments":true,"path":"articles/e4abd3a9.html","link":"","permalink":"https://lao-biao.github.io/articles/e4abd3a9.html","excerpt":"数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2： 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof","text":"数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2： 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof 分组位运算题目要求时间复杂度是O(n)，空间复杂度是O(1)，则不能使用枚举比较，以及HashMap来解决。 数组中只存在着两个数字不重复的情况，将数组中所有的数字进行异或操作，最终得到的结果即是这两个不重复数字的异或结果。 异或操作 举例数组：[4,1,4,6]相关数值的二进制表达 1 :b01 4 :b100 6 :b110 0 ^ 4 = b1001 ^ b100 = b101b101 ^ 6 = b011b011 ^ 4 = b111 两个不重复数字异或结果后最低位的1: int div =1 按奇偶分组： a记录奇数，b记录偶数 4 &amp; 1 = 0 b = 0 ^ 4 = 0b100 = 41 &amp; 1 = 1 a = 1 ^ 1 = 0b1—-其中一个4 &amp; 1 = 0 b = 4 ^ 4 = 0b06 &amp; 1 = 0 b = 0 ^ 6 = 0b110 = 6—-其中另一个 代码 123456789101112131415161718192021222324/*** 分组位运算* @param nums* @return*/public static int[] singleNumbers(int[] nums) &#123; int ret = 0; //数组中所有元素异或 for (int n : nums) ret ^= n; int div = 1; //获取异或结果最低位的1 //或 int div=ret&amp;(-ret); while ((div &amp; ret) == 0) div &lt;&lt;= 1; //左移一位 int a = 0, b = 0; //记录两个单次出现的数的位置 //按奇偶分组 for (int n : nums) if ((div &amp; n) != 0) //记录奇数 a ^= n; else //记录偶数 b ^= n; return new int[]&#123;a, b&#125;;&#125; 以 int 数据类型为例 2个字节(16位)，Java中 int 是4字节（ 与JVM相关）1 与 -1原码：00000000 00000001反码：11111111 11111110 反码为原码按位取反补码：11111111 11111111 补码为反码 +11 &amp; -1 最低位的1即为 1 7 与 -7原码：00000000 00000111反码：11111111 11111000补码：11111111 111110017 &amp; -7 最低位的1即为 1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"Java--xml文件解析","slug":"Java-xml文件解析","date":"2020-04-26T02:59:01.000Z","updated":"2020-07-06T03:37:08.871Z","comments":true,"path":"articles/7fb4a625.html","link":"","permalink":"https://lao-biao.github.io/articles/7fb4a625.html","excerpt":"xml解析xml解析方式有DOM、SAX、Stax三种方式 树结构 DOM: Document Object Model 文档对象模型，擅长(小规模)读/写 流结构 SAX: Simple API for XML 流机制解释器(推模式)，擅长读 Stax: The Streaming API for XML 流机制解释器(拉模式)，擅长读， JDK 6 引入","text":"xml解析xml解析方式有DOM、SAX、Stax三种方式 树结构 DOM: Document Object Model 文档对象模型，擅长(小规模)读/写 流结构 SAX: Simple API for XML 流机制解释器(推模式)，擅长读 Stax: The Streaming API for XML 流机制解释器(拉模式)，擅长读， JDK 6 引入 DOMDOM 是 W3C 处理 XML 的标准 API 直观易用 其处理方式是将 XML 整个作为类似树结构的方式读入内存中以 便操作及解析，方便修改 解析大数据量的 XML 文件，会遇到内存泄露及程序崩溃的风险 DOM 类 DocumentBuilder 解析类，parse方法 Node 节点主接口，getChildNodes返回一个NodeList NodeList 节点列表，每个元素是一个Node Document 文档根节点 Element 标签节点元素 (每一个标签都是标签节点) Text节点 (包含在XML元素内的，都算Text节点) Attr节点(每个属性节点) 读取xml文件：fonts.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;fonts&gt; &lt;font id=\"0\"&gt; &lt;name&gt;宋体&lt;/name&gt; &lt;size&gt;18&lt;/size&gt; &lt;/font&gt; &lt;font id=\"1\"&gt; &lt;name&gt;微软雅黑&lt;/name&gt; &lt;size&gt;12&lt;/size&gt; &lt;/font&gt; &lt;font id=\"2\"&gt; &lt;name&gt;正楷&lt;/name&gt; &lt;size&gt;16&lt;/size&gt; &lt;/font&gt;&lt;/fonts&gt; DomReader.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class DomReader &#123; public static void main(String[] args) &#123; recursiveTraverse(); System.out.println(\"--------------------分割线--------------------\"); traverseBySearch(); &#125; /** * 遍历xml文档 */ public static void recursiveTraverse() &#123; try &#123; //采用DOM解析xml文件 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.parse(\"fonts.xml\"); //获取所有一级子节点 NodeList childNodes = document.getChildNodes(); for (int i = 0; i &lt; childNodes.getLength(); i++) &#123; //1=&lt;fonts&gt; Node font = childNodes.item(i); NodeList fontList = font.getChildNodes(); //获取所有二级子节点 for (int j = 0; j &lt; fontList.getLength(); j++) &#123; //7=4个空格+3*&lt;font&gt; Node fontItem = fontList.item(j); if (font.getNodeType() == Node.ELEMENT_NODE) &#123; //获取内容 NodeList fontChildNodes = fontItem.getChildNodes(); for (int k = 0; k &lt; fontChildNodes.getLength(); k++) &#123; //5=3个空格+&lt;name&gt;+&lt;size&gt; Node fontNode = fontChildNodes.item(k); if (fontNode.getNodeType() == Node.ELEMENT_NODE) &#123; //获取内容 System.out.println(fontNode.getNodeName() + \":\" + fontNode.getTextContent()); &#125; &#125; &#125; &#125; &#125; &#125; catch (ParserConfigurationException | SAXException | IOException e) &#123; e.printStackTrace(); &#125; &#125; /*** 通过标签名查找元素*/ public static void traverseBySearch() &#123; try &#123; //采用DOM解析xml文件 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.parse(\"fonts.xml\"); Element rootElement = document.getDocumentElement(); NodeList nodeList = rootElement.getElementsByTagName(\"name\"); if (nodeList != null) &#123; for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; Element element = (Element) nodeList.item(i); System.out.println(element.getNodeName() + \":\" + element.getTextContent()); &#125; &#125; &#125; catch (ParserConfigurationException | IOException | SAXException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 写xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DomWriter &#123; public static void main(String[] args) &#123; try &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.newDocument(); //创建document结点 if (document != null) &#123; //通过document结点创建元素 Element docx = document.createElement(\"document\"); Element element = document.createElement(\"element\"); element.setAttribute(\"type\", \"paragraph\"); //设置属性 element.setAttribute(\"alignment\", \"left\"); Element object = document.createElement(\"object\"); object.setAttribute(\"type\", \"text\"); Element text = document.createElement(\"text\"); text.appendChild(document.createTextNode(\"This is text node\")); //元素赋值 Element bold = document.createElement(\"bold\"); bold.appendChild(document.createTextNode(\"true\")); //元素赋值 object.appendChild(text); //挂载 object.appendChild(bold); element.appendChild(object); docx.appendChild(element); document.appendChild(docx); TransformerFactory transformerFactory = TransformerFactory.newInstance(); Transformer transformer = transformerFactory.newTransformer(); DOMSource source = new DOMSource(document); //将结点转化成dom资源 //创建目标文件 File file = new File(\"dom.xml\"); StreamResult streamResult = new StreamResult(file); //将xml内容写入文件中 transformer.transform(source, streamResult); &#125; &#125; catch (ParserConfigurationException | TransformerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 生成的xml文件：dom.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;document&gt; &lt;element alignment=\"left\" type=\"paragraph\"&gt; &lt;object type=\"text\"&gt; &lt;text&gt;This is text node&lt;/text&gt; &lt;bold&gt;true&lt;/bold&gt; &lt;/object&gt; &lt;/element&gt;&lt;/document&gt; SAXSimple API for XML 采用事件/流模型来解析 XML 文档，更快速、更轻量。 有选择的解析和访问，不像 DOM 加载整个文档，内存要求较低。 – SAX 对 XML 文档的解析为一次性读取，不创建/不存储文档对象，很难同时访问文档中的多处数据。 推模型 当它每发现一个节点就引发一个事件，而我们需要编写 这些事件的处理程序。 关键类 DefaultHandler SAXHandler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** 处理xml文档内容*/class SAXHandler extends DefaultHandler &#123; private List&lt;String&gt; nameList; private boolean isName = false; public List&lt;String&gt; getNameList() &#123; return nameList; &#125; //xml文档加载时 @Override public void startDocument() throws SAXException &#123; System.out.println(\"start document\"); nameList = new ArrayList&lt;String&gt;(); &#125; //xml文档解析结束 @Override public void endDocument() throws SAXException &#123; System.out.println(\"end document\"); &#125; //访问某一个元素 @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; System.out.println(\"start element\"); if (qName.equals(\"name\")) &#123; isName = true; &#125; &#125; //结束访问某一个元素 @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; System.out.println(\"end element\"); if (isName) &#123; isName = false; &#125; &#125; //访问元素正文 @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; if (isName) &#123; String name = new String(ch, start, length); nameList.add(name); &#125; &#125;&#125; XmlSAXReader.java 测试读文件 fonts.xml 123456789public class XmlSAXReader &#123; public static void main(String[] args) throws SAXException, IOException &#123; XMLReader parser = XMLReaderFactory.createXMLReader(); SAXHandler handler = new SAXHandler(); parser.setContentHandler(handler); parser.parse(\"fonts.xml\"); System.out.println(handler.getNameList()); &#125;&#125; StaxStreaming API for XML 流模型中的拉模型 在遍历文档时，会把感兴趣的部分从读取器中拉出，不需要引发 事件，允许我们选择性地处理节点。这大大提高了灵活性，以及整体效率 两套处理API 基于指针的API， XMLStreamReader 基于迭代器的API，XMLEventReader 测试读取xml文件 事件模式 和 流模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class StaxReader &#123; public static void main(String[] args) &#123; staxReaderByEvent(); System.out.println(\"-------------分割线-------------\"); staxReaderByStream(); &#125; /** * 事件模式 */ private static void staxReaderByEvent() &#123; String xmlFile = \"fonts.xml\"; XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance(); boolean isName = false; try &#123; //创建基于迭代器的事件读取器对象 XMLEventReader xmlEventReader = xmlInputFactory.createXMLEventReader(new FileReader(xmlFile)); //遍历event迭代器 while (xmlEventReader.hasNext()) &#123; XMLEvent xmlEvent = xmlEventReader.nextEvent(); //事件对象是元素的开始 if (xmlEvent.isStartElement()) &#123; //转换为开始元素事件对象 StartElement startElement = xmlEvent.asStartElement(); if (startElement.getName().getLocalPart().equals(\"name\")) isName = true; //获取所有属性 Iterator attr = startElement.getAttributes(); while (attr.hasNext()) System.out.println(attr.next()); &#125; //事件对象是正文 if (xmlEvent.isCharacters()) &#123; //获取正文内容 String data = xmlEvent.asCharacters().getData(); //打印内容 if (isName &amp;&amp; data != null &amp;&amp; data.trim().length() != 0) System.out.println(data); &#125; //事件对象是元素结束 if (xmlEvent.isEndElement()) &#123; //将事件对象转换成元素结束 EndElement endElement = xmlEvent.asEndElement(); if (endElement.getName().getLocalPart().equals(\"name\")) isName = false; &#125; &#125; //结束 xmlEventReader.close(); &#125; catch (FileNotFoundException | XMLStreamException e) &#123; e.printStackTrace(); &#125; &#125; /** * 流模式 */ private static void staxReaderByStream() &#123; String xmlFile = \"fonts.xml\"; XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance(); XMLStreamReader xmlStreamReader = null; try &#123; xmlStreamReader = xmlInputFactory.createXMLStreamReader(new FileReader(xmlFile)); &#125; catch (XMLStreamException | FileNotFoundException e) &#123; e.printStackTrace(); &#125; //基于指针的遍历 try &#123; if (xmlStreamReader != null) &#123; while (xmlStreamReader.hasNext()) &#123; int event = xmlStreamReader.next(); //元素的开始 if (event == XMLStreamConstants.START_ELEMENT) //打印&lt;font&gt;的name标签的内容 if (\"name\".equals(xmlStreamReader.getLocalName())) System.out.println(\"name:\" + xmlStreamReader.getElementText()); &#125; //关流 xmlStreamReader.close(); &#125; &#125; catch (XMLStreamException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 其他的第三方库DOM/SAX/Stax是JDK自带的解析功能 第三方库 JDOM: https://www.jdom.org DOM4J: https://dom4j.github.io 第三方库一般都包含DOM,SAX等多种方式解析，是对Java 解析进行封装","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"}],"tags":[{"name":"xml解析","slug":"xml解析","permalink":"https://lao-biao.github.io/tags/xml%E8%A7%A3%E6%9E%90/"}]},{"title":"LeetCode--面试题#51数组中的逆序对","slug":"LeetCode-面试题-51数组中的逆序对","date":"2020-04-25T02:43:20.000Z","updated":"2020-07-06T03:21:53.989Z","comments":true,"path":"articles/9fbcfe23.html","link":"","permalink":"https://lao-biao.github.io/articles/9fbcfe23.html","excerpt":"数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4] 输出: 5 限制： 0 &lt;= 数组长度 &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/","text":"数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4] 输出: 5 限制： 0 &lt;= 数组长度 &lt;= 50000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/ 暴力解法数组从前往后，逐个比较 时间复杂度：O(n2) 空间复杂度：O(1) 12345678910111213141516171819/** * 暴力算法：超时 * * @param nums * @return */public int reversePairsBF(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return 0; &#125; int res = 0; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] &gt; nums[j]) res++; &#125; &#125; return res;&#125; 归并排序-分治法归并排序 如 设有数列{6，202，100，301，38，8，1}初始状态：6,202,100,301,38,8,1第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；第三次归并后：{1,6,8,38,100,202,301},比较次数：4；总的比较次数为：3+4+4=11；逆序数为14； 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针超出序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 百度百科：归并排序 12345678910111213141516171819public int[] mergeSort(int[] nums, int low, int high) &#123; if (low == high) return new int[]&#123;nums[low]&#125;; int mid = low + (high - low) / 2; int[] leftArr = mergeSort(nums, low, mid); //左有序数组 int[] rightArr = mergeSort(nums, mid + 1, high); //右有序数组 int[] newNum = new int[leftArr.length + rightArr.length]; //新有序数组 int m = 0, i = 0, j = 0; while (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123; newNum[m++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++]; &#125; while (i &lt; leftArr.length) newNum[m++] = leftArr[i++]; while (j &lt; rightArr.length) newNum[m++] = rightArr[j++]; return newNum;&#125; 归并排序解题 在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数 时间复杂度：O(n log2 n) 空间复杂度：O(n) 12345678910111213141516171819202122232425262728293031/*** 借助归并排序：分治法** @param nums* @return 逆序对数*/public int reversePairs(int[] nums) &#123; int[] temp = new int[nums.length]; //临时数组，用于存放有序数组 return merge(nums, 0, nums.length - 1,temp);&#125;private int merge(int[] nums, int low, int high,int[] temp) &#123; if (low &gt;= high) //递归结束条件 return 0; int mid = low + (high - low) / 2; int res = merge(nums, low, mid,temp) + merge(nums, mid + 1, high,temp); //区间划分 int i = low, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; res += nums[i] &lt;= nums[j] ? j - (mid + 1) : 0; temp[k++] = nums[i] &lt;= nums[j] ? nums[i++] : nums[j++]; &#125; while (i &lt;= mid) &#123; res += j - (mid + 1); temp[k++] = nums[i++]; &#125; while (j &lt;= high) temp[k++] = nums[j++]; System.arraycopy(temp, 0, nums, low, high - low + 1); //复制到原数组中 return res;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--#199二叉树的右视图","slug":"LeetCode-199二叉树的右视图","date":"2020-04-22T04:08:07.000Z","updated":"2020-07-06T03:21:11.099Z","comments":true,"path":"articles/60a087a9.html","link":"","permalink":"https://lao-biao.github.io/articles/60a087a9.html","excerpt":"二叉树的右视图给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 12345678910111213示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4] 解释: 1 &lt;--- / \\- 2 - 3 &lt;--- \\ \\ - 5 - 4 &lt;--- 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view","text":"二叉树的右视图给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 12345678910111213示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4] 解释: 1 &lt;--- / \\- 2 - 3 &lt;--- \\ \\ - 5 - 4 &lt;--- 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view 解法–二叉树按层次遍历按照二叉树的按层次遍历的方式（也可理解为深度优先遍历DFS），但每一层只输出最右边的结点，借助队列来实现 代码 1234567891011121314151617181920212223242526272829303132333435//结点定义public class TreeNode &#123; int val; //值 TreeNode left; //左子树 TreeNode right; //右子树 TreeNode(int x) &#123; val = x; &#125;&#125;public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); //root入队 while (!queue.isEmpty()) &#123; int len = queue.size(); while (--len &gt;= 0) &#123; //循环出队 TreeNode temp = queue.poll(); //队首出队 if (temp != null) &#123; if (len == 0) //当前是否为队尾元素 list.add(temp.val); //最右侧结点的值添加到列表中 if (temp.left != null) queue.add(temp.left); //左子树入队 if (temp.right != null) queue.add(temp.right); //右子树入队 &#125; &#125; &#125; return list; &#125;&#125; 解法–二叉树先序遍历对二叉树的先序遍历进行修改 遍历顺序为 根结点 右子树 左子树 ，并且只输出最右侧的结点， 用变量level记录当前层数，只有level等于列表的长度时才加入列表中(level从0开始) 代码 123456789101112131415161718192021222324/** * 二叉树先序遍历法 */public List&lt;Integer&gt; rightSideViewByPre(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); //列表用于存储结果 dfs(root, 0, res); //递归 return res;&#125;/** * 遍历顺序：根结点 右子树 左子树 * @param root 根节点 * @param level 当前层数 * @param res 列表 */private void dfs(TreeNode root, int level, List&lt;Integer&gt; res) &#123; if (root == null) //递归结束条件 return; if (level == res.size()) res.add(root.val); //加入到列表中 dfs(root.right, level + 1, res); //先遍历右子树 dfs(root.left, level + 1, res);&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"LeetCode--#200岛屿数量","slug":"LeetCode-200岛屿数量","date":"2020-04-21T11:14:08.000Z","updated":"2020-07-06T03:21:22.114Z","comments":true,"path":"articles/c2dfdd41.html","link":"","permalink":"https://lao-biao.github.io/articles/c2dfdd41.html","excerpt":"题目岛屿数量 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例一： 123456输入: 11110 11010 11000 00000输出: 1 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 示例二： 123456输入: 11000 11000 00100 00011输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 来源 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-islands","text":"题目岛屿数量 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例一： 123456输入: 11110 11010 11000 00000输出: 1 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 示例二： 123456输入: 11000 11000 00100 00011输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 来源 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-islands 解法深度优先搜索DFS思路深度优先搜索：借助递归 遍历整个数组 如果一个位置为 1，则以其为起始节点开始进行深度优先搜索 在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0 最终岛屿的数量就是进行深度优先搜索的次数 算法时间复杂度：O(MN) M：二维网格的行数，N：二维网格的列数 算法空间复杂度：O(1) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public int numIslandsByDFS(char[][] grid) &#123; if (grid == null || grid.length == 0) &#123; //判空 return 0; &#125; int islandNum = 0; //岛屿数量 int row = grid.length; //行数 int col = grid[0].length; //列数 for (int r = 0; r &lt; row; r++) &#123; //遍历列元素 for (int c = 0; c &lt; col; c++) &#123; //遍历行元素 if (grid[r][c] == '1') &#123; islandNum++; //岛屿数量+1 dfs(grid, r, c); //循环深度优先搜索 &#125; &#125; &#125; return islandNum; //返回岛屿数量&#125;/*** 深度优先搜索--借助递归* 遍历整个数组* 如果一个位置为 1，则以其为起始节点开始进行深度优先搜索* 在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0* 最终岛屿的数量就是进行深度优先搜索的次数** @param grid 二维网格* @param r 当前元素行数* @param c 当前元素列数*/private void dfs(char[][] grid, int r, int c) &#123; int row = grid.length; //行数 int col = grid[0].length; //列数 if (r &lt; 0 || c &lt; 0 || r &gt;= row || c &gt;= col || grid[r][c] == '0') &#123; //递归结束条件 return; &#125; grid[r][c] = '0'; //重新标记 dfs(grid, r - 1, c); //正上方 dfs(grid, r + 1, c); //正下方 dfs(grid, r, c - 1); //正左方 dfs(grid, r, c + 1); //正右方&#125; 广度优先搜索BFS思路广度优先搜索：借助队列 遍历整个数组 如果一个位置为 1，则将其加入队列，开始进行广度优先搜索 在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0 直到队列为空，搜索结束 最终岛屿的数量就是进行广度优先搜索的次数 算法时间复杂度：O(MN) 算法空间复杂度：O(min(M,N)) M：二维网格的行数，N：二维网格的列数 代码123456789101112131415161718192021222324252627282930313233343536373839404142public static int numIslandsByBFS(char[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int islandsNum = 0; //岛屿数量 int row = grid.length; //行数 int col = grid[0].length; //列数 //遍历 for (int r = 0; r &lt; row; r++) &#123; for (int c = 0; c &lt; col; c++) &#123; if (grid[r][c] == '1') &#123; //陆地 grid[r][c] = '0'; //重新标记 islandsNum++; Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(r * col + c); //入队 while (!queue.isEmpty()) &#123; //队列不为空 int id = queue.remove(); //出队 //当前元素的位置 int cr = id / col; //当前元素的行 int cc = id % col; //当前元素的列 if (cr - 1 &gt;= 0 &amp;&amp; grid[cr - 1][cc] == '1') &#123; //正上方 queue.add((cr - 1) * col + cc); grid[cr - 1][cc] = '0'; //重新标记 &#125; if (cr + 1 &lt; row &amp;&amp; grid[cr + 1][cc] == '1') &#123; //正下方 queue.add((cr + 1) * col + cc); grid[cr + 1][cc] = '0'; //重新标记 &#125; if (cc - 1 &gt;= 0 &amp;&amp; grid[cr][cc - 1] == '1') &#123; //正左方 queue.add(cr * col + cc - 1); grid[cr][cc - 1] = '0'; //重新标记 &#125; if (cc + 1 &lt; col &amp;&amp; grid[cr][cc + 1] == '1') &#123; //正右方 queue.add(cr * col + cc + 1); grid[cr][cc + 1] = '0'; //重新标记 &#125; &#125; &#125; &#125; &#125; return islandsNum;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"}],"tags":[]},{"title":"Java语法糖--var类型和switch","slug":"Java语法糖-var类型和switch","date":"2020-04-20T05:06:13.000Z","updated":"2020-07-06T03:38:01.303Z","comments":true,"path":"articles/ab1a490c.html","link":"","permalink":"https://lao-biao.github.io/articles/ab1a490c.html","excerpt":"","text":"var类型Java 10 推出var：局部变量推断 避免信息冗余 对齐了变量名 更容易阅读 本质上还是强类型语言，编译器负责推断类型，并写入字节码文件，推断后不能更改 12345var a = 5;var b = 0.25;var c = \"Hello\";var d = new URL(\"https://github.com);c = 5; //编译器报错 var的限制 可以用在局部变量上，非类成员变量 可以用在for/for-each循环中 声明时必须初始化 不能用在方法（形式）参数和返回类型 大面积滥用会使代码整体阅读性变差 var只在编译时起作用，没有在字节码中引入新的内容，也没有专门的JVM指令处理var switch多分支选择语句 支持的类型：byte/Byte short/Short int/Integer char/Character String(JDK7.0) Enum(JDK5.0) 不支持long float double 多分支合并采用 -&gt; 直接连接判定条件和动作(JDK12) 1234567int days;switch(month)&#123; case \"Jan\",\"Nar\",\"May\",\"July\",\"Aug\",\"Oct\",\"Dec\" -&gt; days = 31; case \"Apr\",\"June\",\"Sep\",\"Nov\" -&gt; days = 30; case \"Feb\" -&gt; days = 28; default -&gt; days = -1; //必须有default&#125; 直接在表达式赋值直接在表达式赋值(JDK12) 123456789int num = 1;int days = switch (num)&#123; case 1,3,5,7,8,10,12 -&gt;31; case 4,6,9,11 -&gt; 30; default -&gt; &#123; int result = 28; break result; //代码块中的break返回结果 &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"}],"tags":[{"name":"var","slug":"var","permalink":"https://lao-biao.github.io/tags/var/"},{"name":"switch","slug":"switch","permalink":"https://lao-biao.github.io/tags/switch/"}]},{"title":"Java语法糖--try-with-resource和ResourceBundle文件加载","slug":"Java语法糖-try-with-resource和ResourceBundle文件加载","date":"2020-04-20T04:35:57.000Z","updated":"2020-07-06T03:37:55.853Z","comments":true,"path":"articles/868afa36.html","link":"","permalink":"https://lao-biao.github.io/articles/868afa36.html","excerpt":"try-with-resourcetry-with-resource与try-catch-finally程序打开外部资源，在使用后需要正确关闭 考虑到异常因素，Java提供try-catch-finally进行保证 JDK7提供try-with-resource，比try-catch-finally更简便 1234567891011121314151617//try-catch-finally结构FileInputStream fis = ...;try&#123; ...&#125;catch(Exception e)&#123; //处理异常&#125;finally&#123; if(fis!=null) fis.close(); //关流&#125;//try-with-resource结构try(FileInputStream fis = ...)&#123; ...&#125;catch(Exception e)&#123; //处理异常&#125; JDK7提供try-with-resource要求resource定义在try中，若外部已经定义需要一个本地变量 JDK9不再要求定义临时变量，可以直接使用外部资源变量","text":"try-with-resourcetry-with-resource与try-catch-finally程序打开外部资源，在使用后需要正确关闭 考虑到异常因素，Java提供try-catch-finally进行保证 JDK7提供try-with-resource，比try-catch-finally更简便 1234567891011121314151617//try-catch-finally结构FileInputStream fis = ...;try&#123; ...&#125;catch(Exception e)&#123; //处理异常&#125;finally&#123; if(fis!=null) fis.close(); //关流&#125;//try-with-resource结构try(FileInputStream fis = ...)&#123; ...&#125;catch(Exception e)&#123; //处理异常&#125; JDK7提供try-with-resource要求resource定义在try中，若外部已经定义需要一个本地变量 JDK9不再要求定义临时变量，可以直接使用外部资源变量 原理资源对象必须继承AutoCloseable接口，即实现close()方法 public class FileInputStream extends InputStream public abstract class InputStream implements Closeable public interface Closeable extends AutoCloseable 123456789101112131415161718//FileInputStream类close方法public void close() throws IOException &#123; synchronized (closeLock) &#123; if (closed) &#123; return; &#125; closed = true; &#125; if (channel != null) &#123; channel.close(); &#125; fd.closeAll(new Closeable() &#123; public void close() throws IOException &#123; close0(); &#125; &#125;);&#125; ResourceBundle文件加载优化Java 8及以前，ResourceBundle默认以ISO-8859-1方式加载Properties文件：需要利用native2ascii工具(JDK自带)对文件进行转义 Java 9及以后，ResourceBundle默认以UTF-8方式加载Properties文件 JDK9以后，已经删除native2ascii工具 新的Properties文件可以直接以UTF-8保存 已利用native2ascii工具转化后的文件，不受影响。ResourceBundle若解析文件不是有效的UTF-8，则以ISO-8859-1方式加载","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"}],"tags":[{"name":"try-with-resource","slug":"try-with-resource","permalink":"https://lao-biao.github.io/tags/try-with-resource/"},{"name":"Resource Bundle","slug":"Resource-Bundle","permalink":"https://lao-biao.github.io/tags/Resource-Bundle/"}]},{"title":"Java语法糖--接口方法","slug":"Java语法糖-接口方法","date":"2020-04-20T03:52:31.000Z","updated":"2020-07-06T03:38:12.765Z","comments":true,"path":"articles/4ee571a7.html","link":"","permalink":"https://lao-biao.github.io/articles/4ee571a7.html","excerpt":"","text":"接口的默认方法Java最初的设计中，接口的方法都是没有实现的、公开的 Java 8推出接口的默认方法/静态方法(都带有实现的)，为Lambda表达式提供支持 12345678910public interface Animal &#123; void move();&#125;//Java 8新特性public interface NewAnimal &#123; default void move() &#123; System.out.println(\"I am moving.\"); &#125;&#125; 以default关键字标注，其他的定义和普通函数一样 规则： 默认方法不能重写Object中的方法(equals() toString() hashcode()) 实现类可以继承/重写父接口的默认方法 接口可以继承/重写父接口的默认方法 当父类和父接口都有（同名同参数）默认方法，子类继承父类的默认方法，兼容JDK及其以前的代码 子类实现了2个接口（均有同名同参数的默认方法），编译失败，必须在子类中重写这个default方法 接口的静态方法Java 8接口的静态方法（带实现的） 该静态方法属于本接口的，不属于子类/子接口 子类（子接口）没有继承该静态方法，只能通过所在的接口名来调用 1234567891011121314151617public interface StaticAnimal &#123; static void move() &#123; System.out.println(\"static animal move()\"); &#125;&#125;public interface StaticLandAnimal extends StaticAnimal &#123; //不能继承StaticAnimal的move()方法&#125;public static class TestStatic implements StaticLandAnimal &#123; public static void main(String[] args) &#123; StaticAnimal.move(); StaticLandAnimal.move(); //编译器报错 new TestStatic().move(); //编译器报错 &#125;&#125; 接口的私有方法Java 9接口的私有方法（带实现的） 解决多个默认方法/静态方法内容重复问题 私有方法属于本接口，只在本接口内使用，不属于子类/子接口 子类（子接口）没有继承该私有方法，也无法调用 静态私有方法可以被静态/默认方法调用，非静态私有方法被默认方法调用 接口与抽象类比较相同点（–Java 12） 都是抽象的，都不能被实例化 都可以有实现方法 都可以不需要继承者实现所有的方法 不同点 抽象类最多只能继承一个，接口可以实现多个 接口的变量默认是 public static final且必须有初值，子类不能修改，而抽象类的变量默认是default，子类可以继承修改 接口没有构造函数，抽象类有构造函数 接口没有main函数，抽象类可以有main函数 接口有public default private的方法，抽象类有 public default protected private的方法","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"}],"tags":[{"name":"接口方法","slug":"接口方法","permalink":"https://lao-biao.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/"}]},{"title":"Java语法糖--自动装箱与拆箱、多异常并列和数值类型赋值优化","slug":"Java语法糖-自动装箱与拆箱、多异常并列和数值类型赋值优化","date":"2020-04-20T02:59:10.000Z","updated":"2020-07-06T03:38:18.624Z","comments":true,"path":"articles/e81b4a74.html","link":"","permalink":"https://lao-biao.github.io/articles/e81b4a74.html","excerpt":"自动装箱与拆箱介绍auto-boxing / auto-unboxing 从JDK5.0开始引入，简化基本类型和对象的写法 基本类型：boolean byte char int short long float double 对象：Boolean Byte Character Integer Short Long Float Double 12345Integer integer1 = 1; //自动装箱Integer integer2 = Integer.valueOf(1); int int1 = integer1; //自动拆箱int int2 = integer2.intValue(); 注意事项 自动装箱和拆箱是编译器的工作，在class中已经添加转化，虚拟机没有自动装箱和拆箱的语句 ==判断：基本类型是内容相同，对象是指针是否相同(内存同一个区域) 基本类型没有空值，对象有null，可能触发NullPointerException（空指针异常） 当一个基础数据类型与封装类进行 == + - * / 运算时，会将封装类进行拆箱，对基础数据类型进行运算 谨慎使用多个非同类的数值类对象进行运算","text":"自动装箱与拆箱介绍auto-boxing / auto-unboxing 从JDK5.0开始引入，简化基本类型和对象的写法 基本类型：boolean byte char int short long float double 对象：Boolean Byte Character Integer Short Long Float Double 12345Integer integer1 = 1; //自动装箱Integer integer2 = Integer.valueOf(1); int int1 = integer1; //自动拆箱int int2 = integer2.intValue(); 注意事项 自动装箱和拆箱是编译器的工作，在class中已经添加转化，虚拟机没有自动装箱和拆箱的语句 ==判断：基本类型是内容相同，对象是指针是否相同(内存同一个区域) 基本类型没有空值，对象有null，可能触发NullPointerException（空指针异常） 当一个基础数据类型与封装类进行 == + - * / 运算时，会将封装类进行拆箱，对基础数据类型进行运算 谨慎使用多个非同类的数值类对象进行运算 多异常并列简介多异常并列在一个catch中，从JDK7.0开始引入，简化写法 1234567try &#123; test(); //操作&#125; catch (IOException ie) &#123; ie.printStackTrace();&#125; catch (SQLException se) &#123; se.printStackTrace();&#125; 简化写法 | 管道符号 12345try &#123; test(); //操作&#125; catch (IOException | SQLException ie) &#123; ie.printStackTrace();&#125; 注意多个异常之间不能有直接/间接继承关系，否则会报错 处理方法不同，不能合并 数值赋值优化整数类型用二进制数赋值整数类型用二进制数赋值 Java7的新语法： 避免二进制计算 byte short int long 数字中的下划线Java7的新语法： 增加数字的可读性和纠错功能 short int long float double 下划线只能出现数字中间，前后必须有数字 允许在二/八/十/十六进制的数字中使用 int a = 0b0011_1011_0001;二进制 int b =02_014;八进制 int c=123__456;十进制，可使用多个下划线 int d =0x7_B_1;十六进制","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"}],"tags":[{"name":"自动装箱与拆箱","slug":"自动装箱与拆箱","permalink":"https://lao-biao.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"},{"name":"多异常并列","slug":"多异常并列","permalink":"https://lao-biao.github.io/tags/%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%B9%B6%E5%88%97/"},{"name":"数值类型赋值优化","slug":"数值类型赋值优化","permalink":"https://lao-biao.github.io/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%B5%8B%E5%80%BC%E4%BC%98%E5%8C%96/"}]},{"title":"Java语法糖--不定项参数和静态导入","slug":"Java语法糖-不定项参数和静态导入","date":"2020-04-20T02:07:53.000Z","updated":"2020-07-06T03:38:06.989Z","comments":true,"path":"articles/689cf977.html","link":"","permalink":"https://lao-biao.github.io/articles/689cf977.html","excerpt":"","text":"不定项参数介绍普通函数的形参列表是固定个数/类型/顺序 JDK5提供了不定项参数(可变参数)功能 数据类型后加… 如 int… /double… /String… 可变参数本质是一个数组，可以是0个也可以是n个同类型参数 要点 一个方法只能有一个不定项参数，且必须位于参数列表的最后 重载的优先级规则1：固定参数的方法，比可变参数优先级更高 重载的优先级规则2：调用语句，同时与两个带可变参数的方法匹配，会报错 1234567891011121314151617181920212223242526272829303132333435/*** 固定参数** @param message*/static void print(String message) &#123; System.out.println(message);&#125;/*** 不定项参数** @param message*/static void print(String... message) &#123; if (message == null || message.length == 0) &#123; System.out.println(\"无参\"); return; &#125; for (String seq : message) &#123; System.out.println(seq); &#125;&#125;/*** 不定项参数** @param str* @param message*/static void print(String str, String... message) &#123; for (String seq : message) &#123; System.out.println(seq); &#125;&#125; 1234//测试代码print(); //无参，调用print(String... message)print(\"Hello world!\"); //一个参数，调用固定参数方法print(String message)print(\"Hello\", \"world\"); //编译器报错：Ambiguous method call. Both print(String... message) and (String str, String... message) in IndefiniteParameter match 静态导入介绍 import导入程序所需的类 import static导入一个类的静态方法和静态变量（JDK5开始引入） import static java.lang.Math.pow; import static java.lang.System.out; 要点import static导入一个类的静态方法和静态变量： 少使用 * 通配符，最好具体到静态变量或方法 静态方法名具有明确特征，如有重名，需要补充类名","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"}],"tags":[{"name":"不定项参数","slug":"不定项参数","permalink":"https://lao-biao.github.io/tags/%E4%B8%8D%E5%AE%9A%E9%A1%B9%E5%8F%82%E6%95%B0/"},{"name":"静态导入","slug":"静态导入","permalink":"https://lao-biao.github.io/tags/%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5/"}]},{"title":"Java语法糖for-each和枚举","slug":"Java语法糖--for-each和枚举","date":"2020-04-19T14:56:58.000Z","updated":"2020-07-06T03:37:48.167Z","comments":true,"path":"articles/6d197383.html","link":"","permalink":"https://lao-biao.github.io/articles/6d197383.html","excerpt":"","text":"for-each for-each从JDK5.0开始引入 避免越界错误 123for(Object object:Set)&#123; object //元素&#125; for与 for-each对比 for可以删除元素，for-each不可以删除/替换元素 for-each遍历的时候，是不知道当前元素的具体位置索引 for-each只能正向遍历，不能反向遍历 for-each不能同时遍历2个或以上的集合 for和for-each性能接近 枚举 枚举变量：变量的取值只在一个有限的集合内 Java5推出enum类型 enum关键字声明枚举类，且都是Enum的子类（不需要加extends） enum内部有多个值，就有多少个实例对象 不能直接new枚举类对象 123public enum State &#123; SUCCESS, LOADING, NETWORK_ERROR, EMPTY, NONE;&#125; Java的enum类型 除了枚举的内容，还可以添加属性/构造函数/方法 处构造函数只能是package-private(default)或者private，内部调用 关键字 同一个类 同一个包 不同包的子类 不同包的非子类 private √ - - - default √ √ - - protected √ √ √ - public √ √ √ √ 123456789101112enum Fruit &#123; APPLE(10), ORANGE(8); private int price; //属性 Fruit(int price) &#123; this.price = price; &#125; public int getPrice() &#123; return this.price; &#125;&#125; Java的enum类型：所有的enum类型属于Enum的子类，也继承了相应的方法 ordinal() 返回枚举值所在的索引位置，从0开始 compareTo() 比较两个枚举值的索引位置大小 toString() 返回枚举值的字符串表示 Enum.valueOf() 将字符串初始化为枚举对象 values() 返回所有的枚举值 枚举类型限定取值集合，减少实例对象","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"}],"tags":[{"name":"for-each","slug":"for-each","permalink":"https://lao-biao.github.io/tags/for-each/"},{"name":"枚举","slug":"枚举","permalink":"https://lao-biao.github.io/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"Android自定义工具类--toast utils","slug":"Android自定义工具类--toast utils","date":"2020-04-19T13:34:50.000Z","updated":"2020-07-06T03:10:21.292Z","comments":true,"path":"articles/34a9fe48.html","link":"","permalink":"https://lao-biao.github.io/articles/34a9fe48.html","excerpt":"","text":"前言在频繁调用Toast会造成较长的延时，不能及时显示最新的toast信息，使用ToastUtils解决延时bug 介绍BaseApplication.getAppContext()见文章–Android子线程更新ui 使用：ToastUtils.showToast(message); 代码12345678910111213public class ToastUtils &#123; private static Toast sToast; @SuppressLint(\"ShowToast\") public static void showToast(String message) &#123; if (sToast == null) &#123; //如果不存在就创建 sToast = Toast.makeText(BaseApplication.getAppContext(), \"\", Toast.LENGTH_SHORT); &#125; sToast.setText(message); //设置内容 sToast.show(); //显示toast内容 &#125;&#125;","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"toast","slug":"toast","permalink":"https://lao-biao.github.io/tags/toast/"}]},{"title":"Android自定义工具类--logutils","slug":"Android自定义工具类-logutils","date":"2020-04-19T13:22:28.000Z","updated":"2020-07-06T03:10:13.787Z","comments":true,"path":"articles/c3843c50.html","link":"","permalink":"https://lao-biao.github.io/articles/c3843c50.html","excerpt":"","text":"前言Android项目中通常会使用log来进行调试，在发布版本后并不需要输出log，使用logutils类来控制log的输出管理 简介在应用调试阶段设置当前log等级大于或等于debug等级，即可输出debug，info，warming和error四个等级的log 在应用发布时只需要将当前log等级调整为0或小于0即可关闭log的输出 参数 object： 类对象(this或ClassName.this) message： log信息 代码123456789101112131415161718192021222324252627282930313233public class LogUtils &#123; private static final int CURRENT_LEV = 4; //当前log等级 private static final int DEBUG_LEV = 4; //debug private static final int INFO_LEV = 3; //info private static final int WARMING_LEV = 2; //warming private static final int ERROR_LEV = 1; //error public static void d(Object object, String message) &#123; if (CURRENT_LEV &gt;= DEBUG_LEV) &#123; Log.d(object.getClass().getSimpleName(), message); &#125; &#125; public static void i(Object object, String message) &#123; if (CURRENT_LEV &gt;= INFO_LEV) &#123; Log.i(object.getClass().getSimpleName(), message); &#125; &#125; public static void w(Object object, String message) &#123; if (CURRENT_LEV &gt;= WARMING_LEV) &#123; Log.w(object.getClass().getSimpleName(), message); &#125; &#125; public static void e(Object object, String message) &#123; if (CURRENT_LEV &gt;= ERROR_LEV) &#123; Log.e(object.getClass().getSimpleName(), message); &#125; &#125;&#125;","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"log","slug":"log","permalink":"https://lao-biao.github.io/tags/log/"}]},{"title":"git常用指令","slug":"git常用指令","date":"2020-04-19T10:57:06.000Z","updated":"2020-07-06T03:11:32.900Z","comments":true,"path":"articles/c34887c6.html","link":"","permalink":"https://lao-biao.github.io/articles/c34887c6.html","excerpt":"基本配置git config --global user.name &quot;Your Name&quot;设置用户名 git config --global user.email &quot;email@example.com&quot;设置邮箱 初始化git init初始化生成.git文件 查看本地仓库状态git status查看本地仓库状态 连接远程仓库git remote add origin https://github.com/xxxxx/demo.git连接远程仓库 克隆git clone https://github.com/xxxxx/demo.git directory 从远程仓库克隆到文件夹中，默认路径为当前路径","text":"基本配置git config --global user.name &quot;Your Name&quot;设置用户名 git config --global user.email &quot;email@example.com&quot;设置邮箱 初始化git init初始化生成.git文件 查看本地仓库状态git status查看本地仓库状态 连接远程仓库git remote add origin https://github.com/xxxxx/demo.git连接远程仓库 克隆git clone https://github.com/xxxxx/demo.git directory 从远程仓库克隆到文件夹中，默认路径为当前路径 添加文件/文件夹touch filename在本地仓库添加文件 git add filename添加文件至暂存区 git add -f filename 添加文件夹至暂存区 git add . 添加目录下所有发生改变的文件至暂存区 git commit -m &#39; &#39;添加到工作区，提交注释信息 拉取git fetch从远程仓库获取目录(head)信息 git pull 从远程仓库获取到本地仓库，获取的是代码 git pull --rebase origin master 解决本地缺少README.md文件问题，远程仓库在初始化时添加了README.md文件 git pull origin master --allow-unrelated-histories 把远程仓库和本地同步，消除差异 推送pushgit push推送到远程仓库 git push -u origin master 本地仓库代码提交至远程仓库，第一次推送到远程仓库必须使用 查看commit日志git log返回commit的hash值，以及commit信息 撤回git reset的三种操作： git reset --soft xxxx(commit操作的hash值)将文件提交至本地仓库后撤回暂存区 git reset --mixed xxxx(commit操作的hash值) 将本地仓库文件撤回至工作区 git reset --hard xxxx(commit操作的hash值) 将工作区、暂存区、本地仓库的所有提交的文件全都撤销（包括工作区文件，会删除） 分支git branch temp 创建分支temp git checkout temp 使用分支temp git merge temp 合并分支到当前分支 git branch -D temp删除分支temp 其他ll显示当前路径下的所有文件及其属性 cd切换路径 cd ../切换至上一层路径 pwd 查看当前全路径 官方文档git官方文档","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://lao-biao.github.io/tags/git/"}]},{"title":"hexo添加RSS订阅功能","slug":"hexo添加RSS订阅功能","date":"2020-04-17T05:25:53.000Z","updated":"2020-07-06T03:13:05.956Z","comments":true,"path":"articles/b9d63583.html","link":"","permalink":"https://lao-biao.github.io/articles/b9d63583.html","excerpt":"","text":"安装插件在博客根目录下运行 npm install hexo--generator-feed 安装过淘宝镜像可使用 cnpm install hexo--generator-feed 命令 配置在根目录下的_config.yml文件中添加下列代码 123456789# Extensions#RSS订阅plugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml # 生成路径 limit: 20 # 最新的20篇文章 在主题目录下的_config.yml文件中添加下列代码 123# subNav-子导航subNav: rss: \"/atom.xml\" # 或 \"atom.xml\" ，这个路径与path一致 生成文件在博客根目录下重新渲染 hexo g 12345$ hexo gINFO Start processingINFO Files loaded in 955 msINFO Generated: atom.xml # 生成atom.xml文件INFO 1 files generated in 933 ms 在public文件夹下生成atom.xml 本地预览：hexo s 点击RSS会跳转保存窗口 推送到远程仓库：hexo d 点击RSS跳转到atom.xml页面","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lao-biao.github.io/categories/hexo/"}],"tags":[{"name":"rss","slug":"rss","permalink":"https://lao-biao.github.io/tags/rss/"}]},{"title":"java数据结构与算法--排序","slug":"java数据结构与算法-排序","date":"2020-04-13T02:08:34.000Z","updated":"2020-07-06T03:34:17.657Z","comments":true,"path":"articles/765a6dde.html","link":"","permalink":"https://lao-biao.github.io/articles/765a6dde.html","excerpt":"排序排序基本概念排序排序是将一个数据元素的任意序列，重新排列成一个按关键字有序的序列 内部排序和外部排序内部排序：整个排序过程在内存储器中进行 外部排序：待排序元素量太大，内存储器无法容纳全部数据，排序需要借助外部存储设备才能完成 稳定排序和不稳定排序如果在待排序的序列中存在多个具有相同关键字的元素 假设Ki=Kj { 1≤i≤n，1≤j≤n，i≠j }，排序前序列中的Ri在Rj之前，经过排序后得到的序列Ri仍在Rj之前，则称所用排序方法是稳定的，反之则是不稳定的 比较排序和非比较排序大部分排序需要通过比较来判断大小，作为排序的依据，而计数排序、基数排序不需要进行比较 其他排序 插入排序：将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度 交换排序：通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度 选择排序：从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度 归并排序：通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度","text":"排序排序基本概念排序排序是将一个数据元素的任意序列，重新排列成一个按关键字有序的序列 内部排序和外部排序内部排序：整个排序过程在内存储器中进行 外部排序：待排序元素量太大，内存储器无法容纳全部数据，排序需要借助外部存储设备才能完成 稳定排序和不稳定排序如果在待排序的序列中存在多个具有相同关键字的元素 假设Ki=Kj { 1≤i≤n，1≤j≤n，i≠j }，排序前序列中的Ri在Rj之前，经过排序后得到的序列Ri仍在Rj之前，则称所用排序方法是稳定的，反之则是不稳定的 比较排序和非比较排序大部分排序需要通过比较来判断大小，作为排序的依据，而计数排序、基数排序不需要进行比较 其他排序 插入排序：将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度 交换排序：通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度 选择排序：从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度 归并排序：通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度 交换排序冒泡排序算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现123456789101112131415161718/*** 冒泡排序* 按小到大排序** @param array 待排序数组*/public static void bubbleSort(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; &#125; &#125; System.out.println(Arrays.toString(array)); //输出当前排序 &#125;&#125; 测试代码： 1234567891011int[] arr = &#123;9, 8, 7, 6, 5, 4, 3, 2, 1&#125;;bubbleSort(arr);//输出[8, 7, 6, 5, 4, 3, 2, 1, 9][7, 6, 5, 4, 3, 2, 1, 8, 9][6, 5, 4, 3, 2, 1, 7, 8, 9][5, 4, 3, 2, 1, 6, 7, 8, 9][4, 3, 2, 1, 5, 6, 7, 8, 9][3, 2, 1, 4, 5, 6, 7, 8, 9][2, 1, 3, 4, 5, 6, 7, 8, 9][1, 2, 3, 4, 5, 6, 7, 8, 9] 快速排序快速排序是冒泡排序的改进版，也是最好的一种内排序，涉及到分治和递归 分治法(Dvide-and-Conquer Method) 算法步骤： 从数列中去一个数作为基准数（简单起见可以取第一个数） 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到他的左边（分区） 再对左右区间重复第一步、第二步，直到各区间只有一个数（递归） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void quickSort(int[] array) &#123; int start = 0; int end = array.length - 1; quickSort(array, start, end);&#125;/*** 快速排序递归部分** @param array 待排数组* @param start * @param end */private static void quickSort(int[] array, int start, int end) &#123; if (start &lt; end) &#123; //递归结束条件 //从数列中取一个数作为基准数（简单起见取第一个数） int base = array[start]; int pLeft = start; //左指针 int pRight = end; //右指针 //分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到他的左边（**分区**） while (pLeft &lt; pRight) &#123; //pLeft!=pRight //从右到左，找到第一个小于基准值的值，将其移动到左指针的位置，并左指针+1 while (pRight &gt; pLeft) &#123; if (array[pRight] &lt; base) &#123; array[pLeft] = array[pRight]; pLeft++; break; &#125; pRight--; &#125; //从左到右，找到第一个大于基准值的值，将其移动到右指针的位置，并右指针-1 while (pLeft &lt; pRight) &#123; if (array[pLeft] &gt; base) &#123; array[pRight] = array[pLeft]; pRight--; break; &#125; pLeft++; &#125; &#125; //基准值填坑 array[pLeft] = base; //对左区间快排 quickSort(array, start, pLeft - 1); //对右区间快排 quickSort(array, pRight + 1, end); &#125;&#125; 测试代码 12345int[] arr = &#123;4, 2, 8, 6,10, 1, 3, 7, 9, 5&#125;;quickSort(arr); //快速排序System.out.println(Arrays.toString(arr)); //输出[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 选择排序基本选择排序算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 代码实现12345678910111213141516171819202122232425/*** 选择排序* @param array*/public static void selectionSort(int[] array) &#123; // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; array.length - 1; i++) &#123; int min = i; //记录最小值的位置 // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125;&#125; 测试代码 12345int[] arr = &#123;8, 3, 10, 6, 4, 1, 2, 7, 9, 5&#125;;selectionSort(arr);System.out.println(Arrays.toString(arr));//输出[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 插入排序直接插入排序算法步骤将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 代码实现12345678910111213141516171819202122232425/*** 插入排序* @param array*/public static void insertSort(int[] array) &#123; // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; array.length; i++) &#123; // 记录要插入的数据 int temp = array[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; temp &lt; array[j - 1]) &#123; array[j] = array[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; array[j] = temp; &#125; &#125;&#125; 测试代码 12345int[] arr = &#123;2, 3, 10, 9, 4, 8, 1, 7, 6, 5&#125;;insertSort(arr);System.out.println(Arrays.toString(arr));//输出[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 二分法插入排序算法在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。 二分法查找插入位置 后移 插入 [2, 3, 10, 9, 4, 8, 1, 7, 6, 5] [2, 3, 10, 9, 4, 8, 1, 7, 6, 5][2, 3, 10, 9, 4, 8, 1, 7, 6, 5][2, 3, 9, 10, 4, 8, 1, 7, 6, 5][2, 3, 4, 9, 10, 8, 1, 7, 6, 5][2, 3, 4, 8, 9, 10, 1, 7, 6, 5][1, 2, 3, 4, 8, 9, 10, 7, 6, 5][1, 2, 3, 4, 7, 8, 9, 10, 6, 5][1, 2, 3, 4, 6, 7, 8, 9, 10, 5][1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 时间复杂度：O(n2) 空间复杂度：O(1) 代码1234567891011121314151617181920public static void binaryInsertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; //要操作的数 int low = 0; int high = i - 1; int mid = -1; while (low &lt;= high) &#123; mid = (low + high) / 2; if (temp &gt; arr[mid]) low = mid + 1; else high = mid - 1; &#125; //从后往前移动数组，直到temp要插入的位置 for (int j = i - 1; j &gt;= low; j--) arr[j + 1] = arr[j]; //插入 arr[low] = temp; &#125;&#125; 测试代码 12345int[] arr = &#123;2, 3, 10, 9, 4, 8, 1, 7, 6, 5&#125;;binaryInsertSort(arr);System.out.println(Arrays.toString(arr));//输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 各种排序比较排序类型 排序效率 各种常用排序算法 类别 排序方法 时间复杂度 空间复杂度 稳定性 平均情况 最好情况 最坏情况 辅助存储 插入排序 直接插入 O(n2) O(n) O(n2) O(1) 稳定 希尔排序 O(n1.3)或O(nlog2n) O(n) O(n2) O(1) 不稳定 选择排序 直接选择 O(n2) O(n2) O(n2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 交换排序 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) 链表：O(1)或数组：O(n) 稳定 基数排序 O(d(r+n)) O(d(n+rd)) O(d(r+n)) O(rd+n) 稳定 注：基数排序的算法复杂度中，r代表关键字的基数，d代表长度，n代表关键字的个数 菜鸟教程十大经典排序算法 相关代码下载代码","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://lao-biao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"java数据结构与算法--查找","slug":"java数据结构与算法-查找","date":"2020-04-12T08:59:53.000Z","updated":"2020-07-06T03:33:45.019Z","comments":true,"path":"articles/e1d5c8a7.html","link":"","permalink":"https://lao-biao.github.io/articles/e1d5c8a7.html","excerpt":"查找线性表查找顺序查找存储结构：顺序表或链表 逐个比较查询，如果找到，返回数据或索引，如果最后没找到就返回null 在各个结点查找概率相同情况下，平均查询长度为表的一半长度，所以时间复杂度T(n)=O(n) 1234567891011121314151617181920212223/*** 顺序查找* 功能：在数组中查找指定的值，返回返回第一个匹配到的索引值** 所求的值存在，返回第一个匹配到的索引值* 所求的值不存在，返回-1** 时间复杂度：T(n)=O(n)* 空间复杂度：S(n)=O(1)* @param array 查找表* @param value 所求的值* @return*/public static int orderSearch(int[] array, int value) &#123; int index = -1; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == value) &#123; index = i; break; //去除break则返回最后一个匹配到的值的位置 &#125; &#125; return index;&#125;","text":"查找线性表查找顺序查找存储结构：顺序表或链表 逐个比较查询，如果找到，返回数据或索引，如果最后没找到就返回null 在各个结点查找概率相同情况下，平均查询长度为表的一半长度，所以时间复杂度T(n)=O(n) 1234567891011121314151617181920212223/*** 顺序查找* 功能：在数组中查找指定的值，返回返回第一个匹配到的索引值** 所求的值存在，返回第一个匹配到的索引值* 所求的值不存在，返回-1** 时间复杂度：T(n)=O(n)* 空间复杂度：S(n)=O(1)* @param array 查找表* @param value 所求的值* @return*/public static int orderSearch(int[] array, int value) &#123; int index = -1; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == value) &#123; index = i; break; //去除break则返回最后一个匹配到的值的位置 &#125; &#125; return index;&#125; 折半查找(二分查找)待查的查找表满足条件： 顺序存储结构 查找表按关键字大小有序排列 递归实现折半查找1234567891011121314151617181920212223242526/*** 二分查找--递归*时间复杂度：T(n)=O(log2 n)*空间复杂度：S(n)=O(log2 n)* @param array* @param value* @return*/public static int binarySearchByRecursion(int[] array, int value) &#123; //指定low和high int low = 0; int high = array.length - 1; return binarySearchByRecursion(array, value, low, high);&#125;public static int binarySearchByRecursion(int[] array, int value, int low, int high) &#123; if (low &gt; high) //递归结束条件--没找到 return -1; int middle = (low + high) / 2; if (value == array[middle]) //递归结束条件--找到 return middle; else if (value &lt; array[middle]) return binarySearchByRecursion(array, value, low, middle); else return binarySearchByRecursion(array, value, middle, high);&#125; 非递归实现折半查找12345678910111213141516171819202122232425262728293031/*** 二分查找* 功能：在数组中查找指定的值，返回返回第一个匹配到的索引值* &lt;p&gt;* 所求的值存在，返回第一个匹配到的索引值* 所求的值不存在，返回-1* &lt;p&gt;* 时间复杂度：T(n)=O(log2 n)* 空间复杂度：S(n)=O(n)** @param array 有序表* @param value 所求值* @return*/public static int binarySearch(int[] array, int value) &#123; //指定low和high int low = 0; int high = array.length - 1; //二分查找 while (low &lt;= high) &#123; //求得middle int middle = (low + high) / 2; if (array[middle] == value) //判断是否等于 return middle; else if (array[middle] &gt; value) //在小的部分 high = middle - 1; else //在大的部分 low = middle + 1; &#125; return -1;&#125; 查找树二叉查找/搜索/排序树 BST (binary search/sort tree) 一颗空树 具有以下性质的二叉树： 若它的左子树不为空，则左子树上所有结点均小于它的根结点的值 若它的右子树不为空，则右子树上所有结点均大于它的根结点的值 它的左、右子树也分别为二叉排序树 对二叉查找树进行中序遍历，得到有序集合 平衡二叉树(Self-balancing binary search tree)自平衡二叉查找树，AVL树 一颗空树 具有以下性质的二叉树： 它的左右两个子树的高度差(平衡因子)的绝对值不超过1 左右两个子树都是一颗平衡二叉树 平衡二叉树必定是二叉搜索树，但二叉搜索树不一定是平衡树 平衡因子(平衡度)结点的平衡因子是结点的左子树减去右子树的高度 平衡二叉树定义：每个结点的平衡因子都为1,-1,0的二叉排序树 目的是减少二叉查找树的层次，提高查找速度 百度百科：平衡二叉树 实现方法AVL、红黑树RBT、替罪羊树、Treap、伸展树Splay、SBT 平衡树平衡树 B-树：在它内部结点中存储键值，但不需在叶子结点上存储这些键值的记录 B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引，B+树总是到叶子结点才命中 数据库的索引的默认数据结构就是采用B+树 B*树：B+树的变体，在B+树的非根和非子叶结点再增加指向兄弟的指针 哈希表查找哈希表不需要通过关键字值与定值比较，来确定位置，根据定值能直接定位记录的存储位置 哈希表的结构和特点hashtable：散列表 特点： 添加、查询、删除、更新数据快 无序 唯一 结构（多种）： 顺序表+链表：主结构是顺序表，每个顺序表的结点在单独引出一个链表 哈希表初始操作状态 哈希表添加数据 计算哈希码(调用hashCode()），结果是一个int值，整数的哈希码取自身即可 计算在哈希表中的存储位置 y = k(x) = x % 11 x:哈希码，k(x):函数，y:在哈希表的存储位置 存入哈希表 一次添加成功 多次添加成功（出现冲突，调用equals()和对应链表的元素进行比较，比较到最后，结果都是false，创建新结点，存储数据，并加入链表末尾） 不添加（出现冲突，调用equals()和对应的元素进行比较，经过一次或多次比较后，结果都是true，表明重复，不添加） 哈希表最终状态 哈希表查找、删除、更新查找：与添加相似，通过函数计算对应位置 删除：改变直接前驱结点指向直接后继结点 更新：先查找到位置，更新数据 hashCode与equalshashCode()：计算哈希码，根据哈希码可以计算出数据在哈希表中的存储位置 equals()：添加时出现冲突和查询时，通过equals()进行比较，判断是否相同 各种类型数据的哈希码的获取 数据类型 方法 int 取自身 double long bits=doubleToLongBits(value);(int)(bits ^ (bits &gt;&gt;&gt; 32)); String int h=hash;if(h==0 &amp;&amp; value.length &gt; 0){ char var[] = value; for(int i=0; i&lt;value.length; i++){ h = 31 * h + val[i]; } hash=h;}return hash; 对象 各个属性的哈希码进行某些相加相乘的运算 减少冲突 哈希表的长度和表中的记录数的比例–装填因子： 根据最终记录存储个数和关键字的分布特点来确定哈希表大小 动态变化装填因子 = 表中的记录的数 / 哈希表的长度 装填因子越小，表中还有很多的空单元，则添加发生冲突的可能性越小 装填因子越小，发生冲突可能性越大，在查找时所耗费的事件越多 装填因子=0.5时，哈希表性能能达到最优 哈希函数的选择： 直接定址法，平方取中法，折叠法，除留去余法(y= x % 11) 处理冲突方法： 链地址法，开放地址法，再散列法，建立一个公共溢出区 Java中的查找树和哈希表TreeSet和TreeMapTreeSet和TreeMap底层使用红黑树 TreeSet底层结构是TreeMap 添加结点过程会通过旋转等方法，保证每次添加前后都是平衡树 HashSet HashMap HashTable(过时)HashSet HashMap HashTable底层使用哈希表 在JDK1.7及其之前，HashMap存储结构为：table数组+链表 在JDK1.8中，当链表的存储数据个数大于等于8时，不再采用链表存储，而采用红黑树存储结构（在查询时间复杂度上：链表为O(n),红黑树为O(lon2n)） HashSet底层结构是HashMap，HashSet的元素作为HashMap的key，统一使用Object对象作为value 1234567/*** HashSet部分源码*/private static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 相关代码下载相关代码","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"查找","slug":"查找","permalink":"https://lao-biao.github.io/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"java数据结构与算法--图","slug":"java数据结构与算法-图","date":"2020-04-11T13:59:01.000Z","updated":"2020-07-06T03:34:33.454Z","comments":true,"path":"articles/c88bf7ec.html","link":"","permalink":"https://lao-biao.github.io/articles/c88bf7ec.html","excerpt":"图图的定义图的基本概念：多对多关系图(graph)是一种网状数据结构，图是由非空的顶点集合和一个描述之间关系的集合组成 形式化定义： Graph = (V,E) V={x | x∈某个数据对象} E={&lt;u,v&gt; | P(u,v)^(u,v∈V)} V是具有相同特性的数据元素的集合，V中数据元素通常称为顶点(Vertex) E是两个顶点之间的集合，P(u,v)表示u和v之间有特定的关联属性 若&lt;u,v&gt;∈E，则&lt;u,v&gt;表示从顶点u到顶点v的一条弧，并称u为弧尾或起始点，称v为弧头或终止点，此时图的顶点之间的连线是有方向的，称之为有向图(directed graph) 若&lt;u,v&gt;∈E，则必有&lt;v,u&gt;∈E，即关系是对称的，此时可以使用一个无序对(u,v)来代替两个有序对，它表示顶点u和顶点v之间的一条边，此时图中顶点之间的连线是没有方向的，称之为无向图(undirected graph)","text":"图图的定义图的基本概念：多对多关系图(graph)是一种网状数据结构，图是由非空的顶点集合和一个描述之间关系的集合组成 形式化定义： Graph = (V,E) V={x | x∈某个数据对象} E={&lt;u,v&gt; | P(u,v)^(u,v∈V)} V是具有相同特性的数据元素的集合，V中数据元素通常称为顶点(Vertex) E是两个顶点之间的集合，P(u,v)表示u和v之间有特定的关联属性 若&lt;u,v&gt;∈E，则&lt;u,v&gt;表示从顶点u到顶点v的一条弧，并称u为弧尾或起始点，称v为弧头或终止点，此时图的顶点之间的连线是有方向的，称之为有向图(directed graph) 若&lt;u,v&gt;∈E，则必有&lt;v,u&gt;∈E，即关系是对称的，此时可以使用一个无序对(u,v)来代替两个有序对，它表示顶点u和顶点v之间的一条边，此时图中顶点之间的连线是没有方向的，称之为无向图(undirected graph) 在无向图和有向图中V的元素都称为顶点，而顶点之间的关系却又不同的称谓，即弧或边，在不影响理解的前提下，统称为边(edge) 顶点集与边集都是有限的，并记顶点与边的数量为|V|和|E| 无向图实际上也是有向图，是双向图 带权图：图的每条边都与它相关的实数，称之为权，这些权值可以并表示一个顶点到另一个顶点的距离或消耗等信息，这种边上具有权值的图称为带权图(weighted graph) 图的存储邻接矩阵二维数组（顺序存储结构），无向图关于对角线对称 邻接表链表（链式存储结构） 图的遍历图的遍历：从图中某个顶点出发，按某种方法对图中所有顶点访问且仅访问一次 图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础 深度优先排序(DFS depth-first search)：类似于树的先根排序，是树的先根遍历的推广（可采用递归和借助栈的非递归方式实现） 广度优先排序(BFS breadth-first search)：类似于树的层次遍历，是树的按层次遍历的推广（借助队列的非递归方式实现） 无向图的深度优先遍历：0-&gt;1-&gt;3-&gt;7-&gt;4-&gt;2-&gt;5-&gt;6 无向图的广度优先遍历：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 无向图的深度优先遍历：A-&gt;B-&gt;E-&gt;F-&gt;C-&gt;D-&gt;G-&gt;H-&gt;I 无向图的广度优先遍历：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;I 最短路径最短路径概念带权图两点之间的最小消耗路径 段数最少的最短路径：类似于树的层次遍历，需要借助队列来实现（广度优先搜索） 算法：对于已经检查过结点，标记为已检查，且不再检查它，可以使用另一个列表存放已经检查过的结点，找到即为可达，第一次找到，即为跳转最少，如果到最后队列为空，则表明没有路径可以到达 权值最小的最短路径：权值之和最小，狄克斯特拉算法 狄克斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。 狄克斯特拉算法思路该算法复杂度为$n^2$,我们可以发现，如果边数远小于$n^2$,对此可以考虑用堆这种数据结构进行优化，取出最短路径的复杂度降为O(1)；每次调整的复杂度降为$O（e log_2 n）$；e为该点的边数，所以复杂度降为$O((m+n)log_2 n)$。 实现 将源点加入堆，并调整堆 选出堆顶元素u（即代价最小的元素），从堆中删除，并对堆进行调整 处理与u相邻的，未被访问过的，满足三角不等式的顶点 若该点在堆里，更新距离，并调整该元素在堆中的位置 若该点不在堆里，加入堆，更新堆 若取到的u为终点，结束算法；否则重复步骤2、3 12345678910111213141516171819202122232425262728293031323334353637383940414243//假设起点为src, 终点为dst, 图以二维矩阵的形式存储，若graph[i][j] == 0, 代表i,j不相连 //visit[i] == 0,代表未访问,visit[0] == -1代表已访问 public int Dijkstra(int src, int dst, int[][] graph,int[] visit)&#123; //节点个数 int n = graph.length; PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;(new Node()); //将起点加入pq pq.add(new Node(src, 0)); while (!pq.isEmpty())&#123; Node t = pq.poll(); //当前节点是终点，即可返回最短路径 if(t.node == dst) return t.cost; //t节点表示还未访问 if (visit[t.node]==0)&#123; //将节点设置为已访问 visit[t.node] = -1; //将当前节点相连且未访问的节点遍历 for (int i = 0; i &lt; n; i++) &#123; if (graph[t.node][i]!=0 &amp;&amp; visit[i]==0) &#123; pq.add(new Node(i, t.cost + graph[t.node][i])); &#125; &#125; &#125; &#125; return -1; &#125; //定义一个存储节点和离起点相应距离的数据结构 class Node implements Comparator&lt;Node&gt; &#123; public int node; public int cost; public Node()&#123;&#125; public Node(int node, int cost)&#123; this.node = node; this.cost = cost; &#125; @Override public int compare(Node node1, Node node2)&#123; return node1.cost-node2.cost; &#125; &#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图","slug":"图","permalink":"https://lao-biao.github.io/tags/%E5%9B%BE/"}]},{"title":"hexo实现置顶文章","slug":"hexo实现置顶文章","date":"2020-04-11T03:18:24.000Z","updated":"2020-07-06T03:12:52.034Z","comments":true,"path":"articles/28f80600.html","link":"","permalink":"https://lao-biao.github.io/articles/28f80600.html","excerpt":"hexo置顶文章安装插件在博客根目录下运行： 123npm uninstall hexo-generator-index --save #卸载index渲染器npm install hexo-generator-index-pin-top --save #安装置顶插件#安装淘宝的镜像可以使用 cnpm 代替 npm 配置置顶标准在/themes/所使用的主题名/layout/post.ejs文件最前面添加下列代码 123456&lt;% if (page.top) &#123; %&gt; &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt; &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt; &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;&lt;% &#125; %&gt;... 文章配置在需要置顶的文章的Front Matter部分添加 top: number number的数值越大优先级越高 12345---title: date: YYYY-MM-DD HH:mm:sstop: 2--- 优先级配置修改根目录配置文件/_config.yml,top值-1根据top值倒序 123456index_generator: path: '' per_page: 6 #每页显示的文章数 order_by: top: -1 #按top倒序排列，number越大的优先显示 date: -1 #按时间倒序排列，最新的优先显示","text":"hexo置顶文章安装插件在博客根目录下运行： 123npm uninstall hexo-generator-index --save #卸载index渲染器npm install hexo-generator-index-pin-top --save #安装置顶插件#安装淘宝的镜像可以使用 cnpm 代替 npm 配置置顶标准在/themes/所使用的主题名/layout/post.ejs文件最前面添加下列代码 123456&lt;% if (page.top) &#123; %&gt; &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt; &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt; &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;&lt;% &#125; %&gt;... 文章配置在需要置顶的文章的Front Matter部分添加 top: number number的数值越大优先级越高 12345---title: date: YYYY-MM-DD HH:mm:sstop: 2--- 优先级配置修改根目录配置文件/_config.yml,top值-1根据top值倒序 123456index_generator: path: '' per_page: 6 #每页显示的文章数 order_by: top: -1 #按top倒序排列，number越大的优先显示 date: -1 #按时间倒序排列，最新的优先显示 效果图 参考文章Hexo yilia 配置–置顶文章部分","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lao-biao.github.io/categories/hexo/"}],"tags":[]},{"title":"java数据结构与算法--树和二叉树","slug":"java数据结构与算法-树和二叉树","date":"2020-04-10T13:30:09.000Z","updated":"2020-07-06T03:34:24.267Z","comments":true,"path":"articles/49f58aa9.html","link":"","permalink":"https://lao-biao.github.io/articles/49f58aa9.html","excerpt":"树和二叉树树的基本概念树树是由一个集合以及在该集合上定义的一种关系构成的，集合中的元素称为树的结点，所定义的关系称为父子关系 父子关系在书的结点之间建立了一个层次结构 树的结点包含一个数据元素及若干指向其子树的若干分支 特殊位置的结点，树的根结点，简称为树根 树是n（n≥0）个结点的有限集 n=0 空树，不包含任何结点 n&gt;0 非空树，有且仅有一个特定的称为根（root）的结点","text":"树和二叉树树的基本概念树树是由一个集合以及在该集合上定义的一种关系构成的，集合中的元素称为树的结点，所定义的关系称为父子关系 父子关系在书的结点之间建立了一个层次结构 树的结点包含一个数据元素及若干指向其子树的若干分支 特殊位置的结点，树的根结点，简称为树根 树是n（n≥0）个结点的有限集 n=0 空树，不包含任何结点 n&gt;0 非空树，有且仅有一个特定的称为根（root）的结点 结点的度与树的度结点拥有的子树的数目称为结点的度（Degree） 度为0的结点称为叶子（leaf）或终端结点 度不为0的结点称为非终端节点或分支结点，除根之外的分支结点也称为内部结点 树内各结点的度的最大值称为树的度 结点的层次与树的深度结点的层次从根开始定义，层次数为1的结点是根节点，其子树的根的层次数为2 树中的结点的最大层次数为树的深度或高度 父亲 儿子 兄弟父亲：一个结点的直接前驱结点 儿子：一个结点的直接后继结点 兄弟：同一个父亲结点的其他结点 祖先 子孙 堂兄弟结点的祖先是从根结点到该点路径上的所有结点 以某结点为根的树中的任一结点都称为该点的子孙 父亲在同一层次的结点互为堂兄弟 有序树 m叉树 森林如果将树中结点的各子树看成是从左至右是有次序的，则称该树为有序树 若不考虑子树的顺序则称为无序树 有序树的子树之间不能互换位置 m叉树：树中所有结点最大度数为m的有序树 森林：m(m≥0)棵互不相交的树的集合，对树中每个结点而言，其子树的集合即为森林 树和森林的概念相近 树→森林：删除一棵树的根，就可以得到一个森林 森林→树：加上一个结点作为树根，森林就变成一棵树 二叉树二叉树概念二叉树：每个结点的度均不超过2的有序树 二叉树的递归定义：二叉树或者是一颗空树，或是由一个根结点和两颗互不相交的分别称为根的左子树和右子树的子树所组成的非空树 二叉树每个结点的孩子数只能是0、1或2，并且每个孩子都有左右之分 位于左边的孩子称为左孩子，位于右边的孩子称为右孩子 以左孩子为根的子树称为左子树，以右孩子为根的子树称为右子树 满二叉树高度为k并且由2k+1-1个结点的二叉树 在满二叉树中，每层结点都达到最大数，即每层节点都是满的 完全二叉树若在一颗满二叉树中，在最下层从最右侧起去掉相邻若干的若干叶子结点，得到的二叉树即为完全二叉树 满二叉树必为完全二叉树，而完全二叉树不一定是满二叉树 二叉树性质 在二叉树的第i层上最多有2i-1个结点(根是第1层) 高度为h的二叉树至多有2h-1个结点 对任何一棵二叉树T ,如果其终端结点数为n0, 度为2的结点数为n2，则n0 = n2+ 1 有n个结点的完全二叉树的高度为 log2n + 1 ,其中 log2n 是向下取整 含有n≥1个结点的二叉树的高度至多为n-1 ;高度至少为 log2n + 1 ,其中 log2n是向下取整 如果对-棵有n个结点的完全二叉树的结点进行编号,则对任结点i( 1≤i≤n ), 有 如果i=1,则结点i是二叉树的根,无双亲;如果i&gt;1 ,则其双亲结点PARENT(i)是结点 i/2 如果2i&gt;n.则结点i无左孩子;否则其左孩子是结点2i 如果2i+1&gt;n,则结点i无右孩子;否则其右孩子是结点2i+1 二叉树的存储结构顺序存储结构对于满二叉树和完全二叉树来说，可以将其数据元素逐层存放到一组连续的存储单元中 用一维数组来实现顺序存储结构时，将二叉树中变好为i的结点存放到数组的第i个分量中 根据二叉树的性质，可以得到结点i的父节点、左右孩子节点分别存放在2i以及2i+1分量中 满二叉树和完全二叉树才用顺序存储结构既不浪费空间，也可通过公式很快地确定结点之间的关系 一般二叉树：必须用”虚结点”将二叉树补成一棵满二叉树来存储（浪费空间） 链式存储结构设计不同的结点结构可构成不同的链式存储结构 二叉链表结点：数据域、左孩子域、右孩子域 Data lChild rChild 三叉链表结点：数据域、左孩子域、父结点、右孩子域 Data lChild parent rChild 二叉树的实现二叉树遍历策略遍历(Traverse)：按照某种次序访问树中的所有结点，且每个结点恰好访问一次（非线性结构线性化） 二叉树：根、左子树、右子树 遍历方式 先序/根遍历DLR：根 左子树 右子树 中序/根遍历LDR：左子树 根 右子树 后序/根遍历LRD：左子树 右子树 根 题：已知一颗二叉树的后序遍历的序列为5 4 3 7 6 2 1，中序遍历的序列为4 5 1 3 2 6 7，则其先序遍历的序列是什么? 解：1 4 5 2 3 6 7 思路： 根据后序可知1为根结点，则有根：1 左子树：45 右子树：2637 中序54 + 后序45可知 4 为根，5为右子树 后序3762可知 2 为根，中序3267则 367为右子树，3为2的左子树，67为2的右子树 中序3267可知6为根，7为右子树 二叉树结点123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 链式二叉表的结点 */public class Node &#123; private Object value; //值 private Node leftChild; //左子树的引用 private Node rightChild; //右子树的引用 public Node(int value) &#123; this.value = value; &#125; public Node(int value, Node leftChild, Node rightChild) &#123; super(); this.value = value; this.leftChild = leftChild; this.rightChild = rightChild; &#125; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125; public Node getLeftChild() &#123; return leftChild; &#125; public void setLeftChild(Node lNode) &#123; this.leftChild = lNode; &#125; public Node getRightChild() &#123; return rightChild; &#125; public void setRightChild(Node rNode) &#123; this.rightChild = rNode; &#125;&#125; 二叉树接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** 二叉树操作接口*/public interface BinaryTree &#123; /** * 是否为空树 * * @return */ public boolean isEmpty(); /** * 树结点数量 * * @return */ public int size(); /** * 树的高度 * * @return */ public int getHeight(); /** * 查询指定值的结点 * * @param value * @return */ public Node findKey(Object value); /** * 前序递归遍历 */ public void preOrderTraverse(); /** * 中序递归遍历 */ public void inOrderTraverse(); /** * 后序递归遍历 */ public void postOrderTraverse(); /** * 前序遍历非递归操作 */ public void preOrderByStack(); /** * 中序遍历非递归操作 */ public void inOrderByStack(); /** * 后序遍历非递归操作 */ public void postOrderByStack(); /** * 按照层次遍历二叉树 */ public void levelOrderByStack();&#125; 二叉树实现 递归遍历 前序、中序、后序非递归遍历 按层次遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271/*** 二叉链表实现*/public class LinkedBinaryTree implements BinaryTree &#123; private Node root; //根结点 public LinkedBinaryTree() &#123; &#125; public LinkedBinaryTree(Node root) &#123; super(); this.root = root; &#125; @Override public boolean isEmpty() &#123; return this.root == null; &#125; @Override public int size() &#123; System.out.print(\"二叉树的结点数：\"); return this.size(root); &#125; private int size(Node root) &#123; if (root != null) &#123; //左子树结点数 int leftSize = this.size(root.getLeftChild()); //右子树结点数 int rightSize = this.size(root.getRightChild()); return leftSize + rightSize + 1; &#125; return 0; &#125; @Override public int getHeight() &#123; System.out.print(\"二叉树的高度：\"); return this.getHeight(root); &#125; private int getHeight(Node root) &#123; if (root == null) &#123; return 0; &#125; else &#123; //左子树的高度 int leftHeight = this.getHeight(root.getLeftChild()); //右子树的高度 int rightHeight = this.getHeight(root.getRightChild()); //返回结点的高度 return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1; &#125; &#125; @Override public Node findKey(Object value) &#123; return this.findKey(value, root); &#125; private Node findKey(Object value, Node root) &#123; if (root == null) return null; else if (root.getValue().equals(value)) //是否为根节点 return root; else &#123; Node leftChild = this.findKey(value, root.getLeftChild()); Node rightChild = this.findKey(value, root.getRightChild()); if (leftChild != null &amp;&amp; leftChild.getValue().equals(value)) //是否为左子树 return leftChild; else if (rightChild != null &amp;&amp; rightChild.getValue().equals(value)) //是否为右子树 return rightChild; else return null; &#125; &#125; @Override public void preOrderTraverse() &#123; /** if (this.root != null) &#123; //根结点的值 System.out.print(root.getValue() + \" \"); //对左子树进行先序遍历 BinaryTree leftTree = new LinkedBinaryTree(root.getLeftChild()); leftTree.preOrderTraverse(); //对右子树进行先序遍历 BinaryTree rightTree = new LinkedBinaryTree(root.getRightChild()); rightTree.preOrderTraverse(); &#125; */ System.out.println(\"前序遍历--递归\"); this.preOrderTraverse(this.root); System.out.println(); //换行符 &#125; private void preOrderTraverse(Node root) &#123; if (root != null) &#123; //输出结点的值 System.out.print(root.getValue() + \" \"); //遍历左子树 this.preOrderTraverse(root.getLeftChild()); //遍历右子树 this.preOrderTraverse(root.getRightChild()); &#125; &#125; @Override public void inOrderTraverse() &#123; /** if (this.root != null) &#123; //对左子树进行中序遍历 BinaryTree leftTree = new LinkedBinaryTree(root.getLeftChild()); leftTree.inOrderTraverse(); //根结点的值 System.out.print(root.getValue() + \" \"); //对右子树进行中序遍历 BinaryTree rightTree = new LinkedBinaryTree(root.getRightChild()); rightTree.inOrderTraverse(); &#125; System.out.println(); */ System.out.println(\"中序遍历--递归\"); this.inOrderTraverse(this.root); System.out.println(); //换行符 &#125; private void inOrderTraverse(Node root) &#123; if (root != null) &#123; //遍历左子树 this.inOrderTraverse(root.getLeftChild()); //输出结点的值 System.out.print(root.getValue() + \" \"); //遍历右子树 this.inOrderTraverse(root.getRightChild()); &#125; &#125; @Override public void postOrderTraverse() &#123; /** if (this.root != null) &#123; //对左子树进行后序遍历 BinaryTree leftTree = new LinkedBinaryTree(root.getLeftChild()); leftTree.postOrderTraverse(); //对右子树进行后序遍历 BinaryTree rightTree = new LinkedBinaryTree(root.getRightChild()); rightTree.postOrderTraverse(); //根结点的值 System.out.print(root.getValue() + \" \"); &#125; */ System.out.println(\"后序遍历--递归\"); this.postOrderTraverse(this.root); System.out.println(); //换行符 &#125; private void postOrderTraverse(Node root) &#123; if (root != null) &#123; //对左子树进行后序遍历 this.postOrderTraverse(root.getLeftChild()); //对右子树进行后序遍历 this.postOrderTraverse(root.getRightChild()); //根结点的值 System.out.print(root.getValue() + \" \"); &#125; &#125; @Override public void preOrderByStack() &#123; if (root == null) return; System.out.println(\"前序非递归遍历\"); Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;(); Node current = root; while (current != null || !deque.isEmpty()) &#123; while (current != null) &#123; deque.push(current); System.out.print(current.getValue() + \" \"); current = current.getLeftChild(); &#125; if (!deque.isEmpty()) &#123; current = deque.pop(); current = current.getRightChild(); &#125; &#125; System.out.println(); //换行符 &#125; @Override public void inOrderByStack() &#123; if (root == null) return; System.out.println(\"中序非递归遍历\"); Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;(); Node current = root; while (current != null || !deque.isEmpty()) &#123; while (current != null) &#123; deque.push(current); //入栈 current = current.getLeftChild(); &#125; if (!deque.isEmpty()) &#123; current = deque.pop(); //出栈 System.out.print(current.getValue() + \" \"); current = current.getRightChild(); &#125; &#125; System.out.println(); //换行符 &#125; /** * 用来记录最新出栈的节点， * 如果当前节点的右孩子与flag相同，说明当前节点右子树已完成遍历 */ @Override public void postOrderByStack() &#123; if (root == null) return; System.out.println(\"后序非递归遍历\"); Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;(); Node current = root; Node flag = null; while (current != null) &#123; //根结点及其根结点的左子树(最左侧的所有结点+根节点)...全部入栈 deque.push(current); current = current.getLeftChild(); &#125; while (!deque.isEmpty()) &#123; current = deque.pop(); //出栈 if (current.getRightChild() == null || current.getRightChild() == flag) &#123; System.out.print(current.getValue() + \" \"); //输出当前值 flag = current; &#125; else &#123; deque.push(current); current = current.getRightChild(); while (current != null) &#123; deque.push(current); current = current.getLeftChild(); &#125; &#125; &#125; System.out.println(); //换行符 &#125; @Override public void levelOrderByQueue() &#123; if (root == null) return; System.out.print(\"按照层次进行遍历\"); Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); //root入队 while (queue.size() != 0) &#123; int len = queue.size(); for (int i = 0; i &lt; len; i++) &#123; Node temp = queue.poll(); //出队 if (temp != null) &#123; System.out.print(temp.getValue() + \" \"); if (temp.getLeftChild() != null) queue.add(temp.getLeftChild()); if (temp.getRightChild() != null) queue.add(temp.getRightChild()); &#125; &#125; &#125; System.out.println(); //换行符 &#125;&#125; 树与二叉树相关代码下载树与二叉树相关代码","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://lao-biao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"java数据结构与算法--串","slug":"java数据结构与算法-串","date":"2020-04-10T06:00:00.000Z","updated":"2020-07-06T03:34:02.237Z","comments":true,"path":"articles/7e56a691.html","link":"","permalink":"https://lao-biao.github.io/articles/7e56a691.html","excerpt":"串内容受限的线性表 串的定义串(String)：零个或多个任意字符组成的有限序列 串名 串值 串长 相关概念子串一个串中任意个连续字符组成的子序列（含空串）称为该串的子串 真子串：不包含自身的所有子串 主串包含子串的串称为主串 字符位置字符在序列中的序号为该字符在串中的位置 子串位置子串第一个字符在主串中的位置 空格串由一个或多个空格组成的串（与空串不同） 串相等当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的 注：所有空串都是相等的 串的类型定义数据对象：D={ai | ai∈ CharacterSet, i = 1,2,…n} 数据关系：R1={&lt;ai-1,ai&gt;|ai-1,ai ∈ D , i = 1,2,…,n}","text":"串内容受限的线性表 串的定义串(String)：零个或多个任意字符组成的有限序列 串名 串值 串长 相关概念子串一个串中任意个连续字符组成的子序列（含空串）称为该串的子串 真子串：不包含自身的所有子串 主串包含子串的串称为主串 字符位置字符在序列中的序号为该字符在串中的位置 子串位置子串第一个字符在主串中的位置 空格串由一个或多个空格组成的串（与空串不同） 串相等当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的 注：所有空串都是相等的 串的类型定义数据对象：D={ai | ai∈ CharacterSet, i = 1,2,…n} 数据关系：R1={&lt;ai-1,ai&gt;|ai-1,ai ∈ D , i = 1,2,…,n} 串的存储结构顺序存储结构顺序串 1234public class String&#123; char[n] strings; //数据 int length; //串长度&#125; 链式存储结构链串 123456789101112//数据域：每个结点存储n个字符//指针域：存储下一个结点的地址public class Node&#123; char[n] data; //数据--n个字符 Node next; //直接后继&#125;public class String&#123; Node head; //头结点 Node tail; //尾结点 int length; //串长度&#125; 存储密度 = (串值所占的内存) / 实际分配的内存 串的基本操作详细代码见String源码 Java API文档 串赋值 String str = &quot;content&quot;; String str = new String(&quot;content&quot;); 串比较 str.compareTo(String anotherString) 求串长 int len = str.length(); 串连结 String newString=str.concat(String anotherString); 求子串 String seq = str.substring( int beginIndex); String seq = str.substring( int beginIndex, int endIndex); 串拷贝 String s = String.copyValueOf(str); 串判空 boolean empty = str.isEmpty(); 子串的位置 int index = str.indexOf(char seq) int index = str.indexOf(String seq); 串替换 String seq = str.replace(); 串的匹配模式算法确定主串中所含子串(模式串)第一次出现的位置 BF算法简单匹配算法 Brute-Force(暴力算法) 采用的是穷举法 算法思路从主串的每一个字符开始依次与模式串的字符进行匹配 如果当前字符匹配成功，则继续匹配 如果匹配失败，回溯，从主串该次匹配成功的第一个字符的下一个字符开始直到模式串 代码实现12345678910111213141516171819202122232425262728293031323334/** * 字符串匹配--暴力算法 * 时间复杂度：O(n*m) //m为主串长度，n为模式串长度 * @param text 主串 * @param pattern 模式串 * @return 匹配成功返回模式串第一次出现的位置 */public static int indexByBruteForce(String text, String pattern) &#123; int sLen = text.length(); //主串字符长度 int pLen = pattern.length(); //模式串字符长度 char[] s = text.toCharArray(); //主串字符 char[] p = pattern.toCharArray(); //模式串字符 if (sLen &lt; pLen) //主串长度比模式串长度小，直接返回不匹配 return -1; int i = 0; //主串指针位置 int j = 0; //模式串指针位置 while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //while (i &lt; sLen &amp;&amp; j &lt; pLen &amp;&amp; sLen - i + j &gt;= pLen) &#123; // 优化sLen - i + j &gt;= pLen保证主串有剩余字符能匹配成功 if (s[i] == p[j]) &#123; //如果当前字符匹配成功，则继续匹配 i++; j++; &#125; else &#123; //如果失配，回溯 i = i - (j - 1); //从该次匹配成功的第一个字符的下一个字符开始 j = 0; //从第一个字符开始 &#125; &#125; //匹配成功返回第一个字符的位置，匹配不成功，返回-1 return j == pLen ? i - j : -1;&#125; 测试代码 1234int index = indexByBruteForce(\"this is for test\", \"test\");System.out.println(index);//输出12 KMP算法Knuth Morris Pratt 算法思路利用已经部分匹配的结果加快模式串的滑动速度，且主串s的指针i不必回溯 在已经匹配的模式串的子串中，找出最长的相同的前缀和后缀，然后移动使它们重叠，定义next[j]数组，表明当模式中第j个字符与主串中相应字符，不匹配时，在模式中需要重新和主串中该字符进行比较的字符的位置$$next[j]={\\begin{cases}max{k|1&lt;k&lt;j,且P_1…P_{k-1} = P_{j-k+1}…P_{j-1}} &amp; 集合为空\\0 &amp; j=1 \\1 &amp; 其他情况\\end{cases}}$$时间复杂度：O(m+n) 可参考资料：字符串匹配的KMP算法–阮一峰 算法改进在next[j]数组的基础上引入nextval[j]数组 nextval[j]数组$$nextval[j]=\\begin{cases}next[j]的next值 &amp; 当前元素的符号与第next[j]的元素符号相同(循环比较直至不相同)\\next[j]\\end{cases}$$nextval[j]数组：相同填next值对应的比较后的值，不同为自己的next值 序号 1 2 3 4 5 6 7 8 模式串 a b a a b c a c next值 0 1 1 2 2 3 1 2 nextval值 0 1 0 2 2 3 0 2 代码实现12345678910111213141516171819202122232425262728293031323334353637/** * @param text 主串 * @param pattern 模式串 * @return 如果匹配成功，返回下标，否则返回-1 */public static int KMP(String text, String pattern) &#123; if (text.length() &lt; pattern.length() || pattern.length() == 0 || null == pattern) // return -1; //求模式串的next数组 int[] next = new int[pattern.length()]; next[0] = -1; for (int i = 1, k = -1; i &lt; pattern.length(); i++) &#123; if (k == -1 || pattern.charAt(i - 1) == pattern.charAt(k)) &#123; k++; next[i] = k; &#125; else &#123; next[i] = 0; k = 0; &#125; &#125; //进行匹配 for (int i = 0, j = 0; i &lt; text.length(); ) &#123; if (text.charAt(i) != pattern.charAt(j)) &#123; if (next[j] == -1) i++; else j = next[j]; &#125; else &#123; if (j == pattern.length() - 1) return i - pattern.length() + 1; i++; j++; &#125; &#125; return -1;&#125; 测试代码 1234int index = KMP(\"this is for test\", \"test\");System.out.println(index);//输出12","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"串","slug":"串","permalink":"https://lao-biao.github.io/tags/%E4%B8%B2/"}]},{"title":"java数据结构与算法--栈和队列","slug":"java数据结构与算法-栈和队列","date":"2020-04-10T05:12:34.000Z","updated":"2020-07-06T03:34:54.233Z","comments":true,"path":"articles/f483932c.html","link":"","permalink":"https://lao-biao.github.io/articles/f483932c.html","excerpt":"栈和队列栈定义栈（stack）：堆栈，是运算受限的线性表 仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除等操作 表中进行插入、删除操作的一端称为栈顶（top），栈顶保存的元素称为栈顶元素，相对的，表的另一端为栈底（bottom） 当栈中没有元素时成为空栈 向一个栈插入元素又称为入栈或进栈 从一个栈中删除元素又称为出栈或退栈 由于栈的插入和删除操作仅在栈顶进行，后进的元素必定先出栈，堆栈又称为后进先出表（Last In First Out， LIFO）","text":"栈和队列栈定义栈（stack）：堆栈，是运算受限的线性表 仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除等操作 表中进行插入、删除操作的一端称为栈顶（top），栈顶保存的元素称为栈顶元素，相对的，表的另一端为栈底（bottom） 当栈中没有元素时成为空栈 向一个栈插入元素又称为入栈或进栈 从一个栈中删除元素又称为出栈或退栈 由于栈的插入和删除操作仅在栈顶进行，后进的元素必定先出栈，堆栈又称为后进先出表（Last In First Out， LIFO） 栈接口push 入栈 pop 出栈 peek 取栈顶元素 12345678910111213141516public interface Stack &#123; //返回堆栈的大小 public int getSize(); //判断栈顶是否为空 public boolean isEmpty(); //数据元素e入栈 public void push(Object e); //栈顶元素出栈 public Object pop(); //取栈顶元素 public Object peek();&#125; 栈的存储结构 顺序栈：使用顺序存储结构实现的堆栈，即利用一组地址连续的存储单元依次存放堆栈中的数据元素 链栈：采用链表作为存储结构实现的栈 顺序栈、链栈操作数据元素的时间复杂度均为O（1） 队列定义队列（queue）简称为队，是运算受限的线性表 仅允许在表的一端进行插入，而在表的另一端进行删除 在队列把插入数据元素的一端成为队尾（rear），删除数据元素的一端称为队首（front） 向队尾插入元素称为进队或入队，新元素入队后成为新的队尾元素 向队列中删除元素称为离队或出队，元素出队后，其后续元素成为新的队首元素 先进队的元素先离队，队列：先进先出表（First In First Out，FIFO） 队列接口入队、出队 12345678910111213141516public interface Queue &#123; //返回队列的大小 public int getSize(); //判断队列是否为空 public boolean isEmpty(); //数据元素e入队 public void enqueue(Object e); //队首元素出队 public Object dequeue(); //取队首元素 public Object peek();&#125; 队列存储结构 顺序队列 使用数组作为存储结构：使用普通数组实现队列，不能使用front之前的空间，会导致大量空间丢失 使用循环数组作为存储结构：末尾元素的下一个元素为数组的头元素 链式队列：使用单链表实现 双端队列双端队列：两端都可以进行进队和出队的队列 输出受限的双端队列：一个端点允许插入和删除元素，另一个端点只允许插入的双端队列 输入受限的双端队列：一个端点允许插入和删除元素，另一个端点只允许删除的双端队列 java中的栈和队列Stack栈类（已过时）public class Stack&lt;E&gt; extends Vector&lt;E&gt; Queue队列类 public interface Queue&lt;E&gt; extends Collection 扩展了java.util.Collection接口 Deque双端队列 public interface Deque&lt;E&gt; extends Queue&lt;E&gt; LinkedList栈+队列 public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable ArrayDeque数组形式的双端队列 public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable 使用栈实现进制转换1234567891011121314151617int num = 13;int temp = num;//定义空栈Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();while (temp &gt; 0) &#123; //取余数 int mod = temp % 2; //入栈 stack.push(mod); //除2 temp = temp &gt;&gt; 1;&#125;System.out.print(num + \"---&gt;\");while (!stack.isEmpty()) &#123; //出栈 System.out.print(stack.pop());&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://lao-biao.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://lao-biao.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"java数据结构与算法--线性表","slug":"java数据结构与算法-线性表","date":"2020-04-10T05:10:08.000Z","updated":"2020-07-06T03:34:41.605Z","comments":true,"path":"articles/5b4e0ff4.html","link":"","permalink":"https://lao-biao.github.io/articles/5b4e0ff4.html","excerpt":"线性表线性表及其结构定义线性表是n个类型相同数据元素的有限序列 相同数据类型：相同数据类型意味着在内存中存储时，每个元素占用相同的内存空间，便于后续的查询定位 序列(顺序性)：在线性表的相邻数据元素之间存在着序偶关系 ai-1是ai的直接前驱，则ai+1是ai的直接后续 唯一没有直接前驱的元素a0一端称为表头 唯一没有直接后续的元素an-1一端称为表尾 除表头和表尾元素外，任何一个元素都有且仅有一个直接前驱和直接后继 有限：线性表中数据元素的个数n定义为线性表的长度，n是一个有限值 n=0时线性表为空表 在非空的线性表中每个数据元素中都有唯一确定的序号 在一个具有n&gt;0个数据元素的线性表中，数据元素序号的范围是[0,n-1]","text":"线性表线性表及其结构定义线性表是n个类型相同数据元素的有限序列 相同数据类型：相同数据类型意味着在内存中存储时，每个元素占用相同的内存空间，便于后续的查询定位 序列(顺序性)：在线性表的相邻数据元素之间存在着序偶关系 ai-1是ai的直接前驱，则ai+1是ai的直接后续 唯一没有直接前驱的元素a0一端称为表头 唯一没有直接后续的元素an-1一端称为表尾 除表头和表尾元素外，任何一个元素都有且仅有一个直接前驱和直接后继 有限：线性表中数据元素的个数n定义为线性表的长度，n是一个有限值 n=0时线性表为空表 在非空的线性表中每个数据元素中都有唯一确定的序号 在一个具有n&gt;0个数据元素的线性表中，数据元素序号的范围是[0,n-1] 线性表的存储结构 顺序表——顺序存储结构 特点：在内存中分配连续的空间，只存储数据，不需要存储地址信息。位置中隐含着地址 优点： 节省存储空间，分配给数据的存储单元全用存放结点的数据，结点之间的逻辑关系没有占用额外的存储空间； 索引查找效率高 序号为i+1的数据元素存储地址可表示为LOC(ai)=LOC(a0))+i*K K为数据所占存储单元 缺点： 插入和删除操作需要移动元素，效率较低 必须提前分配固定数量的空间，如果存储元素少，可能导致空闲浪费 按照内容查询效率低（逐个比较判断） 链表——链式存储结构 特点：数据元素的存储对应的是不连续的存储空间，每个存储结点对应一个需要存储的数据元素。 每个结点是由数据域和指针组成，元素之间的逻辑关系通过存储结点之间的链接关系反映出来，逻辑上相邻的结点物理上不必相邻。 优点： 插入、删除灵活（不必移动结点，只需要改变结点中的指针，但是需要先定位到元素上） 有元素才会分配结点空间， 不会有闲置的结点 缺点： 比顺序存储结构的存储密度小 查找结点时链式存储要比顺序存储慢（每个结点地址不连续、无规律，导致按照索引查找效率低下） 线性表操作Java API文档 123456789101112131415161718192021222324252627282930313233343536373839public interface List&#123; //返回线性表的大小，即元素个数 public int size(); //返回线性表中序号为i的数据元素 public Object get(int i); //如果线性表为空返回true，否则返回false public boolean isEmpty(); //判断线性表是否包含数据元素e public boolean contains(Object e); //返回数据元素e在线性表中的序号 public int indexOf(Object e); //将数据元素e插入到线性表中i号位置 public void add(int i, Object e); //将数据元素e插入到线性表末尾 public void add(Object e); //将数据元素e插入到obj之前 public boolean addBefore(Object obj, Object e); //将数据元素e插入到元素obj之后 public boolean addAfter(Object obj, Object e); //删除线性表中序号为i的元素，并返回之 public Object remove(int i); //删除线性表中第一个与e相同的元素 public boolean remove(Object e); //替换线性表中序号为i的数据元素为e，返回数据元素 public Object replace(int i, Object e); &#125; 12345678910111213141516171819202122232425262728293031public class Node &#123; private Object data; //元素数据 private Node next; //下一个结点 public Node(Object data) &#123; this.data = data; &#125; public Node(Object data, Node next) &#123; this.data = data; this.next = next; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; 顺序表实现–模拟ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/** * 顺序表 * 底层采用数组，但长度可以动态变化 */public class ArrayList implements List &#123; private Object[] elementData; //底层为数组，长度未定 private int size; //元素的个数 @Override public String toString() &#123; if (size == 0) &#123; return \"[]\"; &#125; StringBuilder builder = new StringBuilder(\"[\"); for (int i = 0; i &lt; size; i++) &#123; if (i != size - 1) &#123; builder.append(elementData[i]).append(\",\"); &#125; else &#123; builder.append(elementData[i]); &#125; &#125; builder.append(\"]\"); return builder.toString(); &#125; public ArrayList() &#123; //没有指定长度，默认长度是4; this(4); //没有指定长度，长度是0 //elementData=new Object[]&#123;&#125;; &#125; public ArrayList(int initialCapacity) &#123; //给数组分配指定数量的空间 elementData = new Object[initialCapacity]; //指定顺序表的元素个数,默认是0 //size=0; &#125; @Override public int size() &#123; return size; &#125; @Override public Object get(int i) &#123; if (i &lt; 0 || i &gt;= size) &#123; throw new RuntimeException(\"数组索引越界异常：\" + i); //可使用自定义异常 &#125; return elementData[i]; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean contains(Object e) &#123; return indexOf(e) &gt;= 0; &#125; @Override public int indexOf(Object e) &#123; if (e == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (e.equals(elementData[i])) return i; &#125; return -1; &#125; @Override public void add(int i, Object e) &#123; rangeCheck(i); //数组满了，就扩容 if (size == elementData.length) &#123; grow(); &#125; //后移i及其后面的位置，从最后一个开始 for (int j = size; j &gt; i; j--) &#123; elementData[j] = elementData[j - 1]; &#125; //给数组第i个位置赋值 elementData[i] = e; //元素个数加1 size++; &#125; private void rangeCheck(int index) &#123; //判断i是否为异常值 if (index &lt; 0 || index &gt; size) &#123; throw new RuntimeException(\"数组索引越界异常：\" + index); &#125; &#125; @Override public void add(Object e) &#123; this.add(size, e); /** //数组满了，就扩容 if (size == elementData.length) &#123; grow(); &#125; //给数组赋值 //elementData[size]=e; //元素个数加1 //size++; elementData[size++] = e; */ &#125; private void grow() &#123; //新创建一个新的数组，长度是旧数组的2倍,源码是增长50% Object[] newArr = new Object[elementData.length * 2]; //将旧数组的数据拷贝到新数组 for (int i = 0; i &lt; size; i++) &#123; newArr[i] = elementData[i]; &#125; //让elementData指向新数组 elementData = newArr; //等价于elementData = Arrays.copyOf(elementData,elementData.length*2); &#125; @Override public boolean addBefore(Object obj, Object e) &#123; int index = 0; for (; index &lt; size; index++) &#123; if (elementData[index].equals(obj)) &#123; this.add(index, e); return true; &#125; &#125; return false; &#125; @Override public boolean addAfter(Object obj, Object e) &#123; int index = 0; for (; index &lt; size; index++) &#123; if (elementData[index].equals(obj)) &#123; this.add(index + 1, e); return true; &#125; &#125; return false; &#125; @Override public Object remove(int i) &#123; rangeCheck(i); Object oldElement = elementData[i]; fastRemove(i); return oldElement; &#125; @Override public boolean remove(Object e) &#123; if (e == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (e.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; Object[] newArr = new Object[size - 1]; int newI = 0; for (int i = 0; i &lt; size; i++) &#123; if (i == index) &#123; continue; &#125; newArr[newI] = elementData[i]; newI++; &#125; elementData = newArr; size--; &#125; @Override public Object replace(int i, Object e) &#123; rangeCheck(i); elementData[i] = e; return elementData; &#125;&#125; 单链表实现–模拟LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204public class SingleLinkedList implements List &#123; private Node head = new Node(); //头结点，不存储数据，只为操作链表 private int size; //结点数，不包括头结点 @Override public String toString() &#123; if (size == 0) &#123; return \"[]\"; &#125; StringBuilder builder = new StringBuilder(\"[\"); Node p = head.getNext(); for (int i = 0; i &lt; size; i++) &#123; if (i != size - 1) &#123; builder.append(p.getData()).append(\",\"); &#125; else &#123; builder.append(p.getData()); &#125; //移动指针 p = p.getNext(); &#125; builder.append(\"]\"); return builder.toString(); &#125; @Override public int size() &#123; return size; &#125; @Override public Object get(int i) &#123; Node p = head; for (int j = 0; j &lt;= i; j++) &#123; p = p.getNext(); &#125; return p.getData(); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean contains(Object e) &#123; return indexOf(e) &gt; 0; &#125; @Override public int indexOf(Object e) &#123; Node p = head; int index = 0; if (e == null) &#123; for (; index &lt; size; index++) &#123; p = p.getNext(); if (p.getData() == null) &#123; return index; &#125; &#125; &#125; else &#123; for (; index &lt; size; index++) &#123; p = p.getNext(); if (p.getData().equals(e)) &#123; return index; &#125; &#125; &#125; return -1; &#125; @Override public void add(int i, Object e) &#123; //检查索引是否越界 rangeCheck(i); //找到前一个结点，从头结点开始 Node p = head; for (int j = 0; j &lt; i; j++) &#123; p = p.getNext(); &#125; //创建新结点 Node newNode = new Node(); newNode.setData(e); //指明新结点的直接后继 newNode.setNext(p.getNext()); //指明新结点的直接前驱 p.setNext(newNode); //元素个数+1 size++; &#125; private void rangeCheck(int index) &#123; //判断i是否为异常值 if (index &lt; 0 || index &gt; size) &#123; throw new RuntimeException(\"数组索引越界异常：\" + index); &#125; &#125; @Override public void add(Object e) &#123; this.add(size, e); &#125; @Override public boolean addBefore(Object obj, Object e) &#123; Node p = head; //先找到前一个结点，在前一个结点后面添加 for (int i = 0; i &lt; size; i++) &#123; if (obj == null) &#123; if (p.getNext().getData() == null) &#123; this.add(i, e); return true; &#125; &#125; else &#123; if (p.getNext().getData().equals(obj)) &#123; this.add(i, e); return true; &#125; &#125; p = p.getNext(); &#125; return false; &#125; @Override public boolean addAfter(Object obj, Object e) &#123; Node p = head; for (int i = 0; i &lt; size; i++) &#123; p = p.getNext(); if (obj == null) &#123; if (p.getData() == null) &#123; this.add(i + 1, e); return true; &#125; &#125; else &#123; if (p.getData().equals(obj)) &#123; this.add(i + 1, e); return true; &#125; &#125; &#125; return false; &#125; @Override public Object remove(int i) &#123; rangeCheck(i); //拿到前一个结点 Node p = head; for (int j = 0; j &lt; i; j++) &#123; p = p.getNext(); &#125; //获取该节点 Node now = p.getNext(); //删除该结点：前一个结点直接指向该结点的直接后续 p.setNext(now.getNext()); //元素数量-1 size--; return now.getData(); &#125; @Override public boolean remove(Object e) &#123; //拿到前一个结点 Node p = head; for (int i = 0; i &lt; size; i++) &#123; if (e == null) &#123; if (p.getNext().getData() == null) &#123; //删除操作 Node next = p.getNext().getNext(); p.setNext(next); //元素数量-1 size--; return true; &#125; &#125; else &#123; if (p.getNext().getData().equals(e)) &#123; //删除操作 Node next = p.getNext().getNext(); p.setNext(next); //元素数量-1 size--; return true; &#125; &#125; p = p.getNext(); &#125; return false; &#125; @Override public Object replace(int i, Object e) &#123; rangeCheck(i); //拿到前一个结点 Node p = head; for (int j = 0; j &lt;= i; j++) &#123; p = p.getNext(); &#125; Object oldData = p.getData(); p.setData(e); return oldData; &#125;&#125; 其他链表双向链表双向链表每一个结点有三部分组成：前驱指针域、数据域、后继指针域 Node: pre,data,next 头结点：Node head=Node(null,data,next) 尾结点：Node tail=Node(pre,data,null) 循环链表单链表–头结点的直接前驱为尾节点，最后一个结点的直接后继为头结点 单链表为空时：head.next=head 双链表–头结点的直接前驱为尾节点，尾结点的直接后继为头结点 head.pre=tail tail.next=head Java中线性表Vector 顺序表 底层为可变的数组 增加线程安全，效率低下 扩容每次增长1倍（未指定capacity Increment时） ArrayList顺序表 底层为可变的数组 去除了线程安全换取高效率 扩容每次增长50% LinkedList双向链表 双向循环链表 相关代码下载线性表相关代码","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"https://lao-biao.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"java数据结构与算法--基础","slug":"java数据结构与算法-基础","date":"2020-04-10T05:07:23.000Z","updated":"2020-07-06T03:34:09.278Z","comments":true,"path":"articles/f2c524f6.html","link":"","permalink":"https://lao-biao.github.io/articles/f2c524f6.html","excerpt":"基本概念数据数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。 数据项数据项具有原子性，是不可分割的最小数据单位。 数据元素数据元素是数据的基本单位，是数据集合的个体，通常由若干个数据项组成，在计算机程序中通常作为一个整体来进行处理。 数据对象数据对象是心智相同的数据元素的集合，是数据的子集。 数据结构数据结构是指相互之间存在一种或多种的数据元素的集合。 逻辑结构：数据结构的逻辑层面 线性结构 线性表 栈 队列 串及数组 非线性结构 树形结构 图形结构 数据的存储结构：存在于计算机世界的物理层面 顺序存储 链式存储 索引存储 散列存储 数据结构的运算：检索、排序、插入、删除、修改…","text":"基本概念数据数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。 数据项数据项具有原子性，是不可分割的最小数据单位。 数据元素数据元素是数据的基本单位，是数据集合的个体，通常由若干个数据项组成，在计算机程序中通常作为一个整体来进行处理。 数据对象数据对象是心智相同的数据元素的集合，是数据的子集。 数据结构数据结构是指相互之间存在一种或多种的数据元素的集合。 逻辑结构：数据结构的逻辑层面 线性结构 线性表 栈 队列 串及数组 非线性结构 树形结构 图形结构 数据的存储结构：存在于计算机世界的物理层面 顺序存储 链式存储 索引存储 散列存储 数据结构的运算：检索、排序、插入、删除、修改… 数据结构类型 线性表 栈 队列 (字符)串 数组 广义表 树 二叉树 图 数据的逻辑结构数据的逻辑结构指数据元素之间的逻辑关系（和实现无关） 线性结构与非线性结构 线性结构：有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个后继 集合中必存在唯一的一个”第一个元素” 集合中必存在唯一的一个”最后的元素” 除最后元素之外，其他数据元素均有唯一的”后继” 除第一元素之外，其他元素均有唯一的”前驱” 非线性结构：一个结点元素可能对应多个直接前驱和多个直接后继 树状（二叉树…） 图（网…） 集合结构、线性结构、树状结构、网状结构 集合结构(Set) 确定性：集合中的元素必须是确定的 唯一性：结合中的元素互不相同 无序性：集合中的元素没有先后之分 线性结构：数据元素之间存在着”一对一”的线性关系的数据结构 树状结构：除了一个数据元素以外每个数据元素有且仅有一个直接前驱元素，但是可以有多个直接后续元素（一对多） 网状结构：每个数据元素可以有多个直接前驱元素，也可以有多个直接后续元素（多对多） 数据的存储结构数据的存储结构主要包括数据元素本身的存储以及数据元素之间关系表示，是数据的逻辑结构在计算机的表示。 顺序储存结构：把逻辑上相邻的结存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现 优点：节省存储空间（分配数据的存储单元全用存放结点的数据，不考虑C/C++语言中数组需指定大小的需求），结点之间的关系没有占用额外的存储空间，可实现对结点的随机存取（一个结点对应一个序号） 缺点：插入和删除操作需要移动元素，效率较低 链式存储结构：数据元素的存储结构是不连续的存储空间，每个存储结点对应一个需要存储的数据元素，每个结点是由数据域和指针组成，元素之间的逻辑关系通过存储结点之间的链接关系反映。 比顺序存储结构的存储密度小（每个结点都由数据域和指针域组成，所以相同空间内假设全存满时顺序比链式存储更多） 逻辑上相邻的结点物理上不必相邻 插入、删除灵活（不必移动结点，之哟啊改变结点中的指针） 查找结点时链式存储结构要比顺序存储慢 索引结构：除建立存储结点信息外，还建立附加的索引表来标识结点的地址 散列结构（hash表）：根据结点的关键字直接计算出该结点的存储地址 算法概念算法是指令的集合，是为解决特定问题而规定的一系列操作。它是明确定义的可计算过程，以一个数据集合作为输入，并产生一个数据集合作为输出。 输入：一个算法应以待解决的问题的信息作为输入。 输出：输入对应指令集后得到的信息。 可行性：算法是可行的，即算法中的每一条指令都是可以实现的，均能在有限的时间内完成。 有穷性：算法执行的指令个数是有限的，每个指令又是在有限时间内完成的，因此整个算法也是在有限时间内可以结束的。 确定性：算法对于特定的合法输入，其对应输出是唯一的，即当算法从一个特定输入开始，多次执行同一指令集结果总是相同的。 算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间资源，复杂度分为时间复杂度和空间复杂度。 算法时间复杂度时间复杂度是执行算法所需要的计算工作量 时间频度一个算法执行所耗费的时间(需在机器上运行才能测出) 一个算法花费的时间与算法中语句执行次数成正比例，哪个算法中语句执行次数多，花费时间就多。 一个算法中的语句执行次数为语句频度或时间频度，表示为T(n),n表示问题的规模。 时间复杂度一般情况下，算法中基本操作重复执行的次数是问题规模的某个函数，用T(n)表示。 若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数时，则称f(n)时T(n)的同数量级函数。记作T(n)=O(f(n))为渐进时间复杂度，简称时间复杂度。T(n)=O(f(n)) 时间复杂度是时间频度去掉低阶项和首项常数。 时间频度与时间复杂度是不相同的，时间频度不同但时间复杂度可能相同。 eg：某两个算法的时间频度分别是 T(n)1=100 n2+100 T(n)2=10000 n2+10 n+6 其时间复杂度均为O(n2 ) 最坏时间复杂度与平均时间复杂度 最坏时间复杂度：最坏情况下的时间复杂度(一般情况下时间复杂度都是指最坏时间复杂度)。 平均时间复杂度：指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。 难计算 有很多算法的平均情况和最差情况的复杂度是一样的 O符号：算法时间复杂度的上界(最坏情况 &lt;=) Ω符号：算法时间复杂度的下界(最好情况 &gt;=) Θ符号：算法时间复杂度的精确阶(最好和最坏是同一个阶 =) 时间复杂度计算 找出算法中的基本语句：算法中执行次数最多的那条语句，通常是最内层循环的循环体 计算基本语句的执行次数的数量级：只需计算基本语句执行次数的数量级(可以忽略所有低次幂和最高次幂的系数) 用大O记号表示算法的时间性能：将基本语句执行次数的数量级放入大O记号中 12345678910111213141516171819202122int count=0; // T(n)=O(1)int count=0;... // T(n)=O(1) int count=0,n=8;for(int i=0; i&lt;n;i++) count++; // T(n)=O(n)int count=0,n=8;for(int i=1; i&lt;=n;i*=2) count++; // T(n)=O(log2 n)int count = 0, n = 8;for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) count++; // T(n)=O(n^2)int count = 0, n = 8;for (int i = 1; i &lt;= n; i *= 2) for (int j = 0; j &lt; n; j++) count++; // T(n)=O(nlog2 n) 常用时间复杂度级别 算法阶数 算法时间复杂度 常数阶 O(1) 对数阶 O(log 2 n ) 线性阶 O(n) 线性对数阶 O(n log 2 n) 平方阶 O(n2) 立方阶 O(n3) k次方阶 O(nk) 指数阶 O(2n) 阶乘阶 O(n!) 时间复杂度越高，执行效率越低 算法空间复杂度空间复杂度是执行这个算法所需要的内存空间 空间复杂度算法的存储容量包括： 程序本身所占空间 输入数据所占空间 辅助变量所占空间 输入数据所占空间只取决于问题本身，和算法无关，只需要分析除输入和程序之外的辅助变量所占额外空间。 空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的度量，一般也作为问题规模n的函数，以数量级形式给出，S(n)=O(g(n)) 空间复杂度分析一123456789int fun(int n) &#123; int i, j, k, s; s = 0; for (i = 0; i &lt; n; i++) for (j = 0; j &lt;= i; j++) for (k = 0; k &lt;= j; k++) s++; return s;&#125; 算法中临时变量的个数与问题规模n无关，因此空间复杂度均为S(n)=O(1) 空间复杂度分析二123456789101112//n为数组a的元素个数void fun(int a[], int n, int k) &#123; int i; if (k == n - 1) for (i = 0; i &lt; n; i++) System.out.print(a[i]); else &#123; for (i = k; i &lt; n; i++) a[i] = a[i] + i * i; fun(a, n, k + 1); &#125;&#125; 递归算法，每次调用本身都要分配空间，fun(a,n,0)的空间复杂度为O(n) 注意 空间复杂度相比时间复杂度分析要少 对于递归算法来说，代码一般都比较简短，算法本身所占用的存储空间较少，但运行时需要占用较多的临时工作单元；若改写成非递归算法，代码可能会较长，算法本身占用的存储空间较多，但运行时占用较少的临时工作单元。","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"hexo上传至gitee以及添加gitee评论功能","slug":"hexo+gitee个人博客(giteement评论)","date":"2020-04-09T09:05:22.000Z","updated":"2020-07-06T03:12:04.807Z","comments":true,"path":"articles/6dfbadcb.html","link":"","permalink":"https://lao-biao.github.io/articles/6dfbadcb.html","excerpt":"使用gitee(码云)作为博客地址在完成github和hexo搭建好个人博客系统后，再将博客部署到在gitee上 创建gitee仓库新建仓库 为了使用用户名.gitee.io作为博客的地址，仓库名需要直接填写成gitee用户名，这一点是不同与github 原因：gitee pages在生成页面时会默认地添加后缀.gitee.io 仓库名：gitee用户名 开源：公开(可以作为giteement存放评论的仓库，另外新建一个也是可以的) 配置修改博客根目录下的_config.ym文件 12345678910# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://用户名.gitee.io/# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@gitee.com:用户名/用户名.git branch: master 部署到gitee仓库在博客根目录下运行git bash或命令行窗口 12345678//清除数据hexo clean//重新渲染hexo g//本地local host预览hexo s//部署到gitee仓库hexo d gitee使用gitee pages在gitee的仓库下依次点击服务——&gt;Gitee Pages——&gt;启动 提示：已开启 Gitee Pages 服务，网站地址：https://用户名.gitee.io 即可访问 注意：使用gitee作为博客网站时，在每次推送到仓库后都要手动更新，即：服务——&gt;Gitee Pages——&gt;更新 网站才会更新","text":"使用gitee(码云)作为博客地址在完成github和hexo搭建好个人博客系统后，再将博客部署到在gitee上 创建gitee仓库新建仓库 为了使用用户名.gitee.io作为博客的地址，仓库名需要直接填写成gitee用户名，这一点是不同与github 原因：gitee pages在生成页面时会默认地添加后缀.gitee.io 仓库名：gitee用户名 开源：公开(可以作为giteement存放评论的仓库，另外新建一个也是可以的) 配置修改博客根目录下的_config.ym文件 12345678910# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://用户名.gitee.io/# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@gitee.com:用户名/用户名.git branch: master 部署到gitee仓库在博客根目录下运行git bash或命令行窗口 12345678//清除数据hexo clean//重新渲染hexo g//本地local host预览hexo s//部署到gitee仓库hexo d gitee使用gitee pages在gitee的仓库下依次点击服务——&gt;Gitee Pages——&gt;启动 提示：已开启 Gitee Pages 服务，网站地址：https://用户名.gitee.io 即可访问 注意：使用gitee作为博客网站时，在每次推送到仓库后都要手动更新，即：服务——&gt;Gitee Pages——&gt;更新 网站才会更新 giteement评论功能生成gitee第三方应用创建第三方应用 应用名称：自定义 应用描述：自定义 应用主页：https://用户名.gitee.io/ 应用回调：https://用户名.gitee.io/ 权限：issues notes 在创建成功后会生成Client ID Client Secret 添加相关文件在themes/yilia/layout路径index.ejs文件中添加以下代码 123&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;giteement.oss-cn-beijing.aliyuncs.com&#x2F;oauthcallback.browser.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; Oauthcallback();&lt;&#x2F;script&gt; 在themes/yilia/layout/_partial路径下article.ejs文件中添加以下代码 123456789101112131415161718192021222324252627 &lt;% if (theme.gitment_owner &amp;&amp; theme.gitment_repo &amp;&amp;theme.gitment_oauth &amp;&amp; theme.gitment_oauth.client_id &amp;&amp; theme.gitment_oauth.client_secret)&#123; %&gt; &lt;%- partial(&#39;post&#x2F;gitment&#39;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt;&lt;!--在此处以下代码--&gt;&lt;!--giteement评论功能--&gt;&lt;% if (theme.giteement.enable)&#123; %&gt;&lt;div id&#x3D;&quot;giteementDiv&quot;&gt;&lt;&#x2F;div&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;giteement.oss-cn-beijing.aliyuncs.com&#x2F;default.css&quot;&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;giteement.oss-cn-beijing.aliyuncs.com&#x2F;giteement.browser.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;var giteement &#x3D; new Giteement(&#123; id: &#39;&lt;%- post.date.format(&#39;YYYYMMDDHHmmss&#39;) %&gt;&#39;, owner: &#39;&lt;%- theme.giteement.giteeID %&gt;&#39;, repo: &#39;&lt;%- theme.giteement.repo %&gt;&#39;, backcall_uri: &#39;&lt;%- theme.giteement.redirect_uri %&gt;&#39;, oauth_uri: &#39;&lt;%- theme.giteement.oauth_uri %&gt;&#39;, oauth: &#123; client_id: &#39;&lt;%- theme.giteement.ClientID %&gt;&#39;, client_secret: &#39;&lt;%- theme.giteement.ClientSecret %&gt;&#39; &#125;,&#125;)giteement.render(&#39;giteementDiv&#39;)&lt;&#x2F;script&gt; 配置修改themes/yilia目录下的themes/yilia/_config.ym文件 123456789101112giteement: enable: true# 是否启用码云评论系统 # 是否使用官方js(false可以提升访问速度) remote: false redirect_uri: '' # 应用回调地址(请和配置的第三方应用保持一致) oauth_uri: https://cors-anywhere.herokuapp.com/https://gitee.com/oauth/token giteeID: # 你的码云账号英文名 # 存储评论的 repo name(需要在码云仓库创建公开仓库) repo: #公开仓库可直接填写用户名 gitment_oauth: client_id: '' #client ID client_secret: '' #client secret 渲染 预览 初始化重新渲染，预览 分别执行 hexo clean hexo g hexo s 在localhost:4000下预览 注意：每篇博客需要登录gitee账号初始化评论后才能使用 其他方式(推荐)使用上述方法，评论区域的ui并不美观，可选择yilia-plus主题替代 使用yilia-plus主题hexo-theme-yilia-plus 克隆地址：https://github.com/JoeyBling/hexo-theme-yilia-plus.git 这个主题支持giteement评论功能，只需要注册好gitee第三方应用然后直接进行配置，无需手动添加相关文件","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lao-biao.github.io/categories/hexo/"}],"tags":[{"name":"gitee","slug":"gitee","permalink":"https://lao-biao.github.io/tags/gitee/"},{"name":"giteement","slug":"giteement","permalink":"https://lao-biao.github.io/tags/giteement/"}]},{"title":"hexo+yilia+github搭建个人博客","slug":"hexo+yilia+github搭建个人博客","date":"2020-04-05T04:00:00.000Z","updated":"2020-07-06T03:12:29.230Z","comments":true,"path":"articles/73e911cd.html","link":"","permalink":"https://lao-biao.github.io/articles/73e911cd.html","excerpt":"前言学习使用hexo框架搭建个人博客，开启博客之旅。 下载工具 nodejs nodejs网址 根据操作系统下载对应的版本 git git网址 检查工具windows操作系统下打开命令行窗口，执行命令 node -v npm -v git -v 如果返回对应的版本号信息，说明安装成功","text":"前言学习使用hexo框架搭建个人博客，开启博客之旅。 下载工具 nodejs nodejs网址 根据操作系统下载对应的版本 git git网址 检查工具windows操作系统下打开命令行窗口，执行命令 node -v npm -v git -v 如果返回对应的版本号信息，说明安装成功 博客框架基础部分在电脑的合适位置创建文件夹（blog）用于存放和管理博客，在此文件路径下执行命令行窗口（Mac用户需要获取管理员权限），执行下列命令 12345678//安装淘宝的cnpm管理器,其他国内镜像源也可npm install -g cnpm --registry=http://registry.npm.taobao.org //安装hexo基础框架cnpm install -g hexo-cli//初始化生成框架文件hexo init 生成hexo框架文件后，默认会生成一篇hello word的博客，博客框架基本搭建好了，可以通过本地的端口预览，执行命令hexo s 即可通过本地的4000端口访问博客 地址http://localhost:4000/ 上传到github 在github创建公开仓库：github账户名.github.io 仓库名必须是以 github账户名+.github.io 命名 修改hexo本地设置：通过记事本更改文件夹_config.yml的以下内容 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:xxxx/xxxx.github.io.git #仓库的ssh地址或http地址 branch: master #默认是master分支 在blog文件夹下执行窗口命令安装git自动部署插件 12// 安装git自动部署插件cnpm install --save hexo-deployer-git 推送到github仓库 123456//清理hexo clean//生成 hexo generatehexo g//推送到仓库 hexo deployhexo d 推送成功后即可通过https://xxxx.github.io 访问博客 修改主题从github上clone导入yilia主题文件 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 数据以json的形式保存cnpm i hexo-generator-json-content --save 修改hexo根目录下的_config.yml : 1234567891011121314151617181920212223# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yiliajsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 配置yilia文件下的_config.yml : 目录：/themes/yilia/config.yml）,根据个人喜好进行设置 修改好配置信息后，通过 hexo clean hexo g hexo s在本地预览 执行 hexo clean hexo g hexo d上传同步到github仓库","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lao-biao.github.io/categories/hexo/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://lao-biao.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"android动态权限申请","slug":"Android动态申请权限","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:08:39.153Z","comments":true,"path":"articles/821fe050.html","link":"","permalink":"https://lao-biao.github.io/articles/821fe050.html","excerpt":"","text":"Android 6.0以上动态申请权限添加相关权限在清单文件中添加相关权限 1&lt;uses-permission android:name=\"android.permission.××××\"&gt;&lt;/uses-permission&gt; 检查权限-动态申请权限-申请结果 检查权限 动态申请权限 处理权限申请结果 12345678910111213141516171819202122232425262728private String strPermission =Manifest.permission.××××;private final static int ××××_REQUEST_CODE=1; //请求码，不同的权限设置成不同的值public void requestPermissions(String strPermission) &#123; if (ContextCompat.checkSelfPermission( this, strPermission) != PERMISSION_GRANTED) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale( this, strPermission)) &#123; Toast.makeText(this, \"需要××××权限\", Toast.LENGTH_LONG).show(); &#125; else &#123; ActivityCompat.requestPermissions( this, new String[]&#123; strPermission&#125;,×××× _REQUEST_CODE); &#125; &#125;&#125;//重写onRequestPermissionsResult()方法public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); String requestPermissionsResult = \"\"; if (requestCode == ××××_REQUEST_CODE) &#123; for (int i = 0; i &lt; permissions.length; i++) &#123; if (grantResults[i] == PERMISSION_GRANTED) &#123; requestPermissionsResult += permissions[i] + \" 申请成功\\n\"; &#125; else &#123; requestPermissionsResult += permissions[i] + \" 申请失败\\n\"; &#125; &#125; &#125; Toast.makeText(this, requestPermissionsResult, Toast.LENGTH_SHORT).show();&#125; 执行操作123456requestPermissions(String strPermission);try&#123; //要执行的操作&#125;catch (Exception e)&#123; e.printStackTrace();&#125;","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"动态权限","slug":"动态权限","permalink":"https://lao-biao.github.io/tags/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"}]},{"title":"android studio低版本使用recyclerview","slug":"AndroidStudio使用RecyclerView组件","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:08:45.956Z","comments":true,"path":"articles/f71edc35.html","link":"","permalink":"https://lao-biao.github.io/articles/f71edc35.html","excerpt":"","text":"1. 添加依赖包&nbsp;&nbsp;&nbsp;&nbsp; open Module Settings→Dependencies→add Library Dependency)2. AndroidMainfest.xml文件 123&lt;application android:appComponentFactory=\"\" tools:replace=\"android:appComponentFactory\"&gt; 在gradle.properties文件中添加以下代码123android.enableJetifier=trueandroid.useAndroidX=trueorg.gradle.jvmargs=-Xmx1536m 在原有工程中使用androidX.RecyclerView会出现报错解决方法：在AndroidManifest文件下右键Refactor→Migrate to AndroidX","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"recyclerview","slug":"recyclerview","permalink":"https://lao-biao.github.io/tags/recyclerview/"}]},{"title":"android sqlite学习","slug":"Android SQLite学习","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:36:12.305Z","comments":true,"path":"articles/eb7c6dc.html","link":"","permalink":"https://lao-biao.github.io/articles/eb7c6dc.html","excerpt":"创建数据库 写一个类继承SQLOpenHelper 实现里面的方法，创建构造方法 调用子类对象，再使用getWriteableDatabase()或getReadableDatabase()方法即可创建数据库 参数解释 12345SQLiteOpenHelper context 上下文 name 数据库名称 factory 游标工厂 version 版本号","text":"创建数据库 写一个类继承SQLOpenHelper 实现里面的方法，创建构造方法 调用子类对象，再使用getWriteableDatabase()或getReadableDatabase()方法即可创建数据库 参数解释 12345SQLiteOpenHelper context 上下文 name 数据库名称 factory 游标工厂 version 版本号 重写SQLiteHelper类 123456789101112131415161718192021222324252627282930313233package com.study.sqlitestudy;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.util.Log;public class DatabaseHelper extends SQLiteOpenHelper &#123; private static final String TAG =\"database\" ; public DatabaseHelper(Context context) &#123; super(context, Constants.DATABASE_NAME, null, Constants.VERSION_CODE); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; //第一次创建数据库时的回调 Log.d(TAG, \"创建数据库\"); //log打印 D/database: 创建数据库 String sql=\"create table \"+Constants.TABLE_NAME+\"(_id integer,age integer,name varchar,salary integer);\"; db.execSQL(sql); //执行sql语句 &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; //升级数据库时的回调 //更新版本号必须满足 newVersion&gt;oldVersion 不能降级，否则会报异常，程序崩溃 Log.d(TAG, \"更新数据库\"); //log打印 D/database: 更新数据库 String sql=\"alter table \"+Constants.TABLE_NAME+\" add phone integer;\"; db.execSQL(sql); &#125;&#125; 数据库相关常量 1234567package com.study.sqlitestudy;public class Constants &#123; public static final int VERSION_CODE =2; public static final String DATABASE_NAME =\"demo\"; public static final String TABLE_NAME = \"demotable\";&#125; MainActivity创建数据库 12DatabaseHelper helper=new DatabaseHelper(this);helper.getWritableDatabase(); 编写Dao操作类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.study.sqlitestudy;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.util.Log;public class Dao &#123; private static final String TAG =\"Dao\" ; private final DatabaseHelper helper; public Dao(Context context)&#123; helper = new DatabaseHelper(context); &#125; public void insert()&#123; SQLiteDatabase db=helper.getWritableDatabase(); String sql=\"insert into \"+Constants.TABLE_NAME+ \"(_id,age,name,salary) values(?,?,?,?)\"; db.execSQL(sql,new Object[]&#123;101,20,\"Wang\",1000&#125;); db.close(); &#125; public void delete()&#123; SQLiteDatabase db=helper.getWritableDatabase(); String sql=\"delete from \"+Constants.TABLE_NAME+ \" where age = 20\"; db.execSQL(sql); db.close(); &#125; public void update()&#123; SQLiteDatabase db=helper.getWritableDatabase(); String sql=\"update \"+Constants.TABLE_NAME+ \" set salary = 2000 where age = 20\"; db.execSQL(sql); db.close(); &#125; public void query()&#123; SQLiteDatabase db=helper.getWritableDatabase(); String sql=\"select * from \"+Constants.TABLE_NAME+ \" where age = 20\"; Cursor cursor = db.rawQuery(sql,null); while(cursor.moveToNext())&#123; int index = cursor.getColumnIndex(\"name\"); String name = cursor.getString(index); Log.d(TAG, \"name :\"+name); &#125; cursor.close(); db.close(); &#125;&#125; 编写测试类 数据库升级 数据库的增删改查 1234567891011121314151617181920212223242526272829303132333435package com.study.sqlitestudy;import android.support.test.InstrumentationRegistry;import android.support.test.runner.AndroidJUnit4;import org.junit.Test;import org.junit.runner.RunWith;@RunWith(AndroidJUnit4.class)public class TestDatabase&#123; @Test public void testCreate()&#123; &#125; @Test public void testInsert()&#123; Dao dao=new Dao(InstrumentationRegistry.getTargetContext()); dao.insert(); &#125; @Test public void testDelete()&#123; Dao dao=new Dao(InstrumentationRegistry.getTargetContext()); dao.delete(); &#125; @Test public void testUpdate()&#123; Dao dao=new Dao(InstrumentationRegistry.getTargetContext()); dao.update(); &#125; @Test public void testQuery()&#123; Dao dao=new Dao(InstrumentationRegistry.getTargetContext()); dao.query(); &#125;&#125; 使用Android的API操作增删改查增 insert123456789101112import android.content.ContentValues;public void insert()&#123; SQLiteDatabase db=helper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(\"_id\",1001); values.put(\"age\",20); values.put(\"name\",\"Zhang\"); values.put(\"salary\",1000); db.insert(Constants.TABLE_NAME,null,values); db.close();&#125; 删 delete123456ContentValues values=new ContentValues();String []whereArgs=&#123;String.valueOf(20)&#125;;String whereClasuse=\"age=?\";int delete = db.delete(Constants.TABLE_NAME, whereClasuse, whereArgs);Log.d(TAG, \"delete: \"+delete);db.close(); 改 update12345ContentValues values=new ContentValues();values.put(\"salary\",5000);String whereClasuse=\"age=?\"; //字段名称String[] whereArgs=&#123;String.valueOf(25)&#125;; //值db.update(Constants.TABLE_NAME,values,whereClasuse,whereArgs); 查 query123456789101112131415SQLiteDatabase db=helper.getWritableDatabase();Cursor cursor=db.query(Constants.TABLE_NAME,null,null,null,null,null,null);//参数：数据表名称,columns,selection,selectionArgs,groupBy分组,having,orderBy排序while(cursor.moveToNext())&#123; int id = cursor.getInt(0); String name = cursor.getString(1); Log.d(TAG, \"query: \"+id); Log.d(TAG, \"query: \"+name); // D/Dao: query: 100 // D/Dao: query: 20 // D/Dao: query: 100 // D/Dao: query: 25&#125;cursor.close(); //关闭游标资源db.close(); 数据库事务 安全性 _id age name 1001 20 Zhang 1002 25 Li 操作：Zhang salary - 500 且 Li salary + 500在操作过程中出现异常，则会只执行一部分，使用SQLite的事务可以解决这个不同步的问题，防止数据出错 12345678910111213SQLiteDatabase db=helper.getWritableDatabase();db.beginTransaction(); //开启事务try&#123; db.execSQL(\"update demotable set salary = 1000-500 where name = 'Zhang'\"); int i=10/0; //扔出异常 db.execSQL(\"update demotable set salary = 5000+500 where name = 'Li'\"); db.setTransactionSuccessful();&#125;catch (Exception e)&#123; e.printStackTrace();&#125;finally &#123; db.endTransaction(); db.close();&#125; 执行结果后，数据没有发生变化屏蔽掉扔出异常的语句后 _id age name 1001 20 Zhang 1002 25 Li 高效性 在使用事务的情况下，执行速度比普通条件下更快。","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"android","slug":"notes/android","permalink":"https://lao-biao.github.io/categories/notes/android/"}],"tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://lao-biao.github.io/tags/sqlite/"}]},{"title":"android界面跳转","slug":"Android界面跳转","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:09:47.605Z","comments":true,"path":"articles/de41b12e.html","link":"","permalink":"https://lao-biao.github.io/articles/de41b12e.html","excerpt":"非响应式跳转跳转后的界面创建跳转后的界面代码和布局 1234567public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); &#125;&#125; activity_second.xml布局文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center\"&gt; &lt;TextView android:id=\"@+id/tv_text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"\"/&gt;&lt;/LinearLayout&gt; 在AndroidManifest.xml中注册 1&lt;activity android:name=\".SecondActivity\"&gt;&lt;/activity&gt;","text":"非响应式跳转跳转后的界面创建跳转后的界面代码和布局 1234567public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); &#125;&#125; activity_second.xml布局文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center\"&gt; &lt;TextView android:id=\"@+id/tv_text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"\"/&gt;&lt;/LinearLayout&gt; 在AndroidManifest.xml中注册 1&lt;activity android:name=\".SecondActivity\"&gt;&lt;/activity&gt; 显式意图跳转123456Intent intent=new Intent(MainActivity.this,SecondActivity.class);//键值对的方式传输//internt.putExtra(\"\",\"\");intent.putExtra(\"name\",etName.getText().toString()); //传递用户名intent.putExtra(\"pwd\",etPwd.getText().toString()); //传递密码startActivity(intent); //启动 隐式意图跳转在AndroidManifest.xml添加过滤器 123456789&lt;!--action:包名.信息(自定义)--&gt;&lt;!--category(类别)--&gt;&lt;!--data(数据)--&gt;&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.study.USER_INFO\"&gt;&lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"&gt;&lt;/category&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 123456Intent intent=new Intent(); //隐式意图intent.setAction(\"com.study.USER_INFO\");intent.addCategory(intent.CATEGORY_DEFAULT); //相当于intent.addCategory(android.intent.category.DEFAULT）;intent.putExtra(\"name\",etName.getText().toString()); //传递用户名intent.putExtra(\"pwd\",etPwd.getText().toString()); //传递密码startActivity(intent); //启动 数据获取12345Intent intent = getIntent(); //获取上级界面所传递的数据String name = intent.getStringExtra(\"name\");String pwd = intent.getStringExtra(\"pwd\");TextView tvText = findViewById(R.id.tv_text);tvText.setText(\"账号：\"+name+\" 密码：\"+pwd); //显示信息 响应式跳转使用startActivity()方法只能将上层界面的信息传递到下层界面，不能实现界面信息的回传，响应式界面跳转通过startActivityForResult()方法在启动下层界面时发出请求码，下层界面通过result()方法发送结果码，并将信息传递到上层界面 123456789101112131415161718//上层界面跳转下层界面private static final int REQUEST_CODE = 1; //请求码private static final int RESULT_CODE=2; //结果码Intent intent=new Intent(); //显式或隐式跳转intent.putExtra(); //传递到下层界面的信息startActivityForResult(intent,REQUEST_CODE ); //启动//上层界面接收结果//重写onActivityResult()方法@Overrideprotected void onActivityResult(int requestCode, int resultCode,Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode==REQUEST_CODE ) &#123; if (resultCode==RESULT_CODE) &#123; ... &#125; &#125;&#125; 123456//下层界面private static final int RESULT_CODE=2; //结果码Intent intent = new Intent();intent.putExtra(); //传递给上层界面的信息setResult(RESULT_CODE, intent);finish(); setResult()方法只有在finish()方法执行前才能响应，把setResult()写在onDestroy()中无法实现请求的响应,如果需要在activity结束时回传信息，可以采取监听返回键的方式实现回传。 1234567@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra(); setResult(RESULT_CODE, intent); super.onBackPressed();&#125;","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"界面跳转","slug":"界面跳转","permalink":"https://lao-biao.github.io/tags/%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC/"}]},{"title":"android四大组件--broadcast","slug":"Android广播与广播接收者","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:36:22.340Z","comments":true,"path":"articles/c231612.html","link":"","permalink":"https://lao-biao.github.io/articles/c231612.html","excerpt":"使用广播来接收系统内部发送的广播动态注册广播监听电量变化在应用的活动页面创建时启动广播，通过继承广播接收者的类来接收系统内部发送的广播，在活动页面销毁时取消广播，以防止内存泄漏的问题。 123456789101112131415161718192021222324252627282930313233private BatteryLevelReceiver mBatteryStateReceiver; //接收广播@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //意图过滤 IntentFilter intentFilter=new IntentFilter(); //设置频道--电量变化 intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED); //添加广播接收者 mBatteryStateReceiver = new BatteryLevelReceiver(); //启动广播 this.registerReceiver(mBatteryStateReceiver,intentFilter);//参数：BroadcastReceiver,IntentFilter&#125;private class BatteryLevelReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); Log.d(TAG, \"action:\" + action); Log.d(TAG, \"batteryLevel:\"+intent.getIntExtra(BatteryManager.EXTRA_LEVEL,0)); &#125;&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (mBatteryStateReceiver!=null) &#123; unregisterReceiver(mBatteryStateReceiver); //取消广播，防止内存泄漏 &#125;&#125;","text":"使用广播来接收系统内部发送的广播动态注册广播监听电量变化在应用的活动页面创建时启动广播，通过继承广播接收者的类来接收系统内部发送的广播，在活动页面销毁时取消广播，以防止内存泄漏的问题。 123456789101112131415161718192021222324252627282930313233private BatteryLevelReceiver mBatteryStateReceiver; //接收广播@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //意图过滤 IntentFilter intentFilter=new IntentFilter(); //设置频道--电量变化 intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED); //添加广播接收者 mBatteryStateReceiver = new BatteryLevelReceiver(); //启动广播 this.registerReceiver(mBatteryStateReceiver,intentFilter);//参数：BroadcastReceiver,IntentFilter&#125;private class BatteryLevelReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); Log.d(TAG, \"action:\" + action); Log.d(TAG, \"batteryLevel:\"+intent.getIntExtra(BatteryManager.EXTRA_LEVEL,0)); &#125;&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (mBatteryStateReceiver!=null) &#123; unregisterReceiver(mBatteryStateReceiver); //取消广播，防止内存泄漏 &#125;&#125; 静态注册广播监听系统开机静态注册广播需要在清单文件中添加对应的action（category、data），监听系统的开机还需要添加响应的系统权限。使用静态注册广播不能释放内存，一直在监听，对内存占用比较大。 1234567&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"&gt;&lt;/uses-permission&gt;&lt;receiver android:name=\".BootCompletedReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;!--开机完成的action--&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 123456789public class BootCompletedReceiver extends BroadcastReceiver&#123; private static final String TAG = \"BootCompletedReceiver\"; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(TAG, \"\"+intent.getAction()); Toast.makeText(context,\"开机完成\",Toast.LENGTH_LONG).show();//开机完成时弹出提示信息 &#125;&#125; 有序广播发送有序广播，接收者按照优先级依次收到广播，高优先级的广播接收者可以中止广播，也能修改广播内容。通过设置 android:priority 的值来设置优先级，priority的大小为-1000到1000，默认值为0在Android8.0后需要动态注册广播才能接收，使用静态注册广播需要指定包名，静态广播注册报错 Background execution not allowed 1234567891011121314151617&lt;activity android:name=\".SendOrderBroadcast\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;receiver android:name=\".HighLevelBroadcastReceiver\"&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"sendOrderBroadcastTest\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=\".LowLevelBroadcastReceiver\"&gt; &lt;intent-filter android:priority=\"0\"&gt; &lt;action android:name=\"sendOrderBroadcastTest\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 123456789101112131415161718192021222324252627282930//开启广播private void broadcastSender() &#123; //使用动态注册广播的方式 HighLevelBroadcastReceiver highLevelBroadcastReceiver=new HighLevelBroadcastReceiver(); LowLevelBroadcastReceiver lowLevelBroadcastReceiver=new LowLevelBroadcastReceiver(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(\"sendOrderBroadcastTest\"); registerReceiver(highLevelBroadcastReceiver,intentFilter); registerReceiver(lowLevelBroadcastReceiver,intentFilter); /* 使用静态注册指定广播接收者,指定包名 Intent intent=new Intent(); ComponentName componentName=new ComponentName(SendOrderBroadcast.this,HighLevelBroadcastReceiver.class); intent.setComponent(componentName); intent.setAction(\"sendOrderBroadcastTest\"); sendBroadcast(intent,null); */&#125;//receivePermission在接收时接收端需要添加权限-----Manifest文件//点击发送有序广播按钮的消息映射public void sendOrderBroadcast(View view)&#123; //发送广播内容 Intent intent=new Intent(); intent.setAction(\"sendOrderBroadcastTest\"); Bundle bundle=new Bundle(); bundle.putCharSequence(\"content\",\"这是一条有序广播\"); //参数:Intent,receivePermission,resultReceiver,scheduler,initialCode,initialData,initialExtras sendOrderedBroadcast(intent,null,null,null, Activity.RESULT_OK,null,bundle);&#125; 12345678910111213141516public class HighLevelBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = \"HighLevelReceiver\"; @Override public void onReceive(Context context, Intent intent) &#123; //中止广播 //abortBroadcast()调用这个方法能中止广播的发送，低优先级的广播接收者无法接收 //接收广播内容 Bundle resultExtras = getResultExtras(true); String content = resultExtras.getCharSequence(\"content\").toString(); Log.d(TAG, \"content:\"+content); //log输出接收到的广播内容 //修改广播内容，直接重写广播内容 resultExtras.putCharSequence(\"content\",\"有序广播内容被修改！\"); setResultExtras(resultExtras); &#125;&#125; 1234567891011public class LowLevelBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = \"LowLevelReceiver\"; @Override public void onReceive(Context context, Intent intent) &#123; //接收广播内容 Bundle resultExtras = getResultExtras(true);//参数为false时则不接收上级广播添加的内容 String content = resultExtras.getCharSequence(\"content\").toString(); Log.d(TAG, \"content:\"+content); &#125;&#125; 权限广播发送时添加权限在清单文件中添加权限信息&lt; permission android:name=&quot;&quot;&gt;&lt; /permission&gt;，在调用sendOrderedBroadcast()方法时指定参数receivePermission添加权限，(在manifest文件中添加完权限后需要make project后才能使用)Manifest.permission.权限名，接收端在接收时需要在清单文件中添加&lt; uses-permission android:name=&quot;&quot;&gt;&lt; /uses-permission&gt;相应的权限信息 广播接收者添加权限在清单文件中添加权限信息&lt; permission android:name=&quot;&quot;&gt;&lt; /permission&gt;，在广播接收者的注册信息中添加指定的权限信息android:permission=&quot;&quot;，广播发送端只有添加了指定的权限&lt; uses-permission android:name=&quot;&quot;&gt;&lt; /uses-permission&gt;后才能给广播接收者发送广播。","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"android","slug":"notes/android","permalink":"https://lao-biao.github.io/categories/notes/android/"}],"tags":[{"name":"broadcast","slug":"broadcast","permalink":"https://lao-biao.github.io/tags/broadcast/"}]},{"title":"Android数据的存储","slug":"Android数据存储","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:10:02.255Z","comments":true,"path":"articles/56c6f16a.html","link":"","permalink":"https://lao-biao.github.io/articles/56c6f16a.html","excerpt":"错误的存储方式对一个简单的登录页面进行用户数据的保存，将数据存储到应用的数据目录下。 在写入文件时，文件路径不能直接为android的根目录 例如： 1private String userFileName=\"/user.txt\"; //文件名 运用IO流写出数据 12345678910111213private void saveUserInfo(String name, String pwd, String phone) &#123; File user=new File(userFileName); try &#123; if(!user.exists())&#123; user.createNewFile(); &#125; FileOutputStream userFile=new FileOutputStream(user); userFile.write((name+\" \"+pwd+\" \"+phone).getBytes()); //以空格符为间隔存储 userFile.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; 报错信息（异常）： 1java.io.IOException: Read-only file system","text":"错误的存储方式对一个简单的登录页面进行用户数据的保存，将数据存储到应用的数据目录下。 在写入文件时，文件路径不能直接为android的根目录 例如： 1private String userFileName=\"/user.txt\"; //文件名 运用IO流写出数据 12345678910111213private void saveUserInfo(String name, String pwd, String phone) &#123; File user=new File(userFileName); try &#123; if(!user.exists())&#123; user.createNewFile(); &#125; FileOutputStream userFile=new FileOutputStream(user); userFile.write((name+\" \"+pwd+\" \"+phone).getBytes()); //以空格符为间隔存储 userFile.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; 报错信息（异常）： 1java.io.IOException: Read-only file system 在Android系统中，每一个应用都是独立的，其权限是有限的，不可操作其他应用的内容。 “/“为根目录，这点不同于windows系统。 使用其他的文件名，则会报找不到文件的异常 1234private String userFileName=\"/com.exercise.myapplication/user.txt\";...java.io.IOException: No such file or directory //异常 存储到包名路径下当前用户—文件名应该为 : /data/data/应用包名路径/文件名 在android6.0后支持多用户 应用文件路径为： /data/user/0/应用包名路径 （0 为用户号） 在应用包路径下有 files 和 cache 两个文件夹 在MainActivity.java中可以使用 getFilesDir() 方法得到files的路径,用 getCacheDir() 方法可以得到cache的路径，再使用拼接的方式设置文件的全路径 1private String userFileName=\"user.txt\"; //文件名 1234File files=this.getFilesDir(); //得到files路径File cache=this.getCacheDir(); //得打cache路径File user=new File(files,userFileName);FileOutputStream userFile=new FileOutputStream(user); 读取文件并在应用可视时显示在对应的TextView中 123456789101112131415161718@Overrideprotected void onResume() &#123; super.onResume(); try &#123; FileInputStream user=this.openFileInput(userFileName); BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(user)); String info=bufferedReader.readLine(); String[] splits=info.split(\" \"); //以空格符为界切割 String name=splits[0]; String pwd=splits[1]; String phone=splits[2]; etName.setText(name); //用户名 etPwd.setText(pwd); //密码 etPhone.setText(phone); //手机号 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 数据存在sdcard中 将数据存在sdcard中： 在 manifest 的 AndroidManifest.xml 打开storage的读写权限 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; 在Android6.0后，读写storage需要动态的申请权限(或者直接在设置里更改应用的存储权限) storage的相对路径: /storage/emulated/0 (内部存储) （1表示外置内存卡） 1234567891011121314151617181920212223242526272829303132333435363738private void saveInSdcard() &#123; requestPermissions(); File storagePath=new File(Environment.getExternalStorageDirectory().getAbsolutePath());//获取storage的相对路径 File file=new File(storagePath,\"text.txt\"); //文件路径 try &#123; FileOutputStream fos=new FileOutputStream(file); fos.write((\"text words\").getBytes()); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;public void requestPermissions() &#123;//检查是否获取读取权限 if (ContextCompat.checkSelfPermission( this, Manifest.permission.READ_EXTERNAL_STORAGE) != PERMISSION_GRANTED) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale( this, Manifest.permission.READ_EXTERNAL_STORAGE)) &#123; Toast.makeText(this, \"需要读写权限\", Toast.LENGTH_LONG).show(); //提示未获取读取权限 &#125; else &#123; ActivityCompat.requestPermissions( this, new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); //请求读写权限 &#125; &#125;&#125;//重写onRequestPermissionsResult()方法public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); String requestPermissionsResult = \"\"; if (requestCode == 1) &#123; for (int i = 0; i &lt; permissions.length; i++) &#123; if (grantResults[i] == PERMISSION_GRANTED) &#123; requestPermissionsResult += permissions[i] + \" 申请成功\\n\"; &#125; else &#123; requestPermissionsResult += permissions[i] + \" 申请失败\\n\"; &#125; &#125; &#125; Toast.makeText(this, requestPermissionsResult, Toast.LENGTH_SHORT).show();&#125;","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"数据存储","slug":"数据存储","permalink":"https://lao-biao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"Android非ui线程更新ui","slug":"Android非ui线程更新ui","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:09:23.263Z","comments":true,"path":"articles/89935aa5.html","link":"","permalink":"https://lao-biao.github.io/articles/89935aa5.html","excerpt":"","text":"情景在开发中会遇到在通过子线程获取数据，然后子线程需要更新ui，但是在android中这是不被允许的(子线程不能更新ui,android4.0开始)，可以通过三种方法解决(我已知的方法)。 解决方案方案一在需要更新ui的语句前后分别加上 Looper.prepare(); Looper.loop(); 123Looper.prepare();更新ui的语句Looper.loop(); 方案二调用android的api runOnUiThread() 1234567runOnUiThread(new Runnable() &#123; @Override public void run() &#123; // UI更新执行语句--以Toast为例 Toast.makeText(MainActivity.this, \"message\",Toast.LENGTH_SHORT).show(); &#125;&#125;); 方案三新建一个BaseApplication的类用来管理Context ，Handler，在需要更新ui的时候调用BaseApplication.getHandler().post(),用这个方法可以在一定程度上减少context和thread问题 Context 可应用的组件或控件 activity service 基于全局显示的控件 123//在manifest.xml文件中需要添加入口&lt;application android:name=\".BaseApplication\"/&gt; 1234567891011121314151617181920public class BaseApplication extends Application &#123; private static Handler sHandler = null; private static Context sContext = null; @Override public void onCreate() &#123; super.onCreate(); sHandler = new Handler(); sContext = getBaseContext(); &#125; public static Context getAppContext() &#123; return sContext; &#125; public static Handler getHandler() &#123; return sHandler; &#125;&#125; 调用代码 123456BaseApplication.getHandler().post(new Runnable() &#123; @Override public void run() &#123; // ui更新语句 &#125;&#125;);","categories":[{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"}],"tags":[{"name":"ui","slug":"ui","permalink":"https://lao-biao.github.io/tags/ui/"}]},{"title":"adb简单命令","slug":"adb简单命令","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-05T12:56:09.778Z","comments":true,"path":"articles/9632f7ff.html","link":"","permalink":"https://lao-biao.github.io/articles/9632f7ff.html","excerpt":"设备1. 设备查看1adb devices 2. 设备重新挂载对android的内部系统文件进行查看,需要获得root权限(adb root)，模拟器Android 6.0以后需要第三方软件root才能成功 123456adb remount//有的Android系统需要两次root才能挂载adb rootadb rebootadb rootadb remount 3.设备重启1adb reboot 4.设备关机1adb reboot -p 5.多设备操作1adb -s 设备名称(devices查看) 命令","text":"设备1. 设备查看1adb devices 2. 设备重新挂载对android的内部系统文件进行查看,需要获得root权限(adb root)，模拟器Android 6.0以后需要第三方软件root才能成功 123456adb remount//有的Android系统需要两次root才能挂载adb rootadb rebootadb rootadb remount 3.设备重启1adb reboot 4.设备关机1adb reboot -p 5.多设备操作1adb -s 设备名称(devices查看) 命令 常用shell命令 列出所有文件 ls(相当于dos中的dir命令) 切换路径 cd 打印当前路径 pwd 创建文件/文件夹 touch 文件名 / mkdir 文件夹名 复制文件 cp &nbsp; 原文件名(绝对路径) (路径)新文件名 移动文件 mv &nbsp; 原文件名(绝对路径) (路径)新文件名 删除文件/文件夹 rm 文件名 / rm -r 文件夹名 文本内容查看 cat 文件名(注意带后缀) (*.后缀名 打开本路径下所有的此后缀的文件) 清除屏幕 clear Push与Pull把文件推进系统1adb push (本地)文件路径 (android)文件新路径 把文件拖出系统1adb pull (android)文件路径 (本地)文件路径 logcat捕捉用于抓取log日志 12adb logcat &gt; (本地路径)文件名.logctrl+c 可停止捕捉 获取应用包名应用打开后开始记录log 12adb logcat | grep START (grep为Linux系统的指令)adb logcat | findstr START (Win10系统下) adb控制应用安装应用1adb install 应用的全路径(.apk文件) 启动应用1adb shell am start -n 包名路径/.应用入口 删除应用数据1adb shell pm clear 包名路径 卸载应用1adb uninstall 包名路径 发送广播1adb shell broadcast -a [action] 参数[--类型 key value] 截屏截图，存放在指定位置，拖出系统到当前路径下 12adb shell screencap -p /sdacrd/screen.pngadb pull /sdcard/screen.png ./ 模拟按键123adb shell input keyevent 键码(keycode)eg.home键adb shell input ketevent 3 键码可查看 android.view.KeyEvent.java文件","categories":[],"tags":[{"name":"adb","slug":"adb","permalink":"https://lao-biao.github.io/tags/adb/"}]},{"title":"chrome抓包抓取动态网站json数据","slug":"chrome抓包抓取动态网站json数据","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:10:50.434Z","comments":true,"path":"articles/aea01abd.html","link":"","permalink":"https://lao-biao.github.io/articles/aea01abd.html","excerpt":"","text":"步骤 用chrome的开发者工具获取动态网址的json数据的url 在chrome中右键检查，选择network选项 重新加载页面，找到需要爬取的数据 查看request url即为真实请求的url url即为json数据 使用json库下的loads函数将数据的类型转换成字典类型 实例代码举例：抓取百度搜索关键字–电影 的网站 123456789101112131415161718192021import reimport jsonimport requestsdef catch(page): # 每一个网页的url中的 pn 是递增的--8 pn = page * 8 url = \"https://sp0.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?resource_id=28286&amp;from_mid=1&amp;&amp;format=json&amp;ie=utf-8&amp;oe=utf-8&amp;query=%E7%94%B5%E5%BD%B1&amp;sort_key=16&amp;sort_type=1&amp;stat0=&amp;stat1=&amp;stat2=&amp;stat3=&amp;pn=\" + str( pn) + \"&amp;rn=8&amp;cb=jQuery110204230762934017789_1575516372377&amp;_=1575516372379\" res = requests.get(url) json_str_re = re.compile(\"&#123;.*&#125;\") json_str = json_str_re.search(res.text).group() movie_dict = json.loads(json_str) # 根据json—handle工具，自动排列查看所获取信息 for movie in movie_dict[\"data\"][0][\"result\"]: print(movie[\"ename\"])if __name__ == '__main__': catch(1) # 查询第一页内容 相关链接json-handle插件","categories":[{"name":"python","slug":"python","permalink":"https://lao-biao.github.io/categories/python/"}],"tags":[{"name":"json","slug":"json","permalink":"https://lao-biao.github.io/tags/json/"},{"name":"chrome抓包","slug":"chrome抓包","permalink":"https://lao-biao.github.io/tags/chrome%E6%8A%93%E5%8C%85/"}]},{"title":"css基础","slug":"css基础","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:11:50.053Z","comments":true,"path":"articles/eda1a9a9.html","link":"","permalink":"https://lao-biao.github.io/articles/eda1a9a9.html","excerpt":"css声明1、在head标签中使用style标签声明：作用：此声明一般声明当前网页的公共样式或者给某个标签的单独样式 2、在标签上使用style属性进行声明：作用：此声明会将css样式直接作用于当前标签3、在head标签中使用link标签引入外部声明好的css文件作用：此声明相当于调用,解决了不同网页间样式重复使用的问题 一次声明，随处使用问题：不同的声明给同一个标签操作了同一个样式，会使用谁的？如果CSS的声明全部在head标签中，则遵循就近原则，谁离标签近，谁就会被显示","text":"css声明1、在head标签中使用style标签声明：作用：此声明一般声明当前网页的公共样式或者给某个标签的单独样式 2、在标签上使用style属性进行声明：作用：此声明会将css样式直接作用于当前标签3、在head标签中使用link标签引入外部声明好的css文件作用：此声明相当于调用,解决了不同网页间样式重复使用的问题 一次声明，随处使用问题：不同的声明给同一个标签操作了同一个样式，会使用谁的？如果CSS的声明全部在head标签中，则遵循就近原则，谁离标签近，谁就会被显示 css的选择器 标签选择器：&nbsp;&nbsp;标签名{样式名1： 样式值1；……}&nbsp;&nbsp;作用：会将当前网页内的所有该标签增加相同的样式 id选择器：&nbsp;&nbsp;#标签名的id属性值{样式名1：样式值1；……}&nbsp;&nbsp;作用：给某个指定的标签添加指定的样式 类选择器：&nbsp;&nbsp;.类选择器名{样式名1：样式值1……}&nbsp;&nbsp;作用：给不同的标签添加相同的样式 全部选择选择器：&nbsp;&nbsp;*{样式名1：样式值1……}&nbsp;&nbsp;作用：选择所有的HTML标签，并添加相同的样式 组合选择器：&nbsp;&nbsp;选择器1，选择器2，……{样式名1：样式值1……}&nbsp;&nbsp;作用：解决不同的选择器之间重复样式的问题 子标签选择器：&nbsp;&nbsp;选择器1 子标签选择器{样式名1：样式值1……} 属性选择器：&nbsp;&nbsp;标签名[属性名=属性值]{样式名1：样式值1……}&nbsp;&nbsp;作用：选择某标签指定具备某属性并且属性值为某属性值的标签 1234567891011121314151617181920212223css的使用过程：1、声明css代码域2、使用选择选择器要添加样式的标签根据需要来： 使用*选择器来给整个页面添加基础样式 使用类选择器给不同的标签添加基础样式 使用标签选择器给某类标签添加基础样式 使用id、属性选择器、style属性声明方式给某个标签添加个性化样式3、书写样式单边框设置 border：solid 1px；字体设置 font-size:10px; font-family:\"宋体\";(设置字体格式） font-weight:bold;（设置字体加粗）字体颜色设置 color:颜色;背景颜色设置 background-color:颜色;背景图片设置 background-img:url;(图片相对路径) background-repeate：no-repeate；（设置图片不重复） background-size：cover； （图片平铺整个页面）高和宽设置 width/height:数值px浮动设置 float：left/right行高设置 line-height：10； 样式使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*添加网页背景图*/body&#123; background-image: url(img/1.jpg);/*添加背景图片*/ background-repeat: no-repeat;/*设置图片不同重复*/ background-size:cover; /*设置图片平铺*/&#125;/*使用标签选择器*/table&#123; /*background-image: url(img/0.jpg); backgroud-size: cover;*/&#125;/*设置table的行高 */tr&#123; height: 40px;&#125;/*设置td*/td&#123; width：100px; border: solid 1px red; border-radius: 10px; /*圆环*/ background-color:orange; text-align: center; color: blueviolet; font-weight: bold; letter-spacing: 10px; /*字间距*/&#125;/*------------------------------------------------------*/ul&#123; height: 50px; background-color: gray;&#125;li&#123; list-style-type: none;/*去除li的标识符*/ /*display: inline;*/ float: left;/*设置菜单左悬浮*/ width: 100px; height: 100px; &#125;li a&#123; color: black; text-decoration: none;/*设置超链接去除下划线*/ font-size: 20px; font-weight: blod; margin-left: 20px; position: relative; top: 10px;&#125; css盒子模型div标签：块级标签：主要用来进行网页布局的， 会将其中的子元素内容作为一个独立的整体存在。&nbsp;&nbsp;特点：默认宽度是页面的宽度，但可以设置&nbsp;&nbsp;高度默认是没有的，但是可以设置（可以顶开）&nbsp;&nbsp;如果子元素设置了百分比的高或者宽，占据的是div的百分比，不是页面的。盒子模型：&nbsp;&nbsp;外边距：margin 作用：用来设置元素与元素之间的间隔&nbsp;&nbsp;居中设置：margin：0px auto；上下间隔是0px，水平居中&nbsp;&nbsp;可以根据需求单独的设置上下左右的外边距&nbsp;&nbsp;边框：border 作用：用来设置元素的边框大小，可以设置上下左右&nbsp;&nbsp;内边距：padding 作用：设置内容和边框之间的间隔注意：内边距不会改变内容区域的大小，可以单独设置上下左右的内边距内容区域：&nbsp;&nbsp;作用：改变内容区域的大小&nbsp;&nbsp;设置宽和高即可改变内容区域大小 css的定位position 相对定位：relative作用：相对于原有位置移动指定的距离可以使用top，left，right，bottom来进行设置注意：其他元素的位置是不改变的 绝对定位：absolute作用：可以使用元素参照界面或者相对父元素来进行移动注意：如果父级元素成为参照元素，必须使用相对定位属性默认情况下以界面为基准进行移动的 固定定位：fixed作用：将元素固定显示在页面的指定位置，不会随着滚动条的移动而改变位置以上定位都可以使用top，bottom，left，right来进行移动； 如果相对应的元素的父级元素没有对应的position属性，会逐级向上匹配，直到body元素为止。 z-index:此属性是用来声明元素的显示级别的，等级高的会比等级低的优先显示","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"web","slug":"notes/web","permalink":"https://lao-biao.github.io/categories/notes/web/"}],"tags":[{"name":"css","slug":"css","permalink":"https://lao-biao.github.io/tags/css/"}]},{"title":"html基础","slug":"html基础","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-11T12:16:56.821Z","comments":true,"path":"articles/1a147173.html","link":"","permalink":"https://lao-biao.github.io/articles/1a147173.html","excerpt":"head标签1&lt;title&gt;&lt;/title&gt;网页标题标签 1234&lt;meta charset=\"utf-8\"/&gt; HTML5网页解析编码格式配置&lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"/&gt;HTML4文档编码格式设置 搜索优化标签：关键字、网页描述、作者 12345678&lt;meta name=\"keywords\" content=\"关键字，关键字\"/&gt; 网页关键字&lt;meta name=\"description\" content=\"描述\"/&gt; 网页描述&lt;meta name=\"author\" content=\"人名\"/&gt; 网页作者&lt;meta http-equiv=\"refresh\" content=\"5(秒数) ; url= (网址)\"&gt; 设置网页自动跳转 其他：css引入标签，js引入标签","text":"head标签1&lt;title&gt;&lt;/title&gt;网页标题标签 1234&lt;meta charset=\"utf-8\"/&gt; HTML5网页解析编码格式配置&lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"/&gt;HTML4文档编码格式设置 搜索优化标签：关键字、网页描述、作者 12345678&lt;meta name=\"keywords\" content=\"关键字，关键字\"/&gt; 网页关键字&lt;meta name=\"description\" content=\"描述\"/&gt; 网页描述&lt;meta name=\"author\" content=\"人名\"/&gt; 网页作者&lt;meta http-equiv=\"refresh\" content=\"5(秒数) ; url= (网址)\"&gt; 设置网页自动跳转 其他：css引入标签，js引入标签 标题标签1234567&lt;h(序号) &gt; &lt;/h(序号)&gt;&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; h1到h6：数据加粗显示，显示依次减弱，标题标签自动换行(属于块级标签) 属性 align：center，left，right 设置位置（对齐） 12&lt;hr /&gt; 水平线 默认居中&lt;hr width=\"600px\" size=\"20px\" color=\" \" align=\" \"/&gt; width：水平线宽度 size：水平线高度 color：水平线颜色 align：水平线位置 像素单位(px)：占据电脑屏幕的大小 百分比单位(%)：占据浏览器比例的大小 段落标签段落标签 p：会将一段数据作为整体进行显示，主要是进行css和js操作时比较方便，会自动换行(块级标签) 特点：段与段的间距比较大 换行符：br 告诉浏览器此位置进行换行 空格符：&amp;nbsp 告诉浏览器在此位置增加空格 权重标签: b 会将内容加黑显示 i 会将内容斜体显示 u 会将内容增加下划线 del 增加中划线 (以上不会自动换行可嵌套使用) 列表标签 无序列表 ul li 该标签中书写列表内容，一个li标签代表列表中的一行数据 特点：默认数据前有一个黑圆圈 有序列表 ol li 该标签中书写列表内容，一个li标签代表列表中的一行数据 特点：会自动的给列表进行顺序编码，格式从小到大并且是连续的 属性：type 可以改变顺序编码的值，可以是1，A，a，Ⅰ默认使用阿拉伯数字进行顺序编码 自定义列表 dl dt数据的标题 dd数据的具体内容，一个dd表示一条数据 图片标签img 图片资源： 123本地资源 &lt;img src=\"img/1.png \" width=\" px\"/&gt;网络资源&lt;img src=\" URL \" /&gt; src 图片路径： 相对路径 从当前文件出发查找另一个文件所经过的路径 绝对路径 从根盘符出发所查找文件的路径 属性： width 设置图片的宽度，如果是单独设置，则在图片保证不失真的情况下自动缩小或放大，单位可以是px也可以是百分比 height 设置图片的高度 title 设置图片标题，鼠标放在图片上的时候显示 alt 图片加载失败显示 图片不会自动换行(图片属于行内元素) 超链接标签a标签 href 要跳转的网页资源路径 123本地资源 &lt;a href=\"相对路径\"/&gt;文字描述&lt;/a&gt;网络资源 &lt;a href=\"URL\"/&gt;文字描述&lt;/a&gt; 网络资源(网页)的URL 属性：target =”_” 指明要跳转的网页资源的显示位置 _self在当前页中刷新显示 _blank在新的标签页中显示 _top在顶层页面中显示 _parent在父级页面中显示 超链接标签中一定要声明访问方式，可以是文字也可以是图片 锚点作用：在一张网页中进行资源跳转 12345使用：先使用超链接标签在指定的网页位置增加锚点 格式为&lt;a name =\"锚点名\"&gt;&lt;/a&gt; 再使用a标签可以跳转指定的锚点，达到网页内部资源跳转的目的 格式为&lt;a href =\"#锚点名\"&gt;&lt;/a&gt;回到网页顶部 &lt;a href =\"#\"&gt;文字描述&lt;/a&gt; 表格标签table tr 声明一行 th声明一个单元格，表头格，默认居中加黑显示 td声明一个单元格，默认局左显示原始数据 行高即改行所有单元格的宽度，单元格的宽度即列宽&gt; 属性： border 给表格添加边框 width 设置表格的宽度 height 设置表格的高度 cellpadding 设置内容居边框的距离 cellspacing 设置边框的大小(以上单位均为px) colspan=”个数” 合并左右单元格(实现行合并) rowspan=”个数” 合并上下单元格(实现列合并) 特点：默认根据数据的多少进行表格的大小显示 单元格的合并 首先确保表格是一个规整的表格 根据要合并的单元格，找到其所在的源码位置 行合并：在要合并的单元格的第一个单元格使用其属性colspan，并删除其要合并的单元格 列合并：在要合并的单元格的任一个单元格使用其属性rowspan，并删除其要合并的单元格 内嵌标签iframe src：要显示的网页资源路径(本地资源or网络资源) ​ 默认当前页面打开及加载src指向的资源 width：设置显示区域的宽度 height：设置显示区域的高度 name：设置内嵌区域的名字，结合超链接标签的target属性使用 作用 在当前网页中加载其他网页的资源，达到不同网页资源之间不相互干扰，并能在同一个页面中展现给用户的目的。 框架标签frameset rows：按照行进行切分页面 cols：按照列进行切分页面 子标签frame：进行分区域的占位，一个frame可以单独加载网页资源 属性： src：资源路径 (本地资源or网络资源) name：区域名 构建frameset，一定要删除body标签 form标签form表单标签 作用：收集并提交用户的数据给指定服务器 属性： action：收集的数据提交地址(URL) method：收集的数据的提交方式 get：适合小量数据，表单数据以？隔开拼接在URL后面，不同键值对使用&amp;符号隔开，不安全 post：适合大量数据，安全，隐式提交 表单数据的提交，要提交的表单项必须拥有name属性值，否则不会提交。提交的表单数据为键值对，键为name属性的值，值为用户书写的数据 form标签会收集其标签内部的数据 form表单的数据提交需要依赖于submit提交按钮 表单数据提交的是表单域标签的value值 form表单标签的使用：在点击数据提交时，form标签会将其内部所有form表单域标签中用户书写的数据按照method指明的提交方式提交给action属性所指明的提交地址 form表单域标签 作用：给用户提供可以进行数据书写或者选择的标签 使用： 123456&lt;!--账号密码的提交--&gt;&lt;form action=\"\" method=\"post\"&gt; 账号:&lt;input type=\"text\" name=\"\" value=\"\"/&gt; 密码:&lt;input type=\"text\" name=\"\" value=\"\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 文本框：input type： text 收集少量文本数据，用户可见 password 收集用户密码数据 name：数据提交的键，也会被js使用 value：默认值 12&lt;input type=\"text\" name=\"\" value=\"\"/&gt;&lt;input type=\"password\" name=\"\" value=\"\"/&gt; 单选框：inputtype：radio name：属性值相同的单选框只能选择一项数据 value：要提交的数据 checked：使用此属性的单选默认是选择状态 1&lt;input type=\"radio\" name=\"\" value=\"\" checked=\"\"/&gt; 多选框：inputtype：checkbox name：一个多远组需要使用相同的name属性值 value：要提交的数据 checked：使用此属性的多选框默认是选择状态 下拉框：selectname：数据提交的键名，必须声明 子标签 option：一个option标签表示一个下拉选项 value：要提交的数据 文本域 input textarea：声明一个可以书写大量文字的文本区域 name：数据提交的键名，js和css会使用 rows：声明文本框的行数 cols：声明文本框的列数 普通按钮: inputtype：button value 按钮显示的文字内容 隐藏标签 inputtype：hidden name value 一般用于提交给服务器作为方法标识，不显示在网页上。 编译预显示将源代码显示在浏览器页面中 1234&lt;pre&gt;&lt;/pre&gt;浏览预显示&lt;&gt;需要进行替换，否则浏览器会编译执行&lt; &amp;lt 尖括号不会被编码&gt; &amp;gt","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"web","slug":"notes/web","permalink":"https://lao-biao.github.io/categories/notes/web/"}],"tags":[{"name":"html","slug":"html","permalink":"https://lao-biao.github.io/tags/html/"}]},{"title":"javascrpit基础语法","slug":"javascript基础语法","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-08T02:42:37.805Z","comments":true,"path":"articles/95725add.html","link":"","permalink":"https://lao-biao.github.io/articles/95725add.html","excerpt":"js的声明 在head标签中使用script标签进行js代码域的声明 123&lt;script type=\"text/javascript\"&gt; alert(\"This is my first js.\")；//测试&lt;/script&gt; 作用：声明js代码域特点：js的代码只会作用于当前网页 在head标签中使用script标签引入外部声明好的js文件 1&lt;script type=\"text/javascript\" src=\"相对路径\" charset=\"utf-8\"&gt;&lt;/script&gt; 作用：引入外部声明好的js文件特点：实现js代码的重复使用，避免代码的冗余注意：因为js在HTML文档中是一门单独的语言，可以声明在文档中的任意位置 一般情况下声明在head标签中","text":"js的声明 在head标签中使用script标签进行js代码域的声明 123&lt;script type=\"text/javascript\"&gt; alert(\"This is my first js.\")；//测试&lt;/script&gt; 作用：声明js代码域特点：js的代码只会作用于当前网页 在head标签中使用script标签引入外部声明好的js文件 1&lt;script type=\"text/javascript\" src=\"相对路径\" charset=\"utf-8\"&gt;&lt;/script&gt; 作用：引入外部声明好的js文件特点：实现js代码的重复使用，避免代码的冗余注意：因为js在HTML文档中是一门单独的语言，可以声明在文档中的任意位置 一般情况下声明在head标签中 js的变量 js的所有变量声明只有var关键字var 变量名=初始值；注意： js的变量名是严格区分大小写的 js的字符串可以使用双引号也可以使用单引号 js中可以声明同名变量，不会报错，后面的声明会将前面的声明覆盖 js中的数据类型数据类型判断关键字：typeof数据类型： number:数字类型 string：字符串类型 boolean：布尔型 object：对象 null：空对象赋值，主要是和undefined进行区分 undefined：变量声明不赋值，默认值是undefined 注意：var d; alert(d); alert(typeof c); 在js中尽量给声明的变量赋初值 js变量强制转换 使用Number函数，将其他数据类型转换成数值类型，转换失败返回NaN（Not a Number） 数据类型 原始值 转换后 string 数字字符 对应的nunber数字 string 非数字字符 NaN（number类型） boolean true 1 boolean false 0 object 有具体的值 一串数字 object null 0 Boolean()函数，将其他数据类型转换成布尔类型，有值返回true，无值返回false 数据类型 原始值 转换后的值 number 正数或者负数 true number 0 false string 非空字符串 true string 空字符串”” false object 具体的对象 true object null false 声明不赋值的变量 false js运算符 算术运算符:加+ 减- 乘* 除/ 求余%number类型和number类型的number类型和boolean类型(true–1 false–0)number类型和string类型string和string类型的数字string类型和boolean类型 在算术运算中如果两边的数据类型并不是number，会使用Number()函数强制转换 注意：在字符串中”+”符号代表的是字符串的连接符,不会参与运算 逻辑运算符: 非 ！ 与 &amp; &amp;&amp; 或 | || 关系运算符：！= &gt;= &lt;= 自增运算符：++ – -= // 运算效率高（位运算） 特殊关系运算符： 1234567等值运算符==：先判断类型，类型一致则直接比较，类型不一致，则先使用Number（）进行强转后在进行比较eg:null==undefined //返回值为true等同运算符：=== 先判断类型，类型一致则再比较内容，内容一致则返回true，内容不一致则返回falseeg:null===undefined //返回值为false js的逻辑结构与循环结构js的逻辑结构： if结构： 单分支结构 if() 双分支结构 if() else() 多分支结构 if() else if() …else() switch选择结构：switch（）{ case：break；} 注意：判断的变量可以是number类型也可以是string类型，但不要混用 js的循环结构： for()循环 while()循环 do{}while()循环 js的数组 数组的声明 123var array=new Array(); //声明空数组对象var array=new Array(length); //声明数组长度指定的数组var array=[元素...]; //直接声明数组（常用） 注意：js中的数组声明不用指定长度，js数组的长度是不固定的，由元素的个数而定 数组的赋值和取值数组可以存储任意类型的数据 组名[角标]=值； //角标可以是任意的正整数和零 组的取出 组名[角标]； //返回当前角标所对应存储的值如果角标不存在，返回undefined 数组的length属性 作用： 数组名.length //返回当前数组长度 数组名.length=值 //动态设置数组长度 注意： length&gt;原有长度，则使用空进行填充 length&lt;原有长度，则从后面进行截取，最后的数据会被 数组的遍历 普通for循环 for-in 1234for(var i in array)&#123; alert(i); //获取的是角标 alert(array[i]); //获取的是元素&#125; js数组的常用操作 数组的合并： var a=array.concat(数组); 数组指定间隔符转换字符串： var b=array.join(&quot;-&quot;); 数组移除最后一个元素并返回元素： var c=array.pop(); 数组的追加,返回数组的新长度： var d=array.push(元素); //最佳的元素可以是一个数组，但是作为一个角标值存在 数组移除第一个元素并返回该元素： var e=array.shift(); 数组在开始位置插入指定元素并返回数组的新长度： var f=array.unshift(&quot;&quot;); 数组删除指定位置元素并返回移除的元素 var g=array.splice(start,deletecount,&quot;&quot;); js的函数：作用：功能代码块的封顶，减少代码的冗余 函数的声明 方式一： 1234function 函数名(参数)&#123; 函数体&#125;调用函数；函数名（实际参数）； 方式二：var 函数名=new Function（&quot;形参1&quot;，“形参2&quot;...&quot;函数执行体&quot;）；注意：此声明表明在js函数中是作为对象存在的 方式三： 123var 变量名=function（形参...）&#123; 函数体；&#125; 函数的参数js的函数调用时，形参可以不赋值，不会报错js的函数调用时，形参赋值可以不全部赋值，不会报错，但实参会依次赋值 函数的返回值在js中如果有返回值则返回返回值，无返回值则返回undefined注意：js的代码声明区域和执行区域是一起的，都是在js代码的代码域中 函数的执行符在js中函数的执行符值()没有小括号则函数名其实就是一个变量加上小括号则函数会被执行 函数作为实参传递在js中函数是可以作为实参进行传递的 12345678eg:function testobj(a)&#123; alert(a());&#125;var testParam=function()&#123; alert(\"函数参数\");&#125;testobj(testParam()); js的类和对象js的类： 类的声明 12345function 类名（形参...）&#123; this.属性名=形参； ... this.属性名=function()&#123;&#125;&#125; 类的使用 对象名=new 类名（实参...）; 注意：js中类的内容是对象的公共部分，每个对象还可以自定义地进行扩充 类的”继承” prototype关键字通过prototype关键字实现了不同对象之间的数据共享作用:实现某个类的所有子对象的方法区对象的共享，节省内存 prototype写在类里面，调用时要加上prototype prototype写在类外面，调用时不加prototype 1234567891011121314//声明function Person(name,age)&#123; this.name=name; this.age=age; this.fav=\"Sing\"; this.prototype=new User(); &#125;function User()&#123;&#125;//调用//或者Person.prototype=new User();var p1=new Person(\"盲侠\",20);User.prototype.testU=function()&#123;alert(\"abcd\");&#125;//此处p1.prototype.testU();p1.prototype.testU(); 自定义对象对象的作用：用来存储整体数据原因：不能预知一个对象的所有属性，创建一个临时对象来定义属性存储数据，来保证数据的完整性应用：Ajax使用： 创建自定义对象 1234567var 对象名=new Object();对象名.属性名=属性值;...var 对象名=&#123;&#125;；对象名.属性名=属性值;... 一般用来存储数值，不会再自定义对象中存储函数对象 js中的对象属性和内容是可以自定义的扩充到的，不是依赖于类的声明的，类只是对象公开部分的一种声明，是为了节省代码的冗余 常用对象和方法string对象字符串大小写的转换 str.toUpperCase(); 将字符串转换为大写 str.toLowerCase(); 将字符串转换为小写 字符串的切割 var str=string.split(“字符”)；按照指定的字符切割字符串，返回数组 字符串的截取 str.substr(start,end); 从指定的开始位置截取指定长度的子字符串 str.substring(start,end); 从指定的开始位置和指定的结束位置截取子字符串，含头不含尾 查找子字符串第一次出现的角标 indexOf(“字符”); 返回指定子字符串第一次出现的角标，没有则返回-1 Date对象获取当前年份 d.getYear(); 返回1990年开始距今的年份数 d.getFullYear(); 返回当前年份 d.getMonth()+1; 返回当前月份的角标值，需要+1 d.getDate(); 返回的是当前的日期数 d.getHours(); 返回当前时间的小时数l d.getMinutes(); 返回当前时间的分钟数 d.getSeconds(); 返回当前时间的秒数 Math对象 创建随机数字：Math.random(); 返回0-1之间的随机数，不包括0和1 向下取整：Math.floor(); 向上取整：Math.ceil(); 四舍五入：Math.round(); 数值比较 Math.min(数据...); 获取最小值 Math.max(数据...); 获取最大值 Global对象该对象从不直接使用并且不能new，直接写方法名调用即可 使用eval将字符转换为可执行的js代码 eval(); 使用isNaN判断是否值为NaN isNaN(); 获取字符中的浮点数 parseFloat(“字符串”); js的事件机制事件机制 解释；当行为动作满足了一定的条件后，会触发某类事务的执行作用：主要是结合js的函数来使用 内容： 单双击事件 单击：onclick 双击：ondblclick 鼠标事件悬停：onmouseover移动：onmousemove移出：onmouseout 键盘事件 松开：onkeyup 按下：onkeydown 焦点事件 获取：onfocus 失去：onblur 网页加载事件 加载：onload 一般作为网页资源加载，页面加载成功 注意： js中添加事件的第一种方式：在HTML上直接使用事件属性进行添加，属性值为所监听执行的函数 js中的事件只有在当前HTML元素上有效一个HTML元素可以添加多个不同的事件一个事件可以监听触发多个函数执行，不同函数要使用；间隔 用途 给合适的html标签添加合适的事件 onchange—–select下拉框 onload——-body标签 单双击——–用户进行点击动作的HTML元素 鼠标事件——用户进行鼠标移动操作的 键盘事件——用户进行键盘操作的HTML元素 给HTML元素添加多个事件，注意事件之间的冲突 eg：单双击 当事件的触发事件包含相同部分的时候，会产生事件之间的冲突 事件的阻断 当事件监听的函数的的返回值返回给事件时： false：则会阻断当前事件所在的HTML标签的功能 true：则继续执行当前事件所在的HTML标签的功能 超链接调用js函数 1&lt;a href=\"javascript:函数名()\"&gt;描述&lt;/a&gt; window对象BOM浏览器对象模型：是规范浏览器对js语言的支持（js掉用浏览器本身的功能）BOM的具体实现是window对象 window对象 window对象不用new，直接进行使用，类似Math的使用方式，widow关键字可以省略 框体方法 - 警告框 alert(); //提示一个警告信息，无返回值 - 确认框 confirm(); //提示用户选择一项操作（确定/取消） 返回true或false - 提示框 prompt(); //提示用户某个信息的录入 点击确定返回当前用户录入的数据，默认返回空字符串；点击取消，返回null 定时和间隔执行方法 定时setTimeout(函数对象，时间(毫秒)); //指定的时间后执行指定的函数 间隔执行 setInterval(函数对象，时间(毫秒)); //每间隔指定时间执行指定的函数 停止 clearTimeout(定时器id); //停止当前的定时器 ,返回当前定时器id clearInterval(间隔器id); //停止当前指定的间隔器，返回当前间隔器id 子窗口方法 12345window.open(); //打开新页面参数(子页面资源（相对路径），打开方式，配置) window.close(); //关闭子页面window.open('page.html','newwindow','height=100px,width=100px,top=0px,left=0px,toolbar=no,menubar=no,scrollbar=no,resizeble=no,location=no,status=no'); 注意：close（）只能关闭open（）打开的子页面！二者配套使用 子页面调用父页面的函数window.opener.父类函数名(); window对象常用属性 地址栏属性window.location.href=”新的资源路径（相对路径/url）”; //跳转资源window.location.reload(); //重新加载页面资源 历史记录属性window.history.forward(); //页面资源前进，历史记录的前进window.history.back(); //页面资源后退，历史记录的后退window.history.go(index); //跳转到指定的历史记录资源注意：window.history.go(0)；相当于刷新页面 屏幕属性var width=window.screen.width; //获取屏幕的宽度分辨率var height=window.screen.height; //获取屏幕的高度分辨率 浏览器配置属性window.navigator.userAgent(); //获取用户的浏览器版本信息… 主体面板属性(document) document对象document对象的概念浏览器对外提供的支持js的用来操作HTML文档的一个对象，此对象存的HTML文档的所有信息（隶属于window对象） 使用document获取HTML元素对象直接获取方式 属性 方法 id (window.)document.getElementById(); name属性值 (window.)document.getElementsByName(); //返回数组 标签名 (window.)doucument.getElementsByTagName(); //返回数组 class属性值 (window.)document.getElementsByClassName(); //返回数组 间接获取方式 父子关系获取父级元素对象：var showdiv=document.getElementById();获取所有的子元素对象数组：var childs=showdiv.childNodes; 子父关系获取子元素对象var inp=document.getElementByid();var div=inp.parentNode; 兄弟关系var inp=document.getElementById();var pre=inp.previousSibling;var next=inp.nextSibling; 操作HTML的元素属性 获取元素对象直接or间接 操作元素属性 元素对象名.属性名 //获取固有属性 元素对象名.getAttribute(“属性名”); //获取自定义属性修改 元素对象名.属性值=属性值 //修改固有属性 元素对象名.setAttribute(“属性名”,”属性值”); //修改自定义属性 注意：尽量不要修改元素对象的id，name属性使用自定义方式获取固有属性内容，value的额值获取的是默认值，不能获取到实时的用户数据 操作HTML元素对象的内容和样式 元素内容 获取元素对象 获取元素内容对象名.innerHTML; //返回当前元素对象的所有内容，包括HTML标签对象名.innerText; //返回当前元素对象的文本内容，不包括HTML标签 修改元素内容对象名.innerHTML=””; //会将原有内容覆盖，且HTML标签会被执行对象名.innerHTML=对象名.innerHTML+””; //不会将原有内容覆盖，且HTML标签会被执行对象名.innerText=””; //会将原有内容覆盖，但HTML标签不会被执行，会作为普通文本显示 元素样式(实际相当于操作元素属性) style属性 添加/修改元素样式 元素对象名.style.样式名=&quot;样式值&quot;; //样式名为css样式名去-且驼峰命名原则 删除 元素对象名.style.样式名=””; 注意：以上操作，操作的是HTML的style属性声明中的样式，而不是其他css代码域中的样式 class属性元素对象名.className=”新的值” 添加/修改/删除类选择器样式 操作HTML的文档结构增加节点删除节点 使用innerHTML(适用下拉框内容填充)div.innerHTML=div.innerHTML+’内容’; //增加节点div.innerHTML=””; //删除所有子节点父节点.removeChild(子节点对象) //删除指定子节点 使用documentvar obj=document.createElement(“标签名”);元素对象名.appendChild(obj); //添加元素对象名.removeChild(obj); //删除 document操作form元素 获取form表单对象 (form 标签 id=”frm” name=”frm”) 使用id： var fm=document.getElementById(“fm”); 使用name属性: var frm=document.frm; 获取form表单的所有子元素标签 表单对象.elements form表单的常用方法 表单对象.submit(); //提交 表单对象.reset(); //重置 form的属性操作 表单对象名.action=”新的值” //动态的改变数据的提交路径 表单对象名.method=”新的值” //动态的改变数据的提交方式 表单元素的通用属性 只读模式 readonly=”readonly” //不可以更改，但是数据可以提交 关闭模式 disabled=”disabled” //不可进行任何操作，数据不会提交 操作表单元素 多选框、单选框 被选中状态在js中checked属性值为true，未选中为false 下拉框 被选择的option对象在js中selected属性值为true，未选中为false（select对象.options返回一个option数组） document对象实现form表单校验(验证码、用户名) 创建验证码 创建随机四位数字 var code=Math.floor(Math.random()*9000+1000); 将数字放在span中 var span=document.getElementById(&quot;span&quot;); span.innerHTML=code; 验证(用户名 id=”uname”) 封装校验…相同的保留，不同的传参 获取用户名信息 var uname=document.getElementById(&quot;uname&quot;).value; 创建检验规则—–正则表达式 123var reg=/^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/; //用户名：2-4个汉字/^[a-z]\\w&#123;5,7&#125;$/; //密码：字母打头后5-7位数字/^1[3,4,5,6,7,8]\\d&#123;9&#125;$/; //手机号检验：1开头，第二位为[3,4,5,6,7,8]，共11位 获取span对象 var span=document.getElementById(&quot;unameSpan&quot;); 开始校验 12345678910111213if(uname==\"\"||uname==null)&#123; //输出校验结果 span.innerHTML=\"用户名不能为空\"; span.style.color=\"red\";&#125;else if(reg.test(uname))&#123; //输出校验结果 span.innerHTML=\"用户名可用\"; span.style.color=\"green\";&#125;else&#123; //输出校验结果 span.innerHTML=\"用户名不符合规范\"; span.style.color=\"red\";&#125; 提交判断：form onchanged属性 document操作表格删除行12345function delRow(btn)&#123; var table=document.getElementById(\"\"); //获取表格table对象 var tr=btn.parentNode.parentNode; //获取要删除的行号 table.deleteRow(tr.rowIndex); //tr.rowIndex返回行对象的角标&#125; 修改行功能123456789101112function updateRow(btn)&#123; var tr=btn.parentNode.parentNode; //获取表格table对象 var cell=tr.cell[]; //获取行对象 if(isNaN(cell.innerHTML))&#123; //判断cell.innerHTML的值是否为数字(修复修改功能的bug) //修改行内容 cell.innerHTML=\"&lt;input type='text'\"+cell.innerHTML+\"onblur='updateInp(this)'\" &#125;&#125;function uodateInp(inp)&#123; var cell=inp.parentNode; cell.innerHTML=inp.value;&#125; 选择删除指定行功能123456789var table=document.getElementById(\"\"); //获取表格对象var checks=document.getElementsByName(\"\");//获取要删除的行号//开始删除for(var i=0;i&lt;checks.length;i++)&#123; if(check[i].checked)&#123; table.deleteRow(i); i--; //数组的length值动态变化 &#125;&#125; 添加行1234var table=document.getElementById(\"\"); //获取表格对象var tr=table.insertRow(1); //添加行var cell=tr.insertCell(0); //添加单元格cell.innerHTML=\"\"; //单元格内容 复制行12345678var table=document.getElementById(\"\"); //获取表格对象var checks=document.getElementsByName(\"\"); //获取选择行对象for(var i=1;i&lt;checks.length;i++)&#123; //i=1;保留表头 if(checks[i].checked)&#123; var tr=table.insertRow(table.rows.length); tr.innerHTML=table.rows[i].innerHTML; //复制行 &#125;&#125; 全选：用一个radio操作多个单选框(name相同)12345678910111213function chekedAll()&#123; var check=document.getElementById(\"\"); var chks=document.getElementsByName(\"\"); if(check.checked)&#123; for(var i=0;i&lt;chks.length;i++)&#123; chks[i].checked=true; &#125; &#125;else&#123; for(var i=0;i&lt;chks.length;i++)&#123; chks[i].checked=false; &#125; &#125;&#125; ​","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"web","slug":"notes/web","permalink":"https://lao-biao.github.io/categories/notes/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lao-biao.github.io/tags/javascript/"}]},{"title":"python3使用webdriver模拟浏览器实现网页访问","slug":"python3使用webdriver模拟浏览器实现网页访问","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:23:14.635Z","comments":true,"path":"articles/86288129.html","link":"","permalink":"https://lao-biao.github.io/articles/86288129.html","excerpt":"webdriver配置 进入网址http://npm.taobao.org/mirrors/chromedriver/下载与安装的google chrome版本相对应的chrome driver 将下载的chromedriver.exe添加到python项目文件夹中 模式通过对webdriver进行设置可以实现静默运行和通过窗口运行","text":"webdriver配置 进入网址http://npm.taobao.org/mirrors/chromedriver/下载与安装的google chrome版本相对应的chrome driver 将下载的chromedriver.exe添加到python项目文件夹中 模式通过对webdriver进行设置可以实现静默运行和通过窗口运行 窗口运行运行python文件后会打开一个chrome窗口对网页进行访问 具体代码123456789from selenium import webdriver# webdriver配置，静默运行driver = webdriver.Chrome() driver.viewportSize = &#123;'width': 1920, 'height': 900&#125; # 分辨率driver.maximize_window() # 可使窗口最大化url=''driver.get(url) # 对网页进行访问print(driver.page_source) # 打印网页源码 静默运行运行python文件后不会打开chrome窗口，以静默的方式对网页进行访问 具体代码12345678910from selenium import webdriver# webdriver配置，静默运行option = webdriver.ChromeOptions()option.add_argument('headless') # 设置optiondriver = webdriver.Chrome(options=option) # 调用带参数的谷歌浏览器driver.viewportSize = &#123;'width': 1920, 'height': 900&#125; # 分辨率url=''driver.get(url)print(driver.page_source) # 打印网页源码 相关方法可以通过网站webdriver进行相关文档的查询 元素查找12345678element=driver.find_element_by_xpath() # 通过绝对路径对网页的某一元素进行查找element=driver.find_element_by_class_name() # 类名查找element=driver.find_element_by_id() # id查找element=driver.find_element_by_name() # name查找 截屏12element.screenshot(\"文件名.png\") # 将元素内容截屏保存成png格式，静默运行方式下可以执行，在窗口模式下运行时 输入内容12element.send_keys('') # 对元素进行填写内容，可用于输入框 网页刷新12driver.refresh() # 浏览器刷新网页 网页信息12345678driver.title() # 获取网页的标题driver.page_source # 获取网页源码driver.get_cookies() # 获取浏览器cookiedriver.current_url # 获取当前url","categories":[{"name":"python","slug":"python","permalink":"https://lao-biao.github.io/categories/python/"}],"tags":[{"name":"webdriver","slug":"webdriver","permalink":"https://lao-biao.github.io/tags/webdriver/"}]},{"title":"短暂解决ConnectionRefusedError:WinError 10061问题","slug":"短暂解决python3使用requests提示ConnectionRefusedError的方法","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:24:51.401Z","comments":true,"path":"articles/9d9c9508.html","link":"","permalink":"https://lao-biao.github.io/articles/9d9c9508.html","excerpt":"","text":"使用requests提示ConnectionRefusedError错误信息ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接 解决方法 首先检查是否使用代理 打开win10的网络和Internet设置 勾选自动检测设置，关闭使用设置脚本，关闭手动设置代理的使用代理服务器 打开注册表 删除路径：计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings下的 ProxyEnable ProxyOverride ProxyServer 重新运行python程序这种方式只能短暂解决问题，这三个文件会自动生成，需要重复删除","categories":[{"name":"python","slug":"python","permalink":"https://lao-biao.github.io/categories/python/"}],"tags":[{"name":"requests","slug":"requests","permalink":"https://lao-biao.github.io/tags/requests/"}]},{"title":"mysql基础","slug":"mysql基础","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:22:54.365Z","comments":true,"path":"articles/8e40d0ad.html","link":"","permalink":"https://lao-biao.github.io/articles/8e40d0ad.html","excerpt":"MySQL语句数据库的常用操作登陆服务器mysql -h服务器地址 -u用户名 -p密码（不安全） 1mysql -hlocalhost(本地) -u... -p... 退出服务器1mysql&gt; exit 相对安全的登陆形式mysql -h服务器地址 -u用户名 -p(回车后输入密码) 12mysql -hlocalhost -uroot -pEnter password:...","text":"MySQL语句数据库的常用操作登陆服务器mysql -h服务器地址 -u用户名 -p密码（不安全） 1mysql -hlocalhost(本地) -u... -p... 退出服务器1mysql&gt; exit 相对安全的登陆形式mysql -h服务器地址 -u用户名 -p(回车后输入密码) 12mysql -hlocalhost -uroot -pEnter password:... 查询所有数据库1234567891011mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.01 sec) 查看当前数据库编码mysql&gt; show create database 数据库名称; 12345678mysql&gt; show create database mysql;+----------+----------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------+| mysql | CREATE DATABASE `mysql` /*!40100 DEFAULT CHARACTER SET utf8 */ |+----------+----------------------------------------------------------------+1 row in set (0.00 sec) 创建数据库create datebase 数据库的名称 [编码]编码可有可无，如果没有就是此服务器的默认编码(安装时选择的编码形式) 1234567891011121314151617mysql&gt; create database demo;(默认编码)mysql&gt; create database demo character set gbk;(gbk格式编码)Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || demo || mysql || performance_schema || test |+--------------------+5 rows in set (0.00 sec) 修改数据库名称rename database 旧名称 to 新名称;(5.5版本无法使用 ) 强制修改数据库名称： 退出MySQL服务器 进入数据库储存位置,找到文件夹并修改数据库名称(文件夹) 重新登陆MySQL服务器 修改数据库的编码alter database 数据库名称 character set 编码格式; 123mysql&gt; alter database demo character set gbk;Query OK, 1 row affected (0.00 sec) 删除数据库drop database 数据库名称; 123mysql&gt; drop database demo;Query OK, 0 rows affected (0.01 sec) 查看当前使用的数据库select database(); 12345678mysql&gt; select database();+------------+| database() |+------------+| demo |+------------+1 row in set (0.00 sec) 切换数据库use 数据库名称; 123mysql&gt; use demo;Database changed 数据表的常用操作创建数据表create table 数据表名称 (字段1 数据类型，字段2 数据类型，字段3 数据类型,...); 字段类型 int ：整数 -2147483648~2147483647，4个字节 varchar(长度) ： 字符串，可变字节 double ： 小数，8个字节 datetime：时间，7个字节 bit(M)：位数据类型，默认为1位，0或1 123456789mysql&gt; create table demolist(-&gt; id int,-&gt; name varchar(10),-&gt; age int,-&gt; salary double,-&gt; sex varchar(5)-&gt; );Query OK, 0 rows affected (0.01 sec) 查看所有数据表12345678mysql&gt; show tables;+----------------+| Tables_in_demo |+----------------+| demolist |+----------------+1 row in set (0.01 sec) 查看数据表编码mysql&gt; show create database 数据表名称; 1234567891011121314mysql&gt; show create table demolist;+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| demolist | CREATE TABLE `demolist` ( `id` int(11) DEFAULT NULL, `name` varchar(10) DEFAULT NULL, `age` int(11) DEFAULT NULL, `salary` double DEFAULT NULL, `sex` varchar(5) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 修改数据表的编码alter database 数据表名称 character set 编码格式; 1234mysql&gt; alter table demolist character set gbk;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 查看数据表结构desc 数据表名称; 1234567891011121314mysql&gt; use demo;Database changedmysql&gt; desc demolist;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(10) | YES | | NULL | || age | int(11) | YES | | NULL | || salary | double | YES | | NULL | || sex | varchar(5) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.04 sec) 修改数据表结构增加列（字段）alter table 数据表名称 add 字段名称 字段数据类型; 123456789101112131415161718mysql&gt; alter table demolist add adress varchar(100);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demolist;+--------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(10) | YES | | NULL | || age | int(11) | YES | | NULL | || salary | double | YES | | NULL | || sex | varchar(5) | YES | | NULL | || adress | varchar(100) | YES | | NULL | |+--------+--------------+------+-----+---------+-------+6 rows in set (0.02 sec) 修改长度/类型/约束alter table 数据表名称 modify 字段名称 字段新数据类型(新长度 ); 123456789101112131415161718mysql&gt; alter table demolist modify name varchar(20);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demolist;+--------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | || age | int(11) | YES | | NULL | || salary | double | YES | | NULL | || sex | varchar(5) | YES | | NULL | || adress | varchar(100) | YES | | NULL | |+--------+--------------+------+-----+---------+-------+6 rows in set (0.02 sec) 修改列名（字段名称）alter table 数据表名称 change 旧的字段名称 新的字段名称 字段数据类型(长度); 123456789101112131415161718mysql&gt; alter table demolist change name username varchar(30);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demolist;+----------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || username | varchar(30) | YES | | NULL | || age | int(11) | YES | | NULL | || salary | double | YES | | NULL | || sex | varchar(5) | YES | | NULL | || adress | varchar(100) | YES | | NULL | |+----------+--------------+------+-----+---------+-------+6 rows in set (0.02 sec) 删除列（删除字段）alter table 数据表名称 drop 字段名称; 1234567891011121314151617mysql&gt; alter table demolist drop adress;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demolist;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || username | varchar(30) | YES | | NULL | || age | int(11) | YES | | NULL | || salary | double | YES | | NULL | || sex | varchar(5) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+5 rows in set (0.02 sec) 修改数据表名称rename table 旧的数据表名称 to 新的数据表名称; 123456789101112mysql&gt; rename table demolist to demotable;Query OK, 0 rows affected (0.01 sec)mysql&gt; show tables;+----------------+| Tables_in_demo |+----------------+| demotable |+----------------+1 row in set (0.01 sec) 单表约束主键约束 primary key为了保证一个列，数据不重复；一般来说，一个表里只有一个主键 修改：alter table 数据表名称 modify 字段名称 primary key; 1234567891011121314151617mysql&gt; alter table demotable modify id int primary key;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demotable;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || username | varchar(30) | YES | | NULL | || age | int(11) | YES | | NULL | || salary | double | YES | | NULL | || sex | varchar(5) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+5 rows in set (0.03 sec) 创建：alter table 数据表名称 add 字段名称 字段数据类型 primary key auto_increment; 12mysql&gt; alter table demotable add id int primary key auto_increment;Query OK, 0 rows affected (0.03 sec) 唯一约束为了保证不重复，与主键不同的是可以控制多个字段不重复 1234567891011121314151617181920mysql&gt; create table demoinfo( -&gt; id int primary key auto_increment, -&gt; name varchar(50), -&gt; dna varchar(32) unique, -&gt; age int -&gt; ); Query OK, 0 rows affected (0.01 sec)mysql&gt; desc demoinfo;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(50) | YES | | NULL | || dna | varchar(32) | YES | UNI | NULL | || age | int(11) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+4 rows in set (0.02 sec) 非空约束被约束的字段必须有数据 12345678910111213141516mysql&gt; alter table demoinfo modify name varchar(50) not null;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demoinfo;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(50) | NO | | NULL | || dna | varchar(32) | YES | UNI | NULL | || age | int(11) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+4 rows in set (0.02 sec) 删除主键约束/唯一约束/非空约束删除主键alter table 数据表名称 drop primary; 1234mysql&gt; alter table demoinfo drop primary key;ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key//出现此错误，是因为这个是 自动增长的 主键 1234567891011121314151617181920212223//先修改掉自动增长mysql&gt; alter table demoinfo modify id int;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0//删除主键mysql&gt; alter table demoinfo drop primary key;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demoinfo;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | | 0 | || name | varchar(50) | NO | | NULL | || dna | varchar(32) | YES | UNI | NULL | || age | int(11) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.03 sec) 删除唯一约束alter table 数据表名称 drop index 字段名称; 12345678910111213141516mysql&gt; alter table demoinfo drop index dna;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demoinfo;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | | 0 | || name | varchar(50) | NO | | NULL | || dna | varchar(32) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.02 sec) 删除非空约束直接修改即可 12345678910111213141516mysql&gt; alter table demoinfo modify name varchar(50);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc demoinfo;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | | 0 | || name | varchar(50) | YES | | NULL | || dna | varchar(32) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.03 sec) 删除数据表drop table 数据表名称; 123mysql&gt; drop table demoinfo;Query OK, 0 rows affected (0.01 sec) 数据的常用操作插入数据插入完整数据insert into 数据表名(字段名称1,字段名称2...) value(值1，值2...);insert into 数据表名 value(值1，值2...); (简洁写法) 123mysql&gt; insert into demotable(username,age,salary,sex,id) value(\"zhangsan\",20,0,\"man\",123);Query OK, 1 row affected (0.01 sec) 123mysql&gt; insert into demotable value(\"lisi\",20,0,\"man\",1234);Query OK, 1 row affected (0.01 sec) 查看数据 插入部分数据字段与值对应着写 123mysql&gt; insert into demotable(username,age,sex) value(\"wangwu\",20,\"man\");Query OK, 1 row affected (0.01 sec) 查看数据 插入中文直接输入中文，报错 123mysql&gt; insert into demotable(username,age) value(\"老王\",20);ERROR 1366 (HY000): Incorrect string value: '\\xC0\\xCF\\xCD\\xF5' for column 'username' at row 1 原因：控制台是gbk编码，mysql服务器是utf8编码找到mysql的安装文件中的my.ini文件，修改 123456//修改前[mysql] default-character-set=utf8//修改后[mysql] default-character-set=GBK 保存后，重启服务（我的电脑右键管理–&gt;服务–&gt;重新启动MySQL），重新进入mysql 123mysql&gt; insert into demotable(username,age) value(\"老王\",20);Query OK, 1 row affected (0.01 sec) 查看数据 查询表中的数据select * from 数据表名; 123456789101112mysql&gt; select * from demotable;//id 为auto_increment 自动增长+----------+------+--------+------+------+| username | age | salary | sex | id |+----------+------+--------+------+------+| zhangsan | 20 | 0 | man | 123 || lisi | 20 | 0 | man | 1234 || wangwu | 20 | NULL | man | 1235 || 老王 | 20 | NULL | NULL | 1236 |+----------+------+--------+------+------+4 rows in set (0.00 sec) 修改数据对数据进行更新update 数据表名称 set 字段名称 = 值 条件 (where); 12345678910111213141516mysql&gt; update demotable set salary = 1 where username = \"wangwu\";Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from demotable;+----------+------+--------+------+------+| username | age | salary | sex | id |+----------+------+--------+------+------+| zhangsan | 20 | 0 | man | 123 || lisi | 20 | 0 | man | 1234 || wangwu | 20 | 1 | man | 1235 || 老王 | 20 | NULL | NULL | 1236 |+----------+------+--------+------+------+4 rows in set (0.00 sec) 删除数据表中的数据delete from 数据表名称 条件(where); 1234567891011121314mysql&gt; delete from demotable where username = \"wangwu\";Query OK, 1 row affected (0.01 sec)mysql&gt; select * from demotable;+----------+------+--------+------+------+| username | age | salary | sex | id |+----------+------+--------+------+------+| zhangsan | 20 | 0 | man | 123 || lisi | 20 | 0 | man | 1234 || 老王 | 20 | NULL | NULL | 1236 |+----------+------+--------+------+------+3 rows in set (0.00 sec) 数据表中的数据的查询详细条件 = &lt;&gt; &gt;= &lt;= &gt; &lt; is null is not null and between … and … 在…与…之间，前面的要小于后面的 or 列名 in(值1,值2,…) 列名 = 值1 or 列名 = 值2 or … not like select * from 数据表名称 [where 条件];123456789mysql&gt; select * from demotable where salary = 0;+----------+------+--------+------+------+| username | age | salary | sex | id |+----------+------+--------+------+------+| zhangsan | 20 | 0 | man | 123 || lisi | 20 | 0 | man | 1234 |+----------+------+--------+------+------+2 rows in set (0.01 sec) select 列名,列名,… from 数据表名称 [where 条件];12345678910mysql&gt; select username,age from demotable;+----------+------+| username | age |+----------+------+| zhangsan | 20 || lisi | 20 || 老王 | 20 |+----------+------+3 rows in set (0.00 sec) select 列名,列名,… from 数据表名称 by 列名 asc(升序) / desc(降序);12345678910mysql&gt; select * from demotable order by id desc;+----------+------+--------+------+------+| username | age | salary | sex | id |+----------+------+--------+------+------+| 老王 | 20 | NULL | NULL | 1236 || lisi | 20 | 0 | man | 1234 || zhangsan | 20 | 0 | man | 123 |+----------+------+--------+------+------+3 rows in set (0.00 sec) select 列名 as 别名,列名 as 别名,… from 数据表名称 where 条件;12345678910mysql&gt; select username as \"名字\",age as \"年龄\" from demotable;+----------+------+| 名字 | 年龄 |+----------+------+| zhangsan | 20 || lisi | 20 || 老王 | 20 |+----------+------+3 rows in set (0.00 sec) 模糊查询select * from 数据表名称 where 字段名称 like 关键字% %表示通配符 _表示占位符 1234567mysql&gt; select * from demotable where username like \"zhang%\";+----------+------+--------+------+-----+| username | age | salary | sex | id |+----------+------+--------+------+-----+| zhangsan | 20 | 0 | man | 123 |+----------+------+--------+------+-----+1 row in set (0.02 sec) 函数count： 统计个数1234567mysql&gt; select count(age),age from demotable where age = 20;+------------+------+| count(age) | age |+------------+------+| 3 | 20 |+------------+------+1 row in set (0.01 sec) sum函数： 求和1234567mysql&gt; select sum(salary) from demotable;+-------------+| sum(salary) |+-------------+| 0 |+-------------+1 row in set (0.00 sec) avg函数： 求平均数1234567mysql&gt; select avg(id) from demotable;+----------+| avg(id) |+----------+| 864.3333 |+----------+1 row in set (0.00 sec) max与min：求最大值与最小值1234567mysql&gt; select max(id),min(id) from demotable;+---------+---------+| max(id) | min(id) |+---------+---------+| 1236 | 123 |+---------+---------+1 row in set (0.00 sec) 分组 group by以某一个字段为组，相同的进行折叠 1234567mysql&gt; select * from demotable group by age;+----------+------+--------+------+-----+| username | age | salary | sex | id |+----------+------+--------+------+-----+| zhangsan | 20 | 0 | man | 123 |+----------+------+--------+------+-----+1 row in set (0.00 sec) 统计各年龄段人数 1234567mysql&gt; select age,count(age) from demotable group by age;+------+------------+| age | count(age) |+------+------------+| 20 | 3 |+------+------------+1 row in set (0.00 sec) 数据库备份/恢复备份mysqldump -h服务器地址 -u用户名 -p(密码/回车写) 数据库名称 &gt; 数据备份的路径 恢复mysql -u用户名 -p(密码/回车写) 新数据库名称","categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lao-biao.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://lao-biao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"python语法","slug":"python语法","date":"2020-04-03T04:00:00.000Z","updated":"2020-07-06T03:23:37.931Z","comments":true,"path":"articles/81b2f4bf.html","link":"","permalink":"https://lao-biao.github.io/articles/81b2f4bf.html","excerpt":"python语法python官方网站 python 特点 数值没有长度的限制 可以直接执行运算 使用缩进的空白代替大括号{}，缩进的空白数量是可变的，但所有代码块语句必须包含相同的缩进空白数量 注释单行注释 #多行注释 “”” “””或 ‘’’ ‘’’ 字符串‘’’ ‘’’ 或 ‘ ‘ 或 “ “ 作用 函数名 查找 find() 分割 split() 大小写转换 upper()/lower() 首字母大写 title() 截取 变量名[首:尾] (左闭右开) 追加 append() 取反 reverse() 替换 replace(‘要替换的字符’,’替换的字符’)","text":"python语法python官方网站 python 特点 数值没有长度的限制 可以直接执行运算 使用缩进的空白代替大括号{}，缩进的空白数量是可变的，但所有代码块语句必须包含相同的缩进空白数量 注释单行注释 #多行注释 “”” “””或 ‘’’ ‘’’ 字符串‘’’ ‘’’ 或 ‘ ‘ 或 “ “ 作用 函数名 查找 find() 分割 split() 大小写转换 upper()/lower() 首字母大写 title() 截取 变量名[首:尾] (左闭右开) 追加 append() 取反 reverse() 替换 replace(‘要替换的字符’,’替换的字符’) 变量在内存中存储的数据可以有多种类型python五个标准的数据类型： Numbers（数字） int 整型 long int 长整型（在python3中统一为int整形） e 科学计数法 String（字符串） List（列表） Tuple（元组） Dictionary（字典） 变量在定义时，没有指定的数据的类型，定义变量的一般格式为： 变量名=值； 变量1，变量2，··· 变量n=值1，值2，··· 值n （使用此种方式定义变量时，左右的变量个数和值必须保持一致） 数据类型转换 整型 int(‘数值’) 数值必须为int类型才能转换 单精度浮点数 float(‘数值’) 字符串 str(数值) 运算符算术操作符 加 + 减 - 乘 * 除 / 整除 // 求余 % 幂运算 ** m**n：n个m相乘 逻辑运算符与 and或 or非 not 成员运算符in / not in 判断元素是否存在某个序列中 身份运算符is / is not 判断两个标识符是否引用自同一个对象/不同对象 python常用函数输入函数variable=input() 输出函数print(“”,end=’\\r\\n’) 输出函数 默认以\\r\\n结尾 end参数可以调整print的输出结尾print(“字符串” * 数值n) 将字符串输出n次print(数值a 算术运算符 数值b) 执行运算并输出结果print(“%d” % 变量名[int]) 输出变量值 [%s –字符串] type函数type(数据) 能得到数据的数据类型 isinstance函数isinstance(数据,数据类型) 判断数据是否为所给的数据类型 id函数id(数据) 返回所给数据在内存中的地址 eval函数将字符串当成有效的表达式来求值并返回计算结果 12cal = input(\"请输入一个算术式\")print(eval(cal)) 请输入一个算术式3*26 Process finished with exit code 0 eval直接转换input __import__(’os‘).system(’ls‘) 等价代码 12import osos.system(\"终端命令\") 执行成功，返回0执行失败，返回错误信息 语句条件语句标准写法123456if 条件语句1 : 执行语句1 elif 条件语句n : 执行语句n else : 执行语句n+1 三元表达式variable= value1 if 条件语句1 else value2 1a = 3 if 3 &lt; 2 else 2 # 2和3之间取较小值 循环语句1234567891011#while循环语句while 条件语句 : #条件符合 循环体语句 else : #条件不符合 执行语句 #for循环语句#遍历列表for 变量名 in 列表名: 执行语句else : 执行语句 break：中断循环，跳出循环体 continue：循环向下一个执行 pass：不执行任何操作，起到占位的作用 lambda表达式lambda表达式不是函数，是实现简化语句的一种形式 12#eg.sum = lambda 参数 : 执行语句 列表list 列表中可存储不同的数据类型 列表元素位置排序从0开始，可以用负数访问列表，最后一个元素的位置为-1组合 不同的列表可以组合成一个列表，用+链接重复 同一个列表重复n次，用*n实现 列表函数 函数名/关键字 作用 cmp() 比较，（2.x版本适用）在3.x版本中以(a&gt;b)&gt;(a&lt;b)替代 in 元素是否存在于列表 del 删除列表 len() 列表长度 max() 列表中的最大值 min() 列表中的最小值 list() 将元组转换成列表 列表方法 函数名 作用 append() 追加 extend(seq) 扩展 insert(index,object) 插入 index(object) 索引 count(object) 元素出现的次数 pop(index=-1) 默认为最后一个元素 移除指定位置的元素 remove(object) 移除匹配元素的第一个 reverse() / 列表名[::-1] 反向 sort(cmp=none,key=none,reverse=false) cmp指定方法,key指定元素,reverse:true降序,false升序 排序 元组tuple 与列表类似,元组中的元素值不能改变 元组中的元素不允许删除,只能删除整个元组 元组使用小括号 (),列表使用方括号 [] 创建空元组 tup=() 当元组中只包含一个元素时,要以逗号结尾元组函数 函数名 作用 cmp() 比较 len(tuple) 长度 max(tuple) 最大值 min(tuple) 最小值 tuple(seq) 列表转换成元组 字典dict 字典是一种可变容器模型，且可存储任意类型对象 字典是以键值对的形式存在的key:value 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不是唯一的 值是可以取任何数据类型,既可以是python的标准对象，也能是用户自定义对象 键必须不可变，可用数字，字符串，元组，但不能用列表 访问字典中不存在的键，会输出错误KeyError 字典的内容可以增添新的键/值对，修改或删除已有的键/值 删除键值对 del 字典名[‘键名’] 删除字典 del 字典名 字典函数比较两个字典元素 cmp(dict1,dict2) 3.x不可用计算字典元素个数 len(dict)输出字典可打印的字符串表示 str(dict)返回输入的变量类型 type(variable) 字典方法 {key1:value1,key2:value2} 返回一个字典的复制 dict.copy() 创建以指定序列的元素为键,value为初始值的新字典 dict.fromkeys(seq[,value]) 返回指定键的值 dict.get(key,default=None) 当值不在字典时返回default值 字典的键查询 dict.has_key(key) 以列表返回可遍历的元素、数组 dict.items() 查询所有键名 dict.keys() 以列表返回字典中的所有值 dict.values() 设置键的值 dict.setdefault(key,default=None) 当键不存在时，自动创建 更新字典的键值对 dict1.update(dict2) 删除 pop(key[,default]) 返回被删除的键值 随机返回并输出一对键值对 dict.popitem() 元组和字典的拆包拆包语法：简化元组/字典变量的传递 1234567891011121314def func(*args, **kwargs): print(args) print(kwargs)gl_nums = &#123;1, 2, 3, 4&#125;gl_dict = &#123;\"name\": \"ZhangSan\", \"age\": 20&#125;# 元素均被传递为元组func(gl_nums, gl_dict)# 拆包语法func(*gl_nums, **gl_dict)# 一般形式func(1, 2, 3, 4, name=\"ZhangSan\", age=20) 集合set python内置数据结构（集合） {} 无序，可更改 set集合类需要的参数必须是迭代器类型的 一般用来去重，集合的求交集或并集 函数函数的定义： 123def 函数名(参数) : #当参数是列表，字典等引用类型数据，函数内的执行语句会对其值改变 执行语句 return 返回值 函数的参数 必备参数 关键字参数 默认参数 不定长参数 def 函数名(*参数名) *参数名 接收元组 **参数名 接收字典 异常异常的完整处理方式 123456789101112131415try: # 执行可能抛出异常的语句 passexcept 错误类型: # 异常处理语句 passexcept Exception as result: # 打印错误类型 print(result)else: # 没有异常才会执行的代码 passfinally: # 是否发生异常都执行的语句 pass 简单异常捕获123456try: num = int(input(\"请输入整数\"))except: print(\"请输入正确的数字\")finally: print(\"*\" * 50) 错误类型捕获不同错误类型进行捕获 12345678try: num = int(input(\"请输入整数\")) res = 10 / num print(res)except ValueError: # 错误类型1 print(\"请输入正确的数字\")except ZeroDivisionError: # 错误类型2 print(\"0不能作被除数\") 捕获未知错误 123456try: num = int(input(\"请输入整数\")) res = 10 / num print(res)except Exception as result: print(\"未知错误%s\" % result) 异常的传递当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方 如果传递到主程序，仍没有异常处理，程序才会被终止 主动抛出异常raise抛出异常，由其他需要处理的函数捕获异常 1raise Exception(\"异常信息\") 类class class 类名: 属性 函数 其中函数中的self，哪一个对象调用的方法，self就指向哪一个对象 123class ClassName: def __init__(self,属性): # 构造函数，self是类的实例 self.name = \"Tom\" # 初始化内部属性 一种给类的对象添加属性的方法，即在类的外部给对象增加属性，但不推荐使用，因为没有对类进行实质性修改 12345678# 一种给类的对象添加属性的方法，但不推荐使用，因为没有对类进行实质性修改class Test: passa = Test()a.name = \"A\"print(a.name) 私有属性和私有方法 私有属性或私有方法：在属性或方法名前加 __ ,即为类的私有属性或方法 1234567891011121314151617181920class Women: def __init__(self, name): self.name = name # 私有属性 self.__age = 20 def secret(self): print(\"%s的年龄是%d\" % (self.name, self.__age)) def __sing(self): passgirl = Women(\"Mary\")# 私有属性在外界不能直接访问# print(girl.__age)girl.secret()# 私有属性在外界不能直接访问# girl.__sing() 伪私有属性的访问: 类对象名._类名__属性名 12print(girl._Women__age)print(girl._Women__sing()) dir内置函数 常用内置方法及属性 序号 方法名 类型 作用 01 __new__ 方法 创建对象时，会被自动调用 02 __init__ 方法 对象初始化时，会被自动调用 03 __del__ 方法 从内存中销毁对象前，会被调用 04 __str__ 方法 返回对象的描述信息，print()函数输出使用 123# 查看dir内置函数dir(func())# ['__bool__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] del关键字 销毁对象 12345678910111213141516class A: def __init__(self): print(\"初始化\") def __del__(self): print(\"销毁前\") # print()默认输出16进制的地址值 def __str__(self): # 必须返回一个字符串 return \"A\"a = A()print(a)del a 初始化A销毁前 Process finished with exit code 0 继承 单继承：某个类只直接继承一个类 多继承：某个类直接继承多个类 注意：子类不能在自己的方法内部直接访问父类私有属性或私有方法，只能通过父类的公有方法间接调用 多继承父类之间不要有重名的属性或方法名，默认优先调用先继承的父类 MRO：method resolution order 多继承时判断属性、方法的调用路径子类类名.__mro __ 重写：子类对父类的方法进行重写 完全重写 扩展重写：通过super().父类方法调用父类方法 python3.x父类类名.方法名(self) python2.x super是一个特殊类super()就是使用super类创建出来的对象 重载 1234567class B: def __init__(self): pass#A继承Bclass A (B): def __init__(self,attribute): super(B, self).__init__(attribute) 12345678910111213141516171819202122232425262728293031323334class Person: __sex = None def eat(self): print(\"eating\") def sleep(self): print(\"sleepping\")class Man(Person): __sex = \"man\"class Women(Person): __sex = \"female\"class Coder(Person): def code(self): print(\"coding\")class Boss(Man, Coder): def __init__(self): print(\"Manager\") # override重写 def code(self): super().code() Coder.code(self) # python2.x中 print(\"check\") 新式类与旧式(经典)类新式类：以object为基类的类[推荐使用] python3.x没有指定父类，默认使用object作为类的基类 经典类：不以object为基类的类[不推荐使用] python2.x没有指定父类，不会以object作为基类 类属性查找–向上查找123456class Tool(object): count = 0 # 类属性，相当于静态变量 def __init__(self, name): self.name = name self.count += 1 首先在对象内部查找属性 对象名.属性 [不推荐] 注意：对象名.属性 =value 只会给对象添加一个 属性，并不会影响到类属性的值 没有找到就向上查找类属性 类名.属性 [推荐] 类方法和静态方法类方法：针对类对象定义的方法，在类方法内部可以直接访问类属性或者调用其他的类方法 类方法需要用 修饰器：@classmethod标识 类方法的第一个参数是cls 由哪一个类调用的方法，方法内部的cls就是哪一个类的引用 cls可用其他变量名替代 通过类名调用类方法，不需要传递cls参数 123456789101112131415161718class Tool(object): # 类属性，记录工具的数量 count = 0 @classmethod def show_tool_count(cls): print(\"Tool count==&gt;%d\" % cls.count) def __init__(self, name): self.name = name # 类属性的值+1 Tool.count += 1knife = Tool(\"knife\")fork = Tool(\"fork\")Tool.show_tool_count() # Tool count==&gt;2 静态方法 既不需要访问实例属性或者实例方法 也不需要访问类属性或者调用类方法 @staticmethod标识静态方法 通过类名.方法名 调用静态方法 12345678class Tool(object): @staticmethod def work(): print(\"Tool is working\") Tool.work() # Tool is working 实例方法、类方法、静态方法实例方法：方法内部需要访问实例属性，能访问到类属性 类方法：方法内部只需要访问类属性 静态方法：方法内部不需要访问实例属性和类属性 单例模式单例模式 让类创建的对象,在系统中只有为一个实例 每一次执行类名()返回的对象,内存地址是相同的 __new__方法 在内存中为对象分配空间 返回对象的引用 重写__new__方法一定要 return super().__new__(cls),否则Python的计时器得不到分配了空间的对象引用,就不会调用对象的初始化方法 注意:__new__是一个静态方法,在调用时需要主动传递cls参数 12345678910111213141516171819202122232425262728293031323334353637383940class MusicPlayer(object): # 定义类属性记录单例对象引用 instance = None # 定义类属性记录初始化是否调用 init_flag = False def __new__(cls, *args, **kwargs): \"\"\"\"# 创建对象 print(\"创建对象,分配内存空间\") # 分配内存空间 # 返回对象的引用 return super().__new__(cls) \"\"\" # 判断类属性是否是空对象 if cls.instance is None: # 调用父类的方法,为第一个对象分配空间 cls.instance = super().__new__(cls) # 返回类属性保存的对象引用 return cls.instance def __init__(self): \"\"\" # 初始化会被再次调用 print(\"初始化音乐播放器\") \"\"\" # 初始化方法只调用一次 if MusicPlayer.init_flag: return print(\"初始化音乐播放器\") # 修改标记 MusicPlayer.init_flag = Trueplayer = MusicPlayer()print(player)newPlayer = MusicPlayer()print(newPlayer)# 两个对象的地址是一样的 模块模块导入import关键字导入模块，使python文件可供同一目录下的其他python文件使用 1234567891011# 1import 模块名调用：模块名.工具名# 2from 模块名 import 工具名 # 导入指定工具# 如果两个模块存在同名的函数，后导入的模块函数会覆盖先导入的函数# 取别名可以解决冲突# 3from 模块名 import * # 导入模块下所有工具 起别名 import 模块名 as 别名 模块搜索顺序 搜索当前目录指定模块名文件，如果有就直接导入如果没有，再搜索系统目录 在开发时，给文件起名，不要和系统的模块文件重名 Python中每一个模块都有一个内置属性__new__可以查看模块的完整路径 123456import randomprint(random)# &lt;module 'random' from 'D:\\\\Program Files\\\\Python37\\\\lib\\\\random.py'&gt;print(random.__file__)# D:\\Program Files\\Python37\\lib\\random.py 注意：如果当前目录下，存在一个random.py的文件，程序就无法执行 __main__ 与 __name__判断当前是否是主线程 12if __name__==\"__main__\": print(\"当前为主线程\") 搜索路径123import syssys.path #返回路径sys.path.append(路径) #追加需要导入的模块路径:本地路径 包Package 包是一个包含多个模块的特殊的目录 目录下又有一个文件__init__.py 在外界使用包中的模块，需要在__init__.py中对外界提供的模块列表 包名的命名方式和变量名一致，小写字母+_ 制作发布压缩包 创建setup.py文件 123456789101112from distutils.core import setupsetup(name=\"handle_message\", # 包名 version=\"1.0\", # 版本 description=\"描述信息\", long_description=\"完整描述\", author=\"author\", # 作者 author_email=\"email\", # 作者邮箱 url=\"www.xxx.com\", # 主页 py_modules=[ \"handle_message.send_message\", \"handle_message.receive_message\"]) 构建模块 1python setup.py build 生成发布压缩包 1python setup.py sdist 文件文件的读写 序号 函数/方法 说明 1 open 打开文件，并且返回文件操作对象 2 read 将文件内容读取到内存 3 write 将指定内容写入文件 4 close 关闭文件 read / write / close方法需要由文件对象来调用 调用格式 f = open(filename, mode,buffering)filename:文件的路径mode：模式 w 写 r 读 a 追加 （b—-二进制编码）不同模式可以混合向文件中写入f.write(bytes)文件读写完后要关闭 f.close() with open() as file 会自动关闭文件，不需要手动执行.close() 123456789# 以二进制的方式写入图片到本地images文件夹中def crawl_image(image_url, image_local_path): r = requests.get(image_url, stream=True) try: with open(image_local_path, \"wb\") as f: f.write(r.content) # f.close() except UnicodeDecodeError: # 抛出异常 print(\"save error\") 文件指针：第一次打开文件时，通常文件指针会指向文件的开始位置，当执行了read()方法后，文件指针会移动到读取内容的末尾 按行读取文件内容readline() 12345678910file = open(\"../README.txt\")while True: text = file.readline() # 判断是否读取到内容 # if text is None: if not text: break print(text)file.close() 复制文件读取源文件，写入新文件 Python2.x默认使用ASCII编码，Python3.x默认为UTF-8编码，txt编码默认为GBK编码 小文件的复制 123456789# 编码格式为UTF-8origin = open(\"../README.txt\", encoding=\"UTF-8\")new = open(\"../README_NEW.txt\", \"wb\")text = origin.read().encode(\"UTF-8\")new.write(text)origin.close()new.close() 大文件的复制 12345678910111213# 编码格式为UTF-8origin = open(\"../README.txt\", encoding=\"UTF-8\")new = open(\"../README_NEW.txt\", \"wb\")# 读-写while True: text = origin.readline().encode() # 判断是否读取到内容 if not text: break new.write(text)origin.close()new.close() 文件/目录的常用管理操作 导入os模块 文件操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(源文件名,目标文件名) 02 remove 删除文件 os.remove(文件名) 目录操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdit(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改工作目录 os.chdir(目标目录) 06 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示：文件/目录操作都支持绝对路径和相对路径 工具bs4/beautiful soup替代正则beautiful soup tkiner基于视图化ui的模块库 phantomJSPhantomJS是可使用JavaScript编写脚本的无头Web浏览器。它可以在Windows，macOS，Linux和FreeBSD上运行。 使用QtWebKit作为后端，它为各种Web标准提供了快速的本机支持：DOM处理，CSS选择器，JSON，Canvas和SVG。 selenium/webdriver通过模拟浏览器进行网络爬虫的库 requests网络爬虫相关库，适用于静态网页页面的爬取 PIL/Image, ImageTk图片处理库","categories":[],"tags":[]}],"categories":[{"name":"notes","slug":"notes","permalink":"https://lao-biao.github.io/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://lao-biao.github.io/categories/notes/java/"},{"name":"后端","slug":"notes/后端","permalink":"https://lao-biao.github.io/categories/notes/%E5%90%8E%E7%AB%AF/"},{"name":"leetcode","slug":"leetcode","permalink":"https://lao-biao.github.io/categories/leetcode/"},{"name":"语法糖","slug":"notes/java/语法糖","permalink":"https://lao-biao.github.io/categories/notes/java/%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"name":"android","slug":"android","permalink":"https://lao-biao.github.io/categories/android/"},{"name":"hexo","slug":"hexo","permalink":"https://lao-biao.github.io/categories/hexo/"},{"name":"数据结构与算法","slug":"notes/java/数据结构与算法","permalink":"https://lao-biao.github.io/categories/notes/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"android","slug":"notes/android","permalink":"https://lao-biao.github.io/categories/notes/android/"},{"name":"python","slug":"python","permalink":"https://lao-biao.github.io/categories/python/"},{"name":"web","slug":"notes/web","permalink":"https://lao-biao.github.io/categories/notes/web/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://lao-biao.github.io/tags/jvm/"},{"name":"ajax","slug":"ajax","permalink":"https://lao-biao.github.io/tags/ajax/"},{"name":"jsp","slug":"jsp","permalink":"https://lao-biao.github.io/tags/jsp/"},{"name":"el","slug":"el","permalink":"https://lao-biao.github.io/tags/el/"},{"name":"jstl","slug":"jstl","permalink":"https://lao-biao.github.io/tags/jstl/"},{"name":"servlet","slug":"servlet","permalink":"https://lao-biao.github.io/tags/servlet/"},{"name":"AQS","slug":"AQS","permalink":"https://lao-biao.github.io/tags/AQS/"},{"name":"并发编程","slug":"并发编程","permalink":"https://lao-biao.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"redis","slug":"redis","permalink":"https://lao-biao.github.io/tags/redis/"},{"name":"git","slug":"git","permalink":"https://lao-biao.github.io/tags/git/"},{"name":"mybatis","slug":"mybatis","permalink":"https://lao-biao.github.io/tags/mybatis/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://lao-biao.github.io/tags/spring-boot/"},{"name":"spring mvc","slug":"spring-mvc","permalink":"https://lao-biao.github.io/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"https://lao-biao.github.io/tags/spring/"},{"name":"aop","slug":"aop","permalink":"https://lao-biao.github.io/tags/aop/"},{"name":"反射","slug":"反射","permalink":"https://lao-biao.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"泛型","slug":"泛型","permalink":"https://lao-biao.github.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"混合编程","slug":"混合编程","permalink":"https://lao-biao.github.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"https://lao-biao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"xml解析","slug":"xml解析","permalink":"https://lao-biao.github.io/tags/xml%E8%A7%A3%E6%9E%90/"},{"name":"var","slug":"var","permalink":"https://lao-biao.github.io/tags/var/"},{"name":"switch","slug":"switch","permalink":"https://lao-biao.github.io/tags/switch/"},{"name":"try-with-resource","slug":"try-with-resource","permalink":"https://lao-biao.github.io/tags/try-with-resource/"},{"name":"Resource Bundle","slug":"Resource-Bundle","permalink":"https://lao-biao.github.io/tags/Resource-Bundle/"},{"name":"接口方法","slug":"接口方法","permalink":"https://lao-biao.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/"},{"name":"自动装箱与拆箱","slug":"自动装箱与拆箱","permalink":"https://lao-biao.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"},{"name":"多异常并列","slug":"多异常并列","permalink":"https://lao-biao.github.io/tags/%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%B9%B6%E5%88%97/"},{"name":"数值类型赋值优化","slug":"数值类型赋值优化","permalink":"https://lao-biao.github.io/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%B5%8B%E5%80%BC%E4%BC%98%E5%8C%96/"},{"name":"不定项参数","slug":"不定项参数","permalink":"https://lao-biao.github.io/tags/%E4%B8%8D%E5%AE%9A%E9%A1%B9%E5%8F%82%E6%95%B0/"},{"name":"静态导入","slug":"静态导入","permalink":"https://lao-biao.github.io/tags/%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5/"},{"name":"for-each","slug":"for-each","permalink":"https://lao-biao.github.io/tags/for-each/"},{"name":"枚举","slug":"枚举","permalink":"https://lao-biao.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"toast","slug":"toast","permalink":"https://lao-biao.github.io/tags/toast/"},{"name":"log","slug":"log","permalink":"https://lao-biao.github.io/tags/log/"},{"name":"rss","slug":"rss","permalink":"https://lao-biao.github.io/tags/rss/"},{"name":"排序","slug":"排序","permalink":"https://lao-biao.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"查找","slug":"查找","permalink":"https://lao-biao.github.io/tags/%E6%9F%A5%E6%89%BE/"},{"name":"图","slug":"图","permalink":"https://lao-biao.github.io/tags/%E5%9B%BE/"},{"name":"二叉树","slug":"二叉树","permalink":"https://lao-biao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"串","slug":"串","permalink":"https://lao-biao.github.io/tags/%E4%B8%B2/"},{"name":"栈","slug":"栈","permalink":"https://lao-biao.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://lao-biao.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"线性表","slug":"线性表","permalink":"https://lao-biao.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"gitee","slug":"gitee","permalink":"https://lao-biao.github.io/tags/gitee/"},{"name":"giteement","slug":"giteement","permalink":"https://lao-biao.github.io/tags/giteement/"},{"name":"个人博客","slug":"个人博客","permalink":"https://lao-biao.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"动态权限","slug":"动态权限","permalink":"https://lao-biao.github.io/tags/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"},{"name":"recyclerview","slug":"recyclerview","permalink":"https://lao-biao.github.io/tags/recyclerview/"},{"name":"sqlite","slug":"sqlite","permalink":"https://lao-biao.github.io/tags/sqlite/"},{"name":"界面跳转","slug":"界面跳转","permalink":"https://lao-biao.github.io/tags/%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC/"},{"name":"broadcast","slug":"broadcast","permalink":"https://lao-biao.github.io/tags/broadcast/"},{"name":"数据存储","slug":"数据存储","permalink":"https://lao-biao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"ui","slug":"ui","permalink":"https://lao-biao.github.io/tags/ui/"},{"name":"adb","slug":"adb","permalink":"https://lao-biao.github.io/tags/adb/"},{"name":"json","slug":"json","permalink":"https://lao-biao.github.io/tags/json/"},{"name":"chrome抓包","slug":"chrome抓包","permalink":"https://lao-biao.github.io/tags/chrome%E6%8A%93%E5%8C%85/"},{"name":"css","slug":"css","permalink":"https://lao-biao.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://lao-biao.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"https://lao-biao.github.io/tags/javascript/"},{"name":"webdriver","slug":"webdriver","permalink":"https://lao-biao.github.io/tags/webdriver/"},{"name":"requests","slug":"requests","permalink":"https://lao-biao.github.io/tags/requests/"},{"name":"mysql","slug":"mysql","permalink":"https://lao-biao.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://lao-biao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}